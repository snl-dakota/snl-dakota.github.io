<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Dakota Developers Manual" />
<meta name="keywords" content="optimization, uncertainty quantification, model calibration, parameter estimation, sensitivity analysis, parallel computing, developers manual" />
<meta name="sandia.approval_type" content="formal" />
<meta name="sandia.approved" content="2010-2185" />
<link rev="owns" title="Brian M. Adams" href="mailto:briadam@sandia.gov" />
<meta name="Author" content="Brian M. Adams" />
<title>Dakota: Demo TPL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DAKOTA_Arrow_Name_77x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dakota
   &#160;<span id="projectnumber">Version 6.22</span>
   </div>
   <div id="projectbrief">Explore and Predict with Confidence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Demo TPL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__scratch_dakota-jenkins_jenkins_workspace_docs_builder_source_packages_external_demo_tpl_README"></a></p>
<p>This is a simple <em>Demo</em> which serves as a working example for bringing a new Third-Party Library (TPL) into <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>. The <em>Demo</em> will serve to show minimal requirements for:</p>
<ul>
<li>building and running the <em>Demo</em></li>
<li>building a TPL under <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> using CMake</li>
<li>exposing TPL functionality to <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a></li>
<li>exposing TPL options through <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a></li>
<li>transferring data between a TPL and <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a></li>
</ul>
<p>Following this <em>Demo</em>, a developer should be able to integrate an optimization TPL/method that:</p>
<ul>
<li>is derivative-free</li>
<li>operates over continuous variables</li>
<li>supports any of the following types of constraints<ul>
<li>bound constraints</li>
<li>nonlinear inequality constraints</li>
<li>nonlinear equality constraints</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
Quickstart: Building and Running the &lt;em&gt;Demo&lt;/em&gt;</h1>
<p>In order to build and run this <em>Demo</em>, it is necessary to build <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> from source. Complete instructions for doing so can be found at <a href="https://dakota.sandia.gov/content/build-compile-source-code">https://dakota.sandia.gov/content/build-compile-source-code</a>. At the point in the instructions where cmake is invoked, append <code>-DHAVE_DEMO_TPL:BOOL=ON</code> to the cmake invocation.</p>
<p>Building <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> with the <em>Demo</em> TPL enabled will also activate a working example found in <code>$DAKOTA_BUILD/test/dakota_demo_app</code>, where <code>$DAKOTA_BUILD</code> is the root of the <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> build tree. The test can be run from <code>$DAKOTA_BUILD/test</code> using </p><pre class="fragment">      `ctest -R demo_app`
</pre><p>Summary info will be output to the screen, and test artifacts can be found in <code>$DAKOTA_BUILD/test/dakota_demo_app</code>.</p>
<p>Alternatively the example can be run in the same way a user runs <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>. In particular, from the $DAKOTA_BUILD/test/dakota_demo_app directory, issue the following command: </p><pre class="fragment">      `/path/to/dakota -i dakota_demo_app.in`
</pre><p>The remainder of this file describes how to integrate a TPL into <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> using the <em>Demo</em> (found in <code>$DAKOTA_SRC/packages/external/demo_tpl</code>) as an example.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Building a TPL under Dakota using Cmake</h1>
<p>This section shows how to include the relevant parts of the <em>Demo</em> TPL as a library that <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> builds and includes as part of its own native Cmake build.</p>
<p>Assuming the <em>Demo</em> tpl source code has been placed alongside other <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> TPLs in <code>$DAKOTA_SRC/packages/external/demo_tpl</code>, a simple <em>CMakeLists.txt</em> file can be created at this location to allow <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> to include it within its own Cmake setup. An minimal example might include:</p>
<div class="fragment"><div class="line"># File $DAKOTA_SRC/packages/external/demo_tpl/CMakeLists.txt</div>
<div class="line"> </div>
<div class="line">cmake_minimum_required(VERSION 2.8)</div>
<div class="line">project(&quot;DEMO_TPL&quot; CXX)</div>
<div class="line">SUBDIRS(src)</div>
</div><!-- fragment --><p>In the src subdirectory of demo_tpl would be another <em>CMakeLists.txt</em> file which essentially identifies the relevant source code to be compiled into a library along with defining the library which Daktoa will later include, e.g.</p>
<div class="fragment"><div class="line"># File $DAKOTA_SRC/packages/external/demo_tpl/src/CMakeLists.txt</div>
<div class="line"> </div>
<div class="line">set(demo_tpl_HEADERS</div>
<div class="line">    demo_opt.hpp</div>
<div class="line">   )</div>
<div class="line"> </div>
<div class="line">set(demo_tpl_SOURCES</div>
<div class="line">    demo_opt.cpp</div>
<div class="line">   )</div>
<div class="line"> </div>
<div class="line"># Set the DEMO_TPL library name.</div>
<div class="line">add_library(demo_tpl ${demo_tpl_SOURCES})</div>
<div class="line"> </div>
<div class="line"># Define install targets for &quot;make install&quot;</div>
<div class="line">install(TARGETS demo_tpl EXPORT ${ExportTarget} DESTINATION lib)</div>
</div><!-- fragment --><p>Note that it is possible to use Cmake's glob feature to bring in all source and header files, but care must be taken to avoid introducing <code>main(...)</code> symbols which will collide with <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>'s <code>main</code> at link time.</p>
<p>At this point, <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>'s <em>CMakeLists.txt</em> files will need to be modified to include the <em>Demo</em> TPL. The following modifications can be used to bring in the <em>Demo</em> TPL, conditioned on having <code>-DHAVE_DEMO_TPL:BOOL=ON</code> defined when invoking cmake to configure <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>:</p>
<div class="fragment"><div class="line"># File $DAKOTA_SRC/packages/CMakeLists.txt</div>
<div class="line"> </div>
<div class="line">&lt;... snip ...&gt;</div>
<div class="line">  option(HAVE_DEMO_TPL &quot;Build the Demo_TPL package.&quot; OFF)</div>
<div class="line">&lt;... end snip ...&gt;</div>
<div class="line"> </div>
<div class="line">&lt;... snip ...&gt;</div>
<div class="line">  if(HAVE_DEMO_TPL)</div>
<div class="line">    add_subdirectory(external/demo_tpl)</div>
<div class="line">  endif(HAVE_DEMO_TPL)</div>
<div class="line">&lt;... end snip ...&gt;</div>
</div><!-- fragment --><p>This next modification to <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> will allow the <em>Demo</em> TPL to be used by other <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> source code by including the necessary include paths, link-time libraries and needed #defines:</p>
<div class="fragment"><div class="line"># File $DAKOTA_SRC/src/CMakeLists.txt</div>
<div class="line"> </div>
<div class="line">&lt;... snip ...&gt;</div>
<div class="line"> </div>
<div class="line">if(HAVE_DEMO_TPL)</div>
<div class="line">  set(DAKOTA_DEMOTPL_ROOT_DIR &quot;${Dakota_SOURCE_DIR}/packages/external/demo_tpl&quot;)</div>
<div class="line">  list(APPEND DAKOTA_INCDIRS </div>
<div class="line">      ${DAKOTA_DEMOTPL_ROOT_DIR}/dakota_src</div>
<div class="line">      ${DAKOTA_DEMOTPL_ROOT_DIR}/src)</div>
<div class="line">set(iterator_src ${iterator_src} ${Dakota_SOURCE_DIR}/packages/external/demo_tpl/dakota_src/DemoOptimizer.cpp)</div>
<div class="line">  list(APPEND DAKOTA_PKG_LIBS demo_tpl)</div>
<div class="line">list(APPEND EXPORT_TARGETS demo_tpl)</div>
<div class="line">  add_definitions(&quot;-DHAVE_DEMO_TPL&quot;)</div>
<div class="line">endif(HAVE_DEMO_TPL)</div>
<div class="line"> </div>
<div class="line">&lt;... end snip ...&gt;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14"></a>
Test-Driven Code Development</h1>
<p>Before making concrete changes, it is often helpful to create a simple <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> test which will serve to guide the process. This is akin to test-driven development which essentially creates a test which fails until everything has been implemented to allow it to run and pass. A candidate test for the current activity could be the following:</p>
<div class="fragment"><div class="line"># File $DAKOTA_SRC/test/dakota_demo_app.in</div>
<div class="line"> </div>
<div class="line">    method,</div>
<div class="line">        demo_tpl</div>
<div class="line">        options_file = &quot;demo_tpl.opts&quot;</div>
<div class="line"> </div>
<div class="line">    variables,</div>
<div class="line">        continuous_design = 3</div>
<div class="line">        initial_point      -1.0    1.5   2.0</div>
<div class="line">        upper_bounds       10.0   10.0  10.0</div>
<div class="line">        lower_bounds       -10.0  -10.0 -10.0</div>
<div class="line">        descriptors         &#39;x1&#39;  &#39;x2&#39;  &#39;x3&#39;</div>
<div class="line"> </div>
<div class="line">    interface,</div>
<div class="line">        direct</div>
<div class="line">        analysis_driver = &#39;text_book&#39;</div>
<div class="line"> </div>
<div class="line">    responses,</div>
<div class="line">        objective_functions = 1</div>
<div class="line">        no_gradients</div>
<div class="line">        no_hessians</div>
</div><!-- fragment --><p>For this test to run, we will need to be able to pass parsed options to the <em>Demo</em> TPL and exchange parameters and response values between <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> and <em>Demo</em> TPL. These details are presented in the following sections.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Exposing TPL Functionality to Dakota</h1>
<p><a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> performs some internal checks in order to confirm applicability of a specified method to the problem defined. In order for <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> to perform those checks for the <em>Demo</em> TPL, the functionality of the method must be communicated to <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>. That is done via implementation of a traits class. Traits define the types of problems and data formats the <em>Demo</em> TPL supports by overriding the default traits accessors in TraitsBase. By default, nothing is supported, and the TPL integrator must explicitly turn on the traits for any supported features.</p>
<div class="fragment"><div class="line"><span class="comment">// File $DAKOTA_SRC/packages/external/demo_tpl/dakota_src/DemoOptimizer.hpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DemoOptTraits: <span class="keyword">public</span> TraitsBase</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  &lt;... snip ...&gt;</div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">//- Heading: Constructor and destructor</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  DemoOptTraits() { }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> ~DemoOptTraits() { }</div>
<div class="line">  &lt;... end snip ...&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;... snip ...&gt;</div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">//- Heading: Virtual member function redefinitions</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> supports_continuous_variables()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">  &lt;... end snip ...&gt;</div>
<div class="line">}; <span class="comment">// class DemoOptTraits</span></div>
</div><!-- fragment --><p>A complete list of traits can be found in <code>$DAKOTA_SRC/src/DakotaTraitsBase.hpp</code>. The subset applicable to the <em>Demo</em> TPL can be found in <code>$DAKOTA_SRC/packages/external/demo_tpl/dakota_src/DemoOptimizer.hpp</code>.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Exposing TPL Options Through Dakota</h1>
<p>The simplest way to pass options to a TPL is via a file. The <em>Demo</em> TPL has the ability to read in a file of method options when given a file name. This file name can be specified in the <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> input file and retrieved as illustrated below.</p>
<div class="fragment"><div class="line"><span class="comment">// File $DAKOTA_SRC/packages/external/demo_tpl/dakota_src/DemoOptimizer.cpp</span></div>
<div class="line"> </div>
<div class="line">  &lt;... snip ...&gt;</div>
<div class="line">  <span class="comment">// Check for native Demo_Opt input file.  The file name needs to be</span></div>
<div class="line">  <span class="comment">// included in the Dakota input file.</span></div>
<div class="line">  String adv_opts_file = probDescDB.get_string(<span class="stringliteral">&quot;method.advanced_options_file&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (!adv_opts_file.empty())</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (!boost::filesystem::exists(adv_opts_file))</div>
<div class="line">    {</div>
<div class="line">      Cerr &lt;&lt; <span class="stringliteral">&quot;\nError: Demo_Opt options_file &#39;&quot;</span> &lt;&lt; adv_opts_file</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;&#39; specified, but file not found.\n&quot;</span>;</div>
<div class="line">      <a class="code" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">abort_handler</a>(METHOD_ERROR);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  &lt;... end snip ...&gt;</div>
</div><!-- fragment --><p>If desired, common stopping criteria can be retrieved from the <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> input file, rather than passed through a TPL-specific input file, as follows.</p>
<div class="fragment"><div class="line"><span class="comment">// File $DAKOTA_SRC/packages/external/demo_tpl/dakota_src/DemoOptimizer.cpp</span></div>
<div class="line"> </div>
<div class="line">  &lt;... snip ...&gt;</div>
<div class="line">  get_common_stopping_criteria(max_fn_evals, max_iters, conv_tol,</div>
<div class="line">  min_var_chg, obj_target );</div>
<div class="line">  &lt;... end snip ...&gt;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md17"></a>
Exchanging Parameters and Reponses</h1>
<p>Like any TPL, the <em>Demo</em> TPL will need to exchange parameter and obective function values with <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>. For purposes of demonstration, an example interface between <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> and the <em>Demo</em> TPL can be seen in <code>$DAKOTA_SRC/packages/external/demo_tpl/dakota_src/DemoOptimizer.hpp</code> (with corresponding .cpp in the same directory). Within these files is a key callback interface used by the <em>Demo</em> TPL to obtain objective function values for given parameter values (3 in the test above), eg:</p>
<div class="fragment"><div class="line"><span class="comment">// File $DAKOTA_SRC/packages/external/demo_tpl/dakota_src/DemoOptimizer.cpp</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespacedakota.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a></div>
<div class="line">DemoTPLOptimizer::compute_obj(<span class="keyword">const</span> std::vector&lt;double&gt; &amp; x, <span class="keywordtype">bool</span> verbose)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Tell Dakota what variable values to use for the function</span></div>
<div class="line">  <span class="comment">// valuation.  x must be (converted to) a std::vector&lt;double&gt; to use</span></div>
<div class="line">  <span class="comment">// this demo with minimal changes.</span></div>
<div class="line">  set_variables&lt;&gt;(x, iteratedModel, iteratedModel.current_variables());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluate the function at the specified x.</span></div>
<div class="line">  iteratedModel.evaluate();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Retrieve the the function value and sign it appropriately based</span></div>
<div class="line">  <span class="comment">// on whether minimize or maximize has been specified in the Dakota</span></div>
<div class="line">  <span class="comment">// input file.</span></div>
<div class="line">  <span class="keywordtype">double</span> f = dataTransferHandler-&gt;get_response_value_from_dakota(iteratedModel.current_response());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> f;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this instance, the <em>Demo</em> TPL uses <code>std::vector&lt;double&gt;</code> as its native parameter vector data type and is calling back to the example problem (<a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> model) via an interface to <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> to obtain a single <code>double</code> (aliased to <code>Real</code> in <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>) obective function value for a given set of parameter values. These data exchanges are facilitated by used of "data adapters" supplied by <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> with the <code>set_variables&lt;&gt;(...)</code> utility and <code>dataTransferHandler</code> helper class utilized in this case.</p>
<p>For problems involving nonlinear equality and inequality constraints <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> treats these as additional responses to the objective funtction(s). The <em>Demo</em> TPL supports both types for purposes of showing how these additional responses can be computed by <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> (via interface to an underlying model) and transferred to the TPL. Similar to the call (by <em>Demo</em>) to <code>compute_obj(...)</code> are two additional methods to compute and transfer nonlinear constraint responses, eg:</p>
<div class="fragment"><div class="line"><span class="comment">// File $DAKOTA_SRC/packages/external/demo_tpl/dakota_src/DemoOptimizer.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">DemoTPLOptimizer::compute_nln_eq(std::vector&lt;Real&gt; &amp;c, <span class="keyword">const</span> std::vector&lt;Real&gt; &amp;x, <span class="keywordtype">bool</span> verbose)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Tell Dakota what variable values to use for the nonlinear constraint</span></div>
<div class="line">  <span class="comment">// evaluations.  x must be (converted to) a std::vector&lt;double&gt; to use</span></div>
<div class="line">  <span class="comment">// this demo with minimal changes.</span></div>
<div class="line">  set_variables&lt;&gt;(x, iteratedModel, iteratedModel.current_variables());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluate the function at the specified x.</span></div>
<div class="line">  iteratedModel.evaluate();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use an adapter to copy data</span></div>
<div class="line">  dataTransferHandler-&gt;get_nonlinear_eq_constraints_from_dakota(iteratedModel.current_response(), c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">DemoTPLOptimizer::compute_nln_ineq(std::vector&lt;Real&gt; &amp;c, <span class="keyword">const</span> std::vector&lt;Real&gt; &amp;x, <span class="keywordtype">bool</span> verbose)</div>
<div class="line">{</div>
<div class="line">  set_variables&lt;&gt;(x, iteratedModel, iteratedModel.current_variables());</div>
<div class="line">  iteratedModel.evaluate();</div>
<div class="line">  dataTransferHandler-&gt;get_nonlinear_ineq_constraints_from_dakota(iteratedModel.current_response(), c);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Both of these callback methods (to <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>), <code>compute_nln_eq(...)</code> and <code>compute_nln_ineq(...)</code> follow the same pattern as seen for the objective function callback: 1) set the <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> model with the current variables (parameters), 2) evaluate the model and 3) transfer the desired response (objective or constraint) back to the TPL. The third step is facilitated by the appropriate call to the <code>dataTransferHandler</code> helper class. It should be noted that even though as many as three separate calls to evaluate the model are made for the same parameter values, <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> maintains an internal cache of response values for each unique set. The model will be evaluated the first time a new set of parameter values is provided, but the cached values will simply be returned thereafter, thereby avoiding superfluous model evaluations.</p>
<p><a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> must also provide initial parameter values to the <em>Demo</em> TPL and retrieve final objective function and variable values from the <em>Demo</em> TPL. The initial values for parameters and bound constraints can be obtained from <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> with the <code>get_variables&lt;&gt;(...)</code> helpers. This example returns the values to a standard vector of doubles (Reals). These values can then be passed to the <em>Demo</em> TPL using whatever API is provided. The API for this last step varies with the particular TPL, and <em>Demo</em> provides a function <code>set_problem_data</code> in this case.</p>
<div class="fragment"><div class="line"><span class="comment">// File $DAKOTA_SRC/packages/external/demo_tpl/dakota_src/DemoOptimizer.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> DemoTPLOptimizer::initialize_variables_and_constraints()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Get the number of variables, the initial values, and the values</span></div>
<div class="line">  <span class="comment">// of bound constraints.  They are returned to standard C++ data</span></div>
<div class="line">  <span class="comment">// types.  This example considers only continuous variables.  Other</span></div>
<div class="line">  <span class="comment">// types of variables and constraints will be added at a later time.</span></div>
<div class="line">  <span class="comment">// Note that double is aliased to Real in Dakota.</span></div>
<div class="line">  <span class="keywordtype">int</span> num_total_vars = numContinuousVars;</div>
<div class="line">  std::vector&lt;Real&gt; init_point(num_total_vars);</div>
<div class="line">  std::vector&lt;Real&gt; lower(num_total_vars),</div>
<div class="line">                    upper(num_total_vars);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// More on DemoOptTraits can be found in DemoOptimizer.hpp.</span></div>
<div class="line">  <a class="code" href="namespaceDakota.html#a1f9e7b85b593ed93d049bc0a81e96520">get_variables</a>(iteratedModel, init_point);</div>
<div class="line">  get_variable_bounds_from_dakota&lt;DemoOptTraits&gt;( lower, upper );</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Replace this line by whatever the TPL being integrated uses to</span></div>
<div class="line">  <span class="comment">// ingest variable values and bounds, including any data type</span></div>
<div class="line">  <span class="comment">// conversion needed.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ------------------  TPL_SPECIFIC  ------------------</span></div>
<div class="line">  demoOpt-&gt;set_problem_data(init_point,   <span class="comment">//  &quot;Initial Guess&quot;</span></div>
<div class="line">                            lower     ,   <span class="comment">//  &quot;Lower Bounds&quot;</span></div>
<div class="line">                            upper      ); <span class="comment">//  &quot;Upper Bounds&quot;</span></div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>The TPL should be able to return an optimal objective function value and the corresponding variable (parameter) values via its API. As has been the case throughout, the data should be doubles (aliased to Real in <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>). The following code takes the values returned by <em>Demo</em> via a call to <code>get_best_f()</code> and sets the <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> data structures that contain final objective and variable values. It adjusts the sign of the objective based on whether minimize or maximize has been specified in the <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> input file (minimize is the default). If the problem being optimized involves nonlinear equality and/or inequality constraints, these will also need to be obtained from the TPL and passed to <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> as part of the array of best function values (responses).</p>
<div class="fragment"><div class="line"><span class="comment">// File $DAKOTA_SRC/packages/external/demo_tpl/dakota_src/DemoOptimizer.cpp</span></div>
<div class="line"><span class="comment">// in method void DemoTPLOptimizer::core_run()</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Replace this line with however the TPL being incorporated returns</span></div>
<div class="line">  <span class="comment">// the optimal function value.  To use this demo with minimal</span></div>
<div class="line">  <span class="comment">// changes, the returned value needs to be (converted to) a</span></div>
<div class="line">  <span class="comment">// double.</span></div>
<div class="line">  <span class="keywordtype">double</span> best_f = demoOpt-&gt;get_best_f(); <span class="comment">// TPL_SPECIFIC</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If the TPL defaults to doing minimization, no need to do</span></div>
<div class="line">  <span class="comment">// anything with this code.  It manages needed sign changes</span></div>
<div class="line">  <span class="comment">// depending on whether minimize or maximize has been specified in</span></div>
<div class="line">  <span class="comment">// the Dakota input file.</span></div>
<div class="line">  <span class="keyword">const</span> BoolDeque&amp; max_sense = iteratedModel.primary_response_fn_sense();</div>
<div class="line">  <a class="code" href="namespacedakota.html#a77b2775985ff72df0799f4fdbd53a270">RealVector</a> best_fns(iteratedModel.response_size()); <span class="comment">// includes nonlinear contraints</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get best (single) objcetive value respecting max/min expectations</span></div>
<div class="line">  best_fns[0] = (!max_sense.empty() &amp;&amp; max_sense[0]) ?  -best_f : best_f;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get best Nonlinear Equality Constraints from TPL</span></div>
<div class="line">  <span class="keywordflow">if</span>( numNonlinearEqConstraints &gt; 0 )</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> best_nln_eqs = demoOpt-&gt;get_best_nln_eqs(); <span class="comment">// TPL_SPECIFIC</span></div>
<div class="line">    dataTransferHandler-&gt;get_best_nonlinear_eq_constraints_from_tpl(</div>
<div class="line">                                        best_nln_eqs,</div>
<div class="line">                                        best_fns);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get best Nonlinear Inequality Constraints from TPL</span></div>
<div class="line">  <span class="keywordflow">if</span>( numNonlinearIneqConstraints &gt; 0 )</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> best_nln_ineqs = demoOpt-&gt;get_best_nln_ineqs(); <span class="comment">// TPL_SPECIFIC</span></div>
<div class="line"> </div>
<div class="line">    dataTransferHandler-&gt;get_best_nonlinear_ineq_constraints_from_tpl(</div>
<div class="line">                                        best_nln_ineqs,</div>
<div class="line">                                        best_fns);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  bestResponseArray.front().function_values(best_fns);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;double&gt; best_x = demoOpt-&gt;get_best_x(); <span class="comment">// TPL_SPECIFIC</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set Dakota optimal value data.</span></div>
<div class="line">  set_variables&lt;&gt;(best_x, iteratedModel, bestVariablesArray.front());</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespacedakota_html_a77b2775985ff72df0799f4fdbd53a270"><div class="ttname"><a href="namespacedakota.html#a77b2775985ff72df0799f4fdbd53a270">dakota::RealVector</a></div><div class="ttdeci">Teuchos::SerialDenseVector&lt; int, Real &gt; RealVector</div><div class="ttdoc">Dakota vector of reals.</div><div class="ttdef"><b>Definition:</b> util_data_types.hpp:62</div></div>
<div class="ttc" id="anamespacedakota_html_a4b04262b81aa7d31eb5d2f607e2a35de"><div class="ttname"><a href="namespacedakota.html#a4b04262b81aa7d31eb5d2f607e2a35de">dakota::Real</a></div><div class="ttdeci">double Real</div><div class="ttdoc">Dakota real floating point type.</div><div class="ttdef"><b>Definition:</b> util_data_types.hpp:58</div></div>
<div class="ttc" id="anamespaceDakota_html_acff531cb7537cad348ae92c039e02d99"><div class="ttname"><a href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler</a></div><div class="ttdeci">void abort_handler(int code)</div><div class="ttdoc">global function which handles serial or parallel aborts</div><div class="ttdef"><b>Definition:</b> dakota_global_defs.cpp:86</div></div>
<div class="ttc" id="anamespaceDakota_html_a1f9e7b85b593ed93d049bc0a81e96520"><div class="ttname"><a href="namespaceDakota.html#a1f9e7b85b593ed93d049bc0a81e96520">Dakota::get_variables</a></div><div class="ttdeci">void get_variables(Model &amp;model, VectorType &amp;vec)</div><div class="ttdef"><b>Definition:</b> DakotaOptimizer.hpp:841</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
