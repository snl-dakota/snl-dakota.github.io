<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Dakota Developers Manual" />
<meta name="keywords" content="optimization, uncertainty quantification, model calibration, parameter estimation, sensitivity analysis, parallel computing, developers manual" />
<meta name="sandia.approval_type" content="formal" />
<meta name="sandia.approved" content="2010-2185" />
<link rev="owns" title="Brian M. Adams" href="mailto:briadam@sandia.gov" />
<meta name="Author" content="Brian M. Adams" />
<title>Dakota: DataMethodRep Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DAKOTA_Arrow_Name_77x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dakota
   &#160;<span id="projectnumber">Version 6.22</span>
   </div>
   <div id="projectbrief">Explore and Predict with Confidence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDakota.html">Dakota</a></li><li class="navelem"><a class="el" href="classDakota_1_1DataMethodRep.html">DataMethodRep</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDakota_1_1DataMethodRep-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataMethodRep Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Body class for method specification data.  
 <a href="classDakota_1_1DataMethodRep.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a076b5951131d5287153ac83e303f967a"><td class="memItemLeft" align="right" valign="top"><a id="a076b5951131d5287153ac83e303f967a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a076b5951131d5287153ac83e303f967a">~DataMethodRep</a> ()</td></tr>
<tr class="memdesc:a076b5951131d5287153ac83e303f967a"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a076b5951131d5287153ac83e303f967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad57f4e45a552e247f3f7d80134b9212b"><td class="memItemLeft" align="right" valign="top"><a id="ad57f4e45a552e247f3f7d80134b9212b"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad57f4e45a552e247f3f7d80134b9212b">idMethod</a></td></tr>
<tr class="memdesc:ad57f4e45a552e247f3f7d80134b9212b"><td class="mdescLeft">&#160;</td><td class="mdescRight">string identifier for the method specification data set (from the <code>id_method</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:ad57f4e45a552e247f3f7d80134b9212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a5f809dc7f4d8d5c59f31f542f16f4"><td class="memItemLeft" align="right" valign="top"><a id="a01a5f809dc7f4d8d5c59f31f542f16f4"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a01a5f809dc7f4d8d5c59f31f542f16f4">modelPointer</a></td></tr>
<tr class="memdesc:a01a5f809dc7f4d8d5c59f31f542f16f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">string pointer to the model specification to be used by this method (from the <code>model_pointer</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:a01a5f809dc7f4d8d5c59f31f542f16f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2495b4a1ce9ebf0a7fbe25a35221e38"><td class="memItemLeft" align="right" valign="top"><a id="aa2495b4a1ce9ebf0a7fbe25a35221e38"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa2495b4a1ce9ebf0a7fbe25a35221e38">lowFidModelPointer</a></td></tr>
<tr class="memdesc:aa2495b4a1ce9ebf0a7fbe25a35221e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">string to point to the low fidelity model for Bayesian experimental design <br /></td></tr>
<tr class="separator:aa2495b4a1ce9ebf0a7fbe25a35221e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4b46aa54158e3e59700f3ab7215c4a"><td class="memItemLeft" align="right" valign="top"><a id="a7f4b46aa54158e3e59700f3ab7215c4a"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7f4b46aa54158e3e59700f3ab7215c4a">methodOutput</a></td></tr>
<tr class="memdesc:a7f4b46aa54158e3e59700f3ab7215c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">method verbosity control: {SILENT,QUIET,NORMAL,VERBOSE,DEBUG}_OUTPUT (from the <code>output</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:a7f4b46aa54158e3e59700f3ab7215c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3fa2e38847b23885acf3833f28538e"><td class="memItemLeft" align="right" valign="top"><a id="adb3fa2e38847b23885acf3833f28538e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#adb3fa2e38847b23885acf3833f28538e">maxIterations</a></td></tr>
<tr class="memdesc:adb3fa2e38847b23885acf3833f28538e"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of iterations allowed for the method (from the <code>max_iterations</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:adb3fa2e38847b23885acf3833f28538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3fbf07590a9d712de42dc3ecb5a3d2"><td class="memItemLeft" align="right" valign="top"><a id="a8a3fbf07590a9d712de42dc3ecb5a3d2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8a3fbf07590a9d712de42dc3ecb5a3d2">maxRefineIterations</a></td></tr>
<tr class="memdesc:a8a3fbf07590a9d712de42dc3ecb5a3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of refinement iterations allowed for a uniform/adaptive refinement approach (from the <code>max_refinement_iterations</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:a8a3fbf07590a9d712de42dc3ecb5a3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0521979046813abe0fc9b128094833"><td class="memItemLeft" align="right" valign="top"><a id="a4f0521979046813abe0fc9b128094833"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4f0521979046813abe0fc9b128094833">maxSolverIterations</a></td></tr>
<tr class="memdesc:a4f0521979046813abe0fc9b128094833"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of internal solver iterations allowed for the method (from the <code>max_solver_iterations</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:a4f0521979046813abe0fc9b128094833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772b823c5878978abc5cd6985a9db3c2"><td class="memItemLeft" align="right" valign="top"><a id="a772b823c5878978abc5cd6985a9db3c2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a772b823c5878978abc5cd6985a9db3c2">maxFunctionEvals</a></td></tr>
<tr class="memdesc:a772b823c5878978abc5cd6985a9db3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of function evaluations allowed for the method (from the <code>max_function_evaluations</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:a772b823c5878978abc5cd6985a9db3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde579932a306795d351892e166a0d72"><td class="memItemLeft" align="right" valign="top"><a id="adde579932a306795d351892e166a0d72"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#adde579932a306795d351892e166a0d72">speculativeFlag</a></td></tr>
<tr class="memdesc:adde579932a306795d351892e166a0d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for use of speculative gradient approaches for maintaining parallel load balance during the line search portion of optimization algorithms (from the <code>speculative</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:adde579932a306795d351892e166a0d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e897f342305a30c2a13bf09d84f2a1"><td class="memItemLeft" align="right" valign="top"><a id="ac8e897f342305a30c2a13bf09d84f2a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac8e897f342305a30c2a13bf09d84f2a1">methodUseDerivsFlag</a></td></tr>
<tr class="memdesc:ac8e897f342305a30c2a13bf09d84f2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for usage of derivative data to enhance the computation of surrogate models (PCE/SC expansions, GP models for EGO/EGRA/EGIE) based on the <code>use_derivatives</code> specification <br /></td></tr>
<tr class="separator:ac8e897f342305a30c2a13bf09d84f2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a0c305c73a00f74273e27ab9a8ccc2"><td class="memItemLeft" align="right" valign="top"><a id="a81a0c305c73a00f74273e27ab9a8ccc2"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a81a0c305c73a00f74273e27ab9a8ccc2">constraintTolerance</a></td></tr>
<tr class="memdesc:a81a0c305c73a00f74273e27ab9a8ccc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">tolerance for controlling the amount of infeasibility that is allowed before an active constraint is considered to be violated (from the <code>constraint_tolerance</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:a81a0c305c73a00f74273e27ab9a8ccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f4e92f5495e1cfc628e96ca2645326"><td class="memItemLeft" align="right" valign="top"><a id="af2f4e92f5495e1cfc628e96ca2645326"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af2f4e92f5495e1cfc628e96ca2645326">methodScaling</a></td></tr>
<tr class="memdesc:af2f4e92f5495e1cfc628e96ca2645326"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating scaling status (from the <code>scaling</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:af2f4e92f5495e1cfc628e96ca2645326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb375f251603904ac6f0f1d7d9834bb3"><td class="memItemLeft" align="right" valign="top"><a id="abb375f251603904ac6f0f1d7d9834bb3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abb375f251603904ac6f0f1d7d9834bb3">numFinalSolutions</a></td></tr>
<tr class="memdesc:abb375f251603904ac6f0f1d7d9834bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of final solutions returned from the iterator <br /></td></tr>
<tr class="separator:abb375f251603904ac6f0f1d7d9834bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f40750bd07c226df6a04262fba3cd5"><td class="memItemLeft" align="right" valign="top"><a id="ad3f40750bd07c226df6a04262fba3cd5"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad3f40750bd07c226df6a04262fba3cd5">convergenceTolerance</a></td></tr>
<tr class="memdesc:ad3f40750bd07c226df6a04262fba3cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration convergence tolerance for the method (from the <code>convergence_tolerance</code> specification in MethodIndControl) <br /></td></tr>
<tr class="separator:ad3f40750bd07c226df6a04262fba3cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c00c25f3a3dbf737bd05c42b439e3e2"><td class="memItemLeft" align="right" valign="top"><a id="a2c00c25f3a3dbf737bd05c42b439e3e2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2c00c25f3a3dbf737bd05c42b439e3e2">relativeConvMetric</a></td></tr>
<tr class="memdesc:a2c00c25f3a3dbf737bd05c42b439e3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls use of convergence tolerance in a relative (true) or absolute (false) context <br /></td></tr>
<tr class="separator:a2c00c25f3a3dbf737bd05c42b439e3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ad7ba52b99d8a70369009fde0427f1"><td class="memItemLeft" align="right" valign="top"><a id="a31ad7ba52b99d8a70369009fde0427f1"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a31ad7ba52b99d8a70369009fde0427f1">statsMetricMode</a></td></tr>
<tr class="memdesc:a31ad7ba52b99d8a70369009fde0427f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">mode of computing statistics metrics used for convergence assessment of multilevel/multifidelity refinement processes: active or combined <br /></td></tr>
<tr class="separator:a31ad7ba52b99d8a70369009fde0427f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232e81b24a57f058b946705f9885a44a"><td class="memItemLeft" align="right" valign="top"><a id="a232e81b24a57f058b946705f9885a44a"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a232e81b24a57f058b946705f9885a44a">methodName</a></td></tr>
<tr class="memdesc:a232e81b24a57f058b946705f9885a44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the method selection: one of the optimizer, least squares, nond, dace, or parameter study methods <br /></td></tr>
<tr class="separator:a232e81b24a57f058b946705f9885a44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b182cf1588640b1d017e93b3318dd4"><td class="memItemLeft" align="right" valign="top"><a id="a75b182cf1588640b1d017e93b3318dd4"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a75b182cf1588640b1d017e93b3318dd4">subMethod</a></td></tr>
<tr class="memdesc:a75b182cf1588640b1d017e93b3318dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum value for a sub-method type <br /></td></tr>
<tr class="separator:a75b182cf1588640b1d017e93b3318dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8274f8440e2d98fd838325891d73926"><td class="memItemLeft" align="right" valign="top"><a id="ac8274f8440e2d98fd838325891d73926"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac8274f8440e2d98fd838325891d73926">subMethodName</a></td></tr>
<tr class="memdesc:ac8274f8440e2d98fd838325891d73926"><td class="mdescLeft">&#160;</td><td class="mdescRight">string identifier for a sub-method name within a multi-option method specification (e.g., from meta-iterators) <br /></td></tr>
<tr class="separator:ac8274f8440e2d98fd838325891d73926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413da5212ccc43c56759bfc51a864b92"><td class="memItemLeft" align="right" valign="top"><a id="a413da5212ccc43c56759bfc51a864b92"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a413da5212ccc43c56759bfc51a864b92">subModelPointer</a></td></tr>
<tr class="memdesc:a413da5212ccc43c56759bfc51a864b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">string pointer for a sub-model specification used by a meta-iterator <br /></td></tr>
<tr class="separator:a413da5212ccc43c56759bfc51a864b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34c1c5ced9f014698ff9521bff47730"><td class="memItemLeft" align="right" valign="top"><a id="ad34c1c5ced9f014698ff9521bff47730"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad34c1c5ced9f014698ff9521bff47730">subMethodPointer</a></td></tr>
<tr class="memdesc:ad34c1c5ced9f014698ff9521bff47730"><td class="mdescLeft">&#160;</td><td class="mdescRight">string pointer for a sub-method specification used by a meta-iterator <br /></td></tr>
<tr class="separator:ad34c1c5ced9f014698ff9521bff47730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab24886d4f36f241207c058b86c8a3d0"><td class="memItemLeft" align="right" valign="top"><a id="aab24886d4f36f241207c058b86c8a3d0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aab24886d4f36f241207c058b86c8a3d0">iteratorServers</a></td></tr>
<tr class="memdesc:aab24886d4f36f241207c058b86c8a3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of servers for concurrent iterator parallelism (from the <code>iterator_servers</code> specification) <br /></td></tr>
<tr class="separator:aab24886d4f36f241207c058b86c8a3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432ffa52174dc1fc45eef54a0e46c873"><td class="memItemLeft" align="right" valign="top"><a id="a432ffa52174dc1fc45eef54a0e46c873"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a432ffa52174dc1fc45eef54a0e46c873">procsPerIterator</a></td></tr>
<tr class="memdesc:a432ffa52174dc1fc45eef54a0e46c873"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of processors for each concurrent iterator partition (from the <code>processors_per_iterator</code> specification) <br /></td></tr>
<tr class="separator:a432ffa52174dc1fc45eef54a0e46c873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae793b078d1ed1301588506725ad1738e"><td class="memItemLeft" align="right" valign="top"><a id="ae793b078d1ed1301588506725ad1738e"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae793b078d1ed1301588506725ad1738e">iteratorScheduling</a></td></tr>
<tr class="memdesc:ae793b078d1ed1301588506725ad1738e"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of scheduling used in concurrent iterator parallelism (from the <code>iterator_scheduling</code> specification) <br /></td></tr>
<tr class="separator:ae793b078d1ed1301588506725ad1738e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561c53a3464779e4384e11aa82ce5960"><td class="memItemLeft" align="right" valign="top"><a id="a561c53a3464779e4384e11aa82ce5960"></a>
StringArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a561c53a3464779e4384e11aa82ce5960">hybridMethodNames</a></td></tr>
<tr class="memdesc:a561c53a3464779e4384e11aa82ce5960"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of methods for the sequential and collaborative hybrid meta-iterators (from the <code>method_name_list</code> specification) <br /></td></tr>
<tr class="separator:a561c53a3464779e4384e11aa82ce5960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cd8b3ae7f353ee7205a45b759d291c"><td class="memItemLeft" align="right" valign="top"><a id="a28cd8b3ae7f353ee7205a45b759d291c"></a>
StringArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a28cd8b3ae7f353ee7205a45b759d291c">hybridModelPointers</a></td></tr>
<tr class="memdesc:a28cd8b3ae7f353ee7205a45b759d291c"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of models for the sequential and collaborative hybrid meta-iterators (from the <code>model_pointer_list</code> specification) <br /></td></tr>
<tr class="separator:a28cd8b3ae7f353ee7205a45b759d291c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c7a0a6f95b615f02841f13fa9e6549"><td class="memItemLeft" align="right" valign="top"><a id="a57c7a0a6f95b615f02841f13fa9e6549"></a>
StringArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a57c7a0a6f95b615f02841f13fa9e6549">hybridMethodPointers</a></td></tr>
<tr class="memdesc:a57c7a0a6f95b615f02841f13fa9e6549"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of methods for the sequential and collaborative hybrid meta-iterators (from the <code>method_pointer_list</code> specification) <br /></td></tr>
<tr class="separator:a57c7a0a6f95b615f02841f13fa9e6549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d79a1555aa7da82e499b843a1b8b59"><td class="memItemLeft" align="right" valign="top"><a id="a83d79a1555aa7da82e499b843a1b8b59"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a83d79a1555aa7da82e499b843a1b8b59">hybridGlobalMethodName</a></td></tr>
<tr class="memdesc:a83d79a1555aa7da82e499b843a1b8b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">global method name for embedded hybrids (from the <code>global_method_name</code> specification) <br /></td></tr>
<tr class="separator:a83d79a1555aa7da82e499b843a1b8b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8a30fe4050a3af14cf2aad38ca55a4"><td class="memItemLeft" align="right" valign="top"><a id="a3a8a30fe4050a3af14cf2aad38ca55a4"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3a8a30fe4050a3af14cf2aad38ca55a4">hybridGlobalModelPointer</a></td></tr>
<tr class="memdesc:a3a8a30fe4050a3af14cf2aad38ca55a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">global model pointer for embedded hybrids (from the <code>global_model_pointer</code> specification) <br /></td></tr>
<tr class="separator:a3a8a30fe4050a3af14cf2aad38ca55a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0ff7855952afdafcf1060d329216ac"><td class="memItemLeft" align="right" valign="top"><a id="a3e0ff7855952afdafcf1060d329216ac"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3e0ff7855952afdafcf1060d329216ac">hybridGlobalMethodPointer</a></td></tr>
<tr class="memdesc:a3e0ff7855952afdafcf1060d329216ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">global method pointer for embedded hybrids (from the <code>global_method_pointer</code> specification) <br /></td></tr>
<tr class="separator:a3e0ff7855952afdafcf1060d329216ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac120e837991d3622d89a3663b7360c50"><td class="memItemLeft" align="right" valign="top"><a id="ac120e837991d3622d89a3663b7360c50"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac120e837991d3622d89a3663b7360c50">hybridLocalMethodName</a></td></tr>
<tr class="memdesc:ac120e837991d3622d89a3663b7360c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">local method name for embedded hybrids (from the <code>local_method_name</code> specification) <br /></td></tr>
<tr class="separator:ac120e837991d3622d89a3663b7360c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d67ee55d3ccaeb1fe3bf74672c6fd0"><td class="memItemLeft" align="right" valign="top"><a id="ae3d67ee55d3ccaeb1fe3bf74672c6fd0"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae3d67ee55d3ccaeb1fe3bf74672c6fd0">hybridLocalModelPointer</a></td></tr>
<tr class="memdesc:ae3d67ee55d3ccaeb1fe3bf74672c6fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">local model pointer for embedded hybrids (from the <code>local_model_pointer</code> specification) <br /></td></tr>
<tr class="separator:ae3d67ee55d3ccaeb1fe3bf74672c6fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23643edb05e992586cf2aeb4ccd5c905"><td class="memItemLeft" align="right" valign="top"><a id="a23643edb05e992586cf2aeb4ccd5c905"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a23643edb05e992586cf2aeb4ccd5c905">hybridLocalMethodPointer</a></td></tr>
<tr class="memdesc:a23643edb05e992586cf2aeb4ccd5c905"><td class="mdescLeft">&#160;</td><td class="mdescRight">local method pointer for embedded hybrids (from the <code>local_method_pointer</code> specification) <br /></td></tr>
<tr class="separator:a23643edb05e992586cf2aeb4ccd5c905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d800e5886c547079a5e0d94c4dee0d7"><td class="memItemLeft" align="right" valign="top"><a id="a6d800e5886c547079a5e0d94c4dee0d7"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6d800e5886c547079a5e0d94c4dee0d7">hybridLSProb</a></td></tr>
<tr class="memdesc:a6d800e5886c547079a5e0d94c4dee0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">local search probability for embedded hybrids (from the <code>local_search_probability</code> specification) <br /></td></tr>
<tr class="separator:a6d800e5886c547079a5e0d94c4dee0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a45ea3e243599e4cc36b2adef6f071d"><td class="memItemLeft" align="right" valign="top"><a id="a2a45ea3e243599e4cc36b2adef6f071d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2a45ea3e243599e4cc36b2adef6f071d">concurrentRandomJobs</a></td></tr>
<tr class="memdesc:a2a45ea3e243599e4cc36b2adef6f071d"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of random jobs to perform in the pareto_set and multi_start meta-iterators (from the <code>random_starts</code> and <code>random_weight_sets</code> specifications) <br /></td></tr>
<tr class="separator:a2a45ea3e243599e4cc36b2adef6f071d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520950a248c17c0eeaa5c57efd04ebf2"><td class="memItemLeft" align="right" valign="top"><a id="a520950a248c17c0eeaa5c57efd04ebf2"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a520950a248c17c0eeaa5c57efd04ebf2">concurrentParameterSets</a></td></tr>
<tr class="memdesc:a520950a248c17c0eeaa5c57efd04ebf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">user-specified (i.e., nonrandom) parameter sets to evaluate in the pareto_set and multi_start meta-iterators (from the <code>starting_points</code> and <code>weight_sets</code> specifications) <br /></td></tr>
<tr class="separator:a520950a248c17c0eeaa5c57efd04ebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5315f8c8b2844fb38b15f8a8884a34d"><td class="memItemLeft" align="right" valign="top"><a id="aa5315f8c8b2844fb38b15f8a8884a34d"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa5315f8c8b2844fb38b15f8a8884a34d">softConvLimit</a></td></tr>
<tr class="memdesc:aa5315f8c8b2844fb38b15f8a8884a34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of consecutive iterations with change less than convergenceTolerance required to trigger convergence <br /></td></tr>
<tr class="separator:aa5315f8c8b2844fb38b15f8a8884a34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea85922b05a567157c3a9b6c386c599"><td class="memItemLeft" align="right" valign="top"><a id="a5ea85922b05a567157c3a9b6c386c599"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5ea85922b05a567157c3a9b6c386c599">surrBasedLocalLayerBypass</a></td></tr>
<tr class="memdesc:a5ea85922b05a567157c3a9b6c386c599"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate user-specification of a bypass of any/all layerings in evaluating truth response values in SBL. <br /></td></tr>
<tr class="separator:a5ea85922b05a567157c3a9b6c386c599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f05ac1394cc2d24dd55604f2736b7c"><td class="memItemLeft" align="right" valign="top"><a id="a80f05ac1394cc2d24dd55604f2736b7c"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a80f05ac1394cc2d24dd55604f2736b7c">trustRegionInitSize</a></td></tr>
<tr class="memdesc:a80f05ac1394cc2d24dd55604f2736b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">initial trust region sizes in the surrogate-based local method (from the <code>initial_size</code> specification in MethodSBL), one size per surrogate model (notes: no trust region for the truth model; sizes are relative values, e.g., 0.1 = 10% of range of global bounds for each variable <br /></td></tr>
<tr class="separator:a80f05ac1394cc2d24dd55604f2736b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8560ea28d531c0003ac92811719e66b7"><td class="memItemLeft" align="right" valign="top"><a id="a8560ea28d531c0003ac92811719e66b7"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8560ea28d531c0003ac92811719e66b7">trustRegionMinSize</a></td></tr>
<tr class="memdesc:a8560ea28d531c0003ac92811719e66b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum trust region size in the surrogate-based local method (from the <code>minimum_size</code> specification in MethodSBL), if the trust region size falls below this threshold the SBL iterations are terminated (note: if kriging is used with SBL, the min trust region size is set to 1.0e-3 in attempt to avoid ill-conditioned matrixes that arise in kriging over small trust regions) <br /></td></tr>
<tr class="separator:a8560ea28d531c0003ac92811719e66b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa552ecbc8f8e33fd9a50114e67fa9ae8"><td class="memItemLeft" align="right" valign="top"><a id="aa552ecbc8f8e33fd9a50114e67fa9ae8"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa552ecbc8f8e33fd9a50114e67fa9ae8">trustRegionContractTrigger</a></td></tr>
<tr class="memdesc:aa552ecbc8f8e33fd9a50114e67fa9ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">trust region minimum improvement level (ratio of actual to predicted decrease in objective fcn) in the surrogate-based local method (from the <code>contract_threshold</code> specification in MethodSBL), the trust region shrinks or is rejected if the ratio is below this value ("eta_1" in the Conn-Gould-Toint trust region book) <br /></td></tr>
<tr class="separator:aa552ecbc8f8e33fd9a50114e67fa9ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec1a15ab1e1075cac66e64108f87592"><td class="memItemLeft" align="right" valign="top"><a id="adec1a15ab1e1075cac66e64108f87592"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#adec1a15ab1e1075cac66e64108f87592">trustRegionExpandTrigger</a></td></tr>
<tr class="memdesc:adec1a15ab1e1075cac66e64108f87592"><td class="mdescLeft">&#160;</td><td class="mdescRight">trust region sufficient improvement level (ratio of actual to predicted decrease in objective fn) in the surrogate-based local method (from the <code>expand_threshold</code> specification in MethodSBL), the trust region expands if the ratio is above this value ("eta_2" in the Conn-Gould-Toint trust region book) <br /></td></tr>
<tr class="separator:adec1a15ab1e1075cac66e64108f87592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971be861025e4de6fdbf60d713968cd1"><td class="memItemLeft" align="right" valign="top"><a id="a971be861025e4de6fdbf60d713968cd1"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a971be861025e4de6fdbf60d713968cd1">trustRegionContract</a></td></tr>
<tr class="memdesc:a971be861025e4de6fdbf60d713968cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">trust region contraction factor in the surrogate-based local method (from the <code>contraction_factor</code> specification in MethodSBL) <br /></td></tr>
<tr class="separator:a971be861025e4de6fdbf60d713968cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae1ecbaa839156a9a80e4786a3f2c43"><td class="memItemLeft" align="right" valign="top"><a id="a2ae1ecbaa839156a9a80e4786a3f2c43"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2ae1ecbaa839156a9a80e4786a3f2c43">trustRegionExpand</a></td></tr>
<tr class="memdesc:a2ae1ecbaa839156a9a80e4786a3f2c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">trust region expansion factor in the surrogate-based local method (from the <code>expansion_factor</code> specification in MethodSBL) <br /></td></tr>
<tr class="separator:a2ae1ecbaa839156a9a80e4786a3f2c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cf4b734d7bf19478b174dd0dc0ac92"><td class="memItemLeft" align="right" valign="top"><a id="aa7cf4b734d7bf19478b174dd0dc0ac92"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa7cf4b734d7bf19478b174dd0dc0ac92">surrBasedLocalSubProbObj</a></td></tr>
<tr class="memdesc:aa7cf4b734d7bf19478b174dd0dc0ac92"><td class="mdescLeft">&#160;</td><td class="mdescRight">SBL approximate subproblem objective: ORIGINAL_PRIMARY, SINGLE_OBJECTIVE, LAGRANGIAN_OBJECTIVE, or AUGMENTED_LAGRANGIAN_OBJECTIVE. <br /></td></tr>
<tr class="separator:aa7cf4b734d7bf19478b174dd0dc0ac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88ededa17e66f9eda972d76030b8609"><td class="memItemLeft" align="right" valign="top"><a id="ab88ededa17e66f9eda972d76030b8609"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab88ededa17e66f9eda972d76030b8609">surrBasedLocalSubProbCon</a></td></tr>
<tr class="memdesc:ab88ededa17e66f9eda972d76030b8609"><td class="mdescLeft">&#160;</td><td class="mdescRight">SBL approximate subproblem constraints: NO_CONSTRAINTS, LINEARIZED_CONSTRAINTS, or ORIGINAL_CONSTRAINTS. <br /></td></tr>
<tr class="separator:ab88ededa17e66f9eda972d76030b8609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f963f28adf709a7f79760a755c5251"><td class="memItemLeft" align="right" valign="top"><a id="a12f963f28adf709a7f79760a755c5251"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a12f963f28adf709a7f79760a755c5251">surrBasedLocalMeritFn</a></td></tr>
<tr class="memdesc:a12f963f28adf709a7f79760a755c5251"><td class="mdescLeft">&#160;</td><td class="mdescRight">SBL merit function type: BASIC_PENALTY, ADAPTIVE_PENALTY, BASIC_LAGRANGIAN, or AUGMENTED_LAGRANGIAN. <br /></td></tr>
<tr class="separator:a12f963f28adf709a7f79760a755c5251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393cbf337a3dd93494ad99ba153a2d1e"><td class="memItemLeft" align="right" valign="top"><a id="a393cbf337a3dd93494ad99ba153a2d1e"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a393cbf337a3dd93494ad99ba153a2d1e">surrBasedLocalAcceptLogic</a></td></tr>
<tr class="memdesc:a393cbf337a3dd93494ad99ba153a2d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SBL iterate acceptance logic: TR_RATIO or FILTER. <br /></td></tr>
<tr class="separator:a393cbf337a3dd93494ad99ba153a2d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daec9047df2428f84df1174dffa8c3c"><td class="memItemLeft" align="right" valign="top"><a id="a6daec9047df2428f84df1174dffa8c3c"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6daec9047df2428f84df1174dffa8c3c">surrBasedLocalConstrRelax</a></td></tr>
<tr class="memdesc:a6daec9047df2428f84df1174dffa8c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SBL constraint relaxation method: NO_RELAX or HOMOTOPY. <br /></td></tr>
<tr class="separator:a6daec9047df2428f84df1174dffa8c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e782966ecd5fd3a090c9ecfcb8591d0"><td class="memItemLeft" align="right" valign="top"><a id="a5e782966ecd5fd3a090c9ecfcb8591d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5e782966ecd5fd3a090c9ecfcb8591d0">surrBasedGlobalReplacePts</a></td></tr>
<tr class="memdesc:a5e782966ecd5fd3a090c9ecfcb8591d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">user-specified method for adding points to the set upon which the next surrogate is based in the <code>surrogate_based_global</code> method. <br /></td></tr>
<tr class="separator:a5e782966ecd5fd3a090c9ecfcb8591d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b33fe906e18b5ac03daaef618b1b44"><td class="memItemLeft" align="right" valign="top"><a id="a27b33fe906e18b5ac03daaef618b1b44"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a27b33fe906e18b5ac03daaef618b1b44">dlDetails</a></td></tr>
<tr class="memdesc:a27b33fe906e18b5ac03daaef618b1b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">string of options for a dynamically linked solver <br /></td></tr>
<tr class="separator:a27b33fe906e18b5ac03daaef618b1b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1637086a84cd21b38c56094c56cbce7c"><td class="memItemLeft" align="right" valign="top"><a id="a1637086a84cd21b38c56094c56cbce7c"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1637086a84cd21b38c56094c56cbce7c">dlLib</a></td></tr>
<tr class="memdesc:a1637086a84cd21b38c56094c56cbce7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle to dynamically loaded library <br /></td></tr>
<tr class="separator:a1637086a84cd21b38c56094c56cbce7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcafe12cc709d47ea9fed379445bd3d"><td class="memItemLeft" align="right" valign="top"><a id="a7bcafe12cc709d47ea9fed379445bd3d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7bcafe12cc709d47ea9fed379445bd3d">verifyLevel</a></td></tr>
<tr class="memdesc:a7bcafe12cc709d47ea9fed379445bd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>verify_level</code> specification in MethodNPSOLDC <br /></td></tr>
<tr class="separator:a7bcafe12cc709d47ea9fed379445bd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f603717922ea078018f7c12a625b69"><td class="memItemLeft" align="right" valign="top"><a id="ad4f603717922ea078018f7c12a625b69"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad4f603717922ea078018f7c12a625b69">functionPrecision</a></td></tr>
<tr class="memdesc:ad4f603717922ea078018f7c12a625b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>function_precision</code> specification in MethodNPSOLDC and the <code>EPSILON</code> specification in NOMAD <br /></td></tr>
<tr class="separator:ad4f603717922ea078018f7c12a625b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a91a32b9c3c1ba338244b7b97ed3b1"><td class="memItemLeft" align="right" valign="top"><a id="a35a91a32b9c3c1ba338244b7b97ed3b1"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a35a91a32b9c3c1ba338244b7b97ed3b1">lineSearchTolerance</a></td></tr>
<tr class="memdesc:a35a91a32b9c3c1ba338244b7b97ed3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>linesearch_tolerance</code> specification in MethodNPSOLDC <br /></td></tr>
<tr class="separator:a35a91a32b9c3c1ba338244b7b97ed3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b89c19b9380406db2d29688014b224"><td class="memItemLeft" align="right" valign="top"><a id="a48b89c19b9380406db2d29688014b224"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a48b89c19b9380406db2d29688014b224">absConvTol</a></td></tr>
<tr class="memdesc:a48b89c19b9380406db2d29688014b224"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute function convergence tolerance <br /></td></tr>
<tr class="separator:a48b89c19b9380406db2d29688014b224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0192e5a57814eb7aed1e1a8a0d3d1cab"><td class="memItemLeft" align="right" valign="top"><a id="a0192e5a57814eb7aed1e1a8a0d3d1cab"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0192e5a57814eb7aed1e1a8a0d3d1cab">xConvTol</a></td></tr>
<tr class="memdesc:a0192e5a57814eb7aed1e1a8a0d3d1cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">x-convergence tolerance <br /></td></tr>
<tr class="separator:a0192e5a57814eb7aed1e1a8a0d3d1cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22d7370f53d09b7d6b93bae857f2018"><td class="memItemLeft" align="right" valign="top"><a id="aa22d7370f53d09b7d6b93bae857f2018"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa22d7370f53d09b7d6b93bae857f2018">singConvTol</a></td></tr>
<tr class="memdesc:aa22d7370f53d09b7d6b93bae857f2018"><td class="mdescLeft">&#160;</td><td class="mdescRight">singular convergence tolerance <br /></td></tr>
<tr class="separator:aa22d7370f53d09b7d6b93bae857f2018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2086253ac6a7a7d2a06d85165db8cb7"><td class="memItemLeft" align="right" valign="top"><a id="ac2086253ac6a7a7d2a06d85165db8cb7"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac2086253ac6a7a7d2a06d85165db8cb7">singRadius</a></td></tr>
<tr class="memdesc:ac2086253ac6a7a7d2a06d85165db8cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">radius for singular convergence test <br /></td></tr>
<tr class="separator:ac2086253ac6a7a7d2a06d85165db8cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbd64a1b87bbf885202da926601cfe3"><td class="memItemLeft" align="right" valign="top"><a id="aedbd64a1b87bbf885202da926601cfe3"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aedbd64a1b87bbf885202da926601cfe3">falseConvTol</a></td></tr>
<tr class="memdesc:aedbd64a1b87bbf885202da926601cfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">false-convergence tolerance <br /></td></tr>
<tr class="separator:aedbd64a1b87bbf885202da926601cfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52293c240acfe3847823fece342a19b"><td class="memItemLeft" align="right" valign="top"><a id="ad52293c240acfe3847823fece342a19b"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad52293c240acfe3847823fece342a19b">initTRRadius</a></td></tr>
<tr class="memdesc:ad52293c240acfe3847823fece342a19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">initial trust radius <br /></td></tr>
<tr class="separator:ad52293c240acfe3847823fece342a19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acbcef158b8f1e6a0e6a6866164ed28"><td class="memItemLeft" align="right" valign="top"><a id="a9acbcef158b8f1e6a0e6a6866164ed28"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9acbcef158b8f1e6a0e6a6866164ed28">covarianceType</a></td></tr>
<tr class="memdesc:a9acbcef158b8f1e6a0e6a6866164ed28"><td class="mdescLeft">&#160;</td><td class="mdescRight">kind of covariance required <br /></td></tr>
<tr class="separator:a9acbcef158b8f1e6a0e6a6866164ed28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0845b927a73f022f9921d3a54e0c0c7"><td class="memItemLeft" align="right" valign="top"><a id="ad0845b927a73f022f9921d3a54e0c0c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad0845b927a73f022f9921d3a54e0c0c7">regressDiag</a></td></tr>
<tr class="memdesc:ad0845b927a73f022f9921d3a54e0c0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to print the regression diagnostic vector <br /></td></tr>
<tr class="separator:ad0845b927a73f022f9921d3a54e0c0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4098e92d2988221bc68499b087c0a7"><td class="memItemLeft" align="right" valign="top"><a id="a5f4098e92d2988221bc68499b087c0a7"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5f4098e92d2988221bc68499b087c0a7">searchMethod</a></td></tr>
<tr class="memdesc:a5f4098e92d2988221bc68499b087c0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>search_method</code> specification for Newton and nonlinear interior-point methods in MethodOPTPPDC <br /></td></tr>
<tr class="separator:a5f4098e92d2988221bc68499b087c0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38945a935011407a1848a3c1f173c62f"><td class="memItemLeft" align="right" valign="top"><a id="a38945a935011407a1848a3c1f173c62f"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a38945a935011407a1848a3c1f173c62f">gradientTolerance</a></td></tr>
<tr class="memdesc:a38945a935011407a1848a3c1f173c62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>gradient_tolerance</code> specification in MethodOPTPPDC <br /></td></tr>
<tr class="separator:a38945a935011407a1848a3c1f173c62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdff94f5bced8f0c2c562e2178b89fe"><td class="memItemLeft" align="right" valign="top"><a id="a9bdff94f5bced8f0c2c562e2178b89fe"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9bdff94f5bced8f0c2c562e2178b89fe">maxStep</a></td></tr>
<tr class="memdesc:a9bdff94f5bced8f0c2c562e2178b89fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>max_step</code> specification in MethodOPTPPDC <br /></td></tr>
<tr class="separator:a9bdff94f5bced8f0c2c562e2178b89fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac573d7347f3f500bd5178a554b8b85d"><td class="memItemLeft" align="right" valign="top"><a id="aac573d7347f3f500bd5178a554b8b85d"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aac573d7347f3f500bd5178a554b8b85d">meritFn</a></td></tr>
<tr class="memdesc:aac573d7347f3f500bd5178a554b8b85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>merit_function</code> specification for nonlinear interior-point methods in MethodOPTPPDC <br /></td></tr>
<tr class="separator:aac573d7347f3f500bd5178a554b8b85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae336ed9b0c35c787cfcc179cec887efc"><td class="memItemLeft" align="right" valign="top"><a id="ae336ed9b0c35c787cfcc179cec887efc"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae336ed9b0c35c787cfcc179cec887efc">stepLenToBoundary</a></td></tr>
<tr class="memdesc:ae336ed9b0c35c787cfcc179cec887efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>steplength_to_boundary</code> specification for nonlinear interior-point methods in MethodOPTPPDC <br /></td></tr>
<tr class="separator:ae336ed9b0c35c787cfcc179cec887efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae741c37d6b8fa7bfc269f8850227cb5b"><td class="memItemLeft" align="right" valign="top"><a id="ae741c37d6b8fa7bfc269f8850227cb5b"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae741c37d6b8fa7bfc269f8850227cb5b">centeringParam</a></td></tr>
<tr class="memdesc:ae741c37d6b8fa7bfc269f8850227cb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>centering_parameter</code> specification for nonlinear interior-point methods in MethodOPTPPDC <br /></td></tr>
<tr class="separator:ae741c37d6b8fa7bfc269f8850227cb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f89d3f5fb6265d892e3cbb89c135da4"><td class="memItemLeft" align="right" valign="top"><a id="a7f89d3f5fb6265d892e3cbb89c135da4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7f89d3f5fb6265d892e3cbb89c135da4">searchSchemeSize</a></td></tr>
<tr class="memdesc:a7f89d3f5fb6265d892e3cbb89c135da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>search_scheme_size</code> specification for PDS methods in MethodOPTPPDC <br /></td></tr>
<tr class="separator:a7f89d3f5fb6265d892e3cbb89c135da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac10d281a12a2cae9b4dd32e9ec80d6"><td class="memItemLeft" align="right" valign="top"><a id="aaac10d281a12a2cae9b4dd32e9ec80d6"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aaac10d281a12a2cae9b4dd32e9ec80d6">initStepLength</a></td></tr>
<tr class="memdesc:aaac10d281a12a2cae9b4dd32e9ec80d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>initStepLength</code> choice for nonlinearly constrained APPS in MethodAPPSDC <br /></td></tr>
<tr class="separator:aaac10d281a12a2cae9b4dd32e9ec80d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b319bcd160f98b0ee93d094a21bd5a"><td class="memItemLeft" align="right" valign="top"><a id="ab5b319bcd160f98b0ee93d094a21bd5a"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab5b319bcd160f98b0ee93d094a21bd5a">contractStepLength</a></td></tr>
<tr class="memdesc:ab5b319bcd160f98b0ee93d094a21bd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>contractStepLength</code> choice for nonlinearly constrained APPS in MethodAPPSDC <br /></td></tr>
<tr class="separator:ab5b319bcd160f98b0ee93d094a21bd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d2e0247d1e6a7fe513b9b96b0dc531"><td class="memItemLeft" align="right" valign="top"><a id="aa6d2e0247d1e6a7fe513b9b96b0dc531"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa6d2e0247d1e6a7fe513b9b96b0dc531">threshStepLength</a></td></tr>
<tr class="memdesc:aa6d2e0247d1e6a7fe513b9b96b0dc531"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>threshStepLength</code> choice for nonlinearly constrained APPS in MethodAPPSDC <br /></td></tr>
<tr class="separator:aa6d2e0247d1e6a7fe513b9b96b0dc531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae913128aac3cc788e85430098333b1cf"><td class="memItemLeft" align="right" valign="top"><a id="ae913128aac3cc788e85430098333b1cf"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae913128aac3cc788e85430098333b1cf">meritFunction</a></td></tr>
<tr class="memdesc:ae913128aac3cc788e85430098333b1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>meritFunction</code> choice for nonlinearly constrained APPS in MethodAPPSDC <br /></td></tr>
<tr class="separator:ae913128aac3cc788e85430098333b1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81676af1c038e622d3b4bcd60697712"><td class="memItemLeft" align="right" valign="top"><a id="ad81676af1c038e622d3b4bcd60697712"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad81676af1c038e622d3b4bcd60697712">constrPenalty</a></td></tr>
<tr class="memdesc:ad81676af1c038e622d3b4bcd60697712"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>constrPenalty</code> choice for nonlinearly constrained APPS in MethodAPPSDC <br /></td></tr>
<tr class="separator:ad81676af1c038e622d3b4bcd60697712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0141b1930ba46a25dc8a2b5672367ab"><td class="memItemLeft" align="right" valign="top"><a id="ab0141b1930ba46a25dc8a2b5672367ab"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab0141b1930ba46a25dc8a2b5672367ab">smoothFactor</a></td></tr>
<tr class="memdesc:ab0141b1930ba46a25dc8a2b5672367ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">the initial <code>smoothFactor</code> value for nonlinearly constrained APPS in MethodAPPSDC <br /></td></tr>
<tr class="separator:ab0141b1930ba46a25dc8a2b5672367ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab3c8e5c7723b31188c16a241e0bec1"><td class="memItemLeft" align="right" valign="top"><a id="a5ab3c8e5c7723b31188c16a241e0bec1"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5ab3c8e5c7723b31188c16a241e0bec1">constraintPenalty</a></td></tr>
<tr class="memdesc:a5ab3c8e5c7723b31188c16a241e0bec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the initial <code>constraint_penalty</code> for COLINY methods in MethodAPPS, MethodSCOLIBDIR, MethodSCOLIBPS, MethodSCOLIBSW and MethodSCOLIBEA <br /></td></tr>
<tr class="separator:a5ab3c8e5c7723b31188c16a241e0bec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab371d40abc28582afccfa535216a7a1d"><td class="memItemLeft" align="right" valign="top"><a id="ab371d40abc28582afccfa535216a7a1d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab371d40abc28582afccfa535216a7a1d">constantPenalty</a></td></tr>
<tr class="memdesc:ab371d40abc28582afccfa535216a7a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>constant_penalty</code> flag for COLINY methods in MethodSCOLIBPS and MethodSCOLIBSW <br /></td></tr>
<tr class="separator:ab371d40abc28582afccfa535216a7a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb2d9ae5bfed2c91fa659aa66da511"><td class="memItemLeft" align="right" valign="top"><a id="a35cb2d9ae5bfed2c91fa659aa66da511"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a35cb2d9ae5bfed2c91fa659aa66da511">globalBalanceParam</a></td></tr>
<tr class="memdesc:a35cb2d9ae5bfed2c91fa659aa66da511"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>global_balance_parameter</code> for the DIRECT method in MethodSCOLIBDIR <br /></td></tr>
<tr class="separator:a35cb2d9ae5bfed2c91fa659aa66da511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d949bac04015a892a7a5512721b908"><td class="memItemLeft" align="right" valign="top"><a id="a39d949bac04015a892a7a5512721b908"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a39d949bac04015a892a7a5512721b908">localBalanceParam</a></td></tr>
<tr class="memdesc:a39d949bac04015a892a7a5512721b908"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>local_balance_parameter</code> for the DIRECT method in MethodSCOLIBDIR <br /></td></tr>
<tr class="separator:a39d949bac04015a892a7a5512721b908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde0e0343a40fa9758f3765e50f0baaa"><td class="memItemLeft" align="right" valign="top"><a id="afde0e0343a40fa9758f3765e50f0baaa"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#afde0e0343a40fa9758f3765e50f0baaa">maxBoxSize</a></td></tr>
<tr class="memdesc:afde0e0343a40fa9758f3765e50f0baaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>max_boxsize_limit</code> for the DIRECT method in MethodSCOLIBDIR <br /></td></tr>
<tr class="separator:afde0e0343a40fa9758f3765e50f0baaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c0beb84ec2626f0829efd8d4f8ab38"><td class="memItemLeft" align="right" valign="top"><a id="ab7c0beb84ec2626f0829efd8d4f8ab38"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab7c0beb84ec2626f0829efd8d4f8ab38">minBoxSize</a></td></tr>
<tr class="memdesc:ab7c0beb84ec2626f0829efd8d4f8ab38"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>min_boxsize_limit</code> for the DIRECT method in MethodSCOLIBDIR and MethodNCSUDC <br /></td></tr>
<tr class="separator:ab7c0beb84ec2626f0829efd8d4f8ab38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87601369b0598d5a38ecbd669e292434"><td class="memItemLeft" align="right" valign="top"><a id="a87601369b0598d5a38ecbd669e292434"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a87601369b0598d5a38ecbd669e292434">boxDivision</a></td></tr>
<tr class="memdesc:a87601369b0598d5a38ecbd669e292434"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>division</code> setting (<code>major_dimension</code> or <code>all_dimensions</code>) for the DIRECT method in MethodSCOLIBDIR <br /></td></tr>
<tr class="separator:a87601369b0598d5a38ecbd669e292434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42adb292927c7847b985741422a4b8b"><td class="memItemLeft" align="right" valign="top"><a id="af42adb292927c7847b985741422a4b8b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af42adb292927c7847b985741422a4b8b">mutationAdaptive</a></td></tr>
<tr class="memdesc:af42adb292927c7847b985741422a4b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>non_adaptive</code> specification for the coliny_ea method in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:af42adb292927c7847b985741422a4b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043e912e36a4b3429629662d9bce073a"><td class="memItemLeft" align="right" valign="top"><a id="a043e912e36a4b3429629662d9bce073a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a043e912e36a4b3429629662d9bce073a">showMiscOptions</a></td></tr>
<tr class="memdesc:a043e912e36a4b3429629662d9bce073a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>show_misc_options</code> specification in MethodSCOLIBDC <br /></td></tr>
<tr class="separator:a043e912e36a4b3429629662d9bce073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0002657907fb7f902e1117c6bf09aff"><td class="memItemLeft" align="right" valign="top"><a id="ac0002657907fb7f902e1117c6bf09aff"></a>
StringArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac0002657907fb7f902e1117c6bf09aff">miscOptions</a></td></tr>
<tr class="memdesc:ac0002657907fb7f902e1117c6bf09aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>misc_options</code> specification in MethodSCOLIBDC <br /></td></tr>
<tr class="separator:ac0002657907fb7f902e1117c6bf09aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9079741130e4678550d67074a4b5dd"><td class="memItemLeft" align="right" valign="top"><a id="abd9079741130e4678550d67074a4b5dd"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abd9079741130e4678550d67074a4b5dd">solnTarget</a></td></tr>
<tr class="memdesc:abd9079741130e4678550d67074a4b5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>solution_target</code> specification in MethodSCOLIBDC <br /></td></tr>
<tr class="separator:abd9079741130e4678550d67074a4b5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e6de462b721a12929ac3f0f16a4270"><td class="memItemLeft" align="right" valign="top"><a id="ac8e6de462b721a12929ac3f0f16a4270"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac8e6de462b721a12929ac3f0f16a4270">crossoverRate</a></td></tr>
<tr class="memdesc:ac8e6de462b721a12929ac3f0f16a4270"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>crossover_rate</code> specification for EA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:ac8e6de462b721a12929ac3f0f16a4270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306963417bf4e3b59377471a6ead9763"><td class="memItemLeft" align="right" valign="top"><a id="a306963417bf4e3b59377471a6ead9763"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a306963417bf4e3b59377471a6ead9763">mutationRate</a></td></tr>
<tr class="memdesc:a306963417bf4e3b59377471a6ead9763"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>mutation_rate</code> specification for EA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:a306963417bf4e3b59377471a6ead9763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7cb43066d9548cad473a2106cbae31"><td class="memItemLeft" align="right" valign="top"><a id="a4d7cb43066d9548cad473a2106cbae31"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4d7cb43066d9548cad473a2106cbae31">mutationScale</a></td></tr>
<tr class="memdesc:a4d7cb43066d9548cad473a2106cbae31"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>mutation_scale</code> specification for EA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:a4d7cb43066d9548cad473a2106cbae31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b769fcdd8845f30e2b9ce0c122fe21"><td class="memItemLeft" align="right" valign="top"><a id="af7b769fcdd8845f30e2b9ce0c122fe21"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af7b769fcdd8845f30e2b9ce0c122fe21">mutationMinScale</a></td></tr>
<tr class="memdesc:af7b769fcdd8845f30e2b9ce0c122fe21"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>min_scale</code> specification for mutation in EA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:af7b769fcdd8845f30e2b9ce0c122fe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed64e64ecf9ca08f20cc9c7a96481283"><td class="memItemLeft" align="right" valign="top"><a id="aed64e64ecf9ca08f20cc9c7a96481283"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aed64e64ecf9ca08f20cc9c7a96481283">initDelta</a></td></tr>
<tr class="memdesc:aed64e64ecf9ca08f20cc9c7a96481283"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>initial_delta</code> specification for APPS/COBYLA/PS/SW methods in MethodAPPS, MethodSCOLIBCOB, MethodSCOLIBPS, and MethodSCOLIBSW <br /></td></tr>
<tr class="separator:aed64e64ecf9ca08f20cc9c7a96481283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b58caae67330e1e487e9e1ee04772c"><td class="memItemLeft" align="right" valign="top"><a id="ac7b58caae67330e1e487e9e1ee04772c"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac7b58caae67330e1e487e9e1ee04772c">threshDelta</a></td></tr>
<tr class="memdesc:ac7b58caae67330e1e487e9e1ee04772c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>variable_tolerance</code> specification for APPS/COBYLA/PS/SW methods in MethodAPPS, MethodSCOLIBCOB, MethodSCOLIBPS, and MethodSCOLIBSW <br /></td></tr>
<tr class="separator:ac7b58caae67330e1e487e9e1ee04772c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6597cc5ba3b5c5efd8242b28d716455"><td class="memItemLeft" align="right" valign="top"><a id="af6597cc5ba3b5c5efd8242b28d716455"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af6597cc5ba3b5c5efd8242b28d716455">contractFactor</a></td></tr>
<tr class="memdesc:af6597cc5ba3b5c5efd8242b28d716455"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>contraction_factor</code> specification for APPS/PS/SW methods in MethodAPPS, MethodSCOLIBPS, and MethodSCOLIBSW <br /></td></tr>
<tr class="separator:af6597cc5ba3b5c5efd8242b28d716455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68a6877aca190b086335bbb7b69e9e4"><td class="memItemLeft" align="right" valign="top"><a id="ae68a6877aca190b086335bbb7b69e9e4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae68a6877aca190b086335bbb7b69e9e4">newSolnsGenerated</a></td></tr>
<tr class="memdesc:ae68a6877aca190b086335bbb7b69e9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>new_solutions_generated</code> specification for GA/EPSA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:ae68a6877aca190b086335bbb7b69e9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf19b1293f1bff2845bcc150de5d351"><td class="memItemLeft" align="right" valign="top"><a id="a4bf19b1293f1bff2845bcc150de5d351"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4bf19b1293f1bff2845bcc150de5d351">numberRetained</a></td></tr>
<tr class="memdesc:a4bf19b1293f1bff2845bcc150de5d351"><td class="mdescLeft">&#160;</td><td class="mdescRight">the integer assignment to random, chc, or elitist in the <code>replacement_type</code> specification for GA/EPSA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:a4bf19b1293f1bff2845bcc150de5d351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e0d037b6806832249dca90448a597b"><td class="memItemLeft" align="right" valign="top"><a id="a99e0d037b6806832249dca90448a597b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a99e0d037b6806832249dca90448a597b">expansionFlag</a></td></tr>
<tr class="memdesc:a99e0d037b6806832249dca90448a597b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>no_expansion</code> specification for APPS/PS/SW methods in MethodAPPS, MethodSCOLIBPS, and MethodSCOLIBSW <br /></td></tr>
<tr class="separator:a99e0d037b6806832249dca90448a597b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afaabe06d0ccc527ebdb81bef30f4a4"><td class="memItemLeft" align="right" valign="top"><a id="a5afaabe06d0ccc527ebdb81bef30f4a4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5afaabe06d0ccc527ebdb81bef30f4a4">expandAfterSuccess</a></td></tr>
<tr class="memdesc:a5afaabe06d0ccc527ebdb81bef30f4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>expand_after_success</code> specification for PS/SW methods in MethodSCOLIBPS and MethodSCOLIBSW <br /></td></tr>
<tr class="separator:a5afaabe06d0ccc527ebdb81bef30f4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf46fa5ac22f56273a1248339e81df23"><td class="memItemLeft" align="right" valign="top"><a id="abf46fa5ac22f56273a1248339e81df23"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abf46fa5ac22f56273a1248339e81df23">contractAfterFail</a></td></tr>
<tr class="memdesc:abf46fa5ac22f56273a1248339e81df23"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>contract_after_failure</code> specification for the SW method in MethodSCOLIBSW <br /></td></tr>
<tr class="separator:abf46fa5ac22f56273a1248339e81df23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fb8f9a108cec0eab86eba9203efaad"><td class="memItemLeft" align="right" valign="top"><a id="ad1fb8f9a108cec0eab86eba9203efaad"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad1fb8f9a108cec0eab86eba9203efaad">mutationRange</a></td></tr>
<tr class="memdesc:ad1fb8f9a108cec0eab86eba9203efaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>mutation_range</code> specification for the pga_int method in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:ad1fb8f9a108cec0eab86eba9203efaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c5eb0c22402e288f1bb9e1e8457fc1"><td class="memItemLeft" align="right" valign="top"><a id="a68c5eb0c22402e288f1bb9e1e8457fc1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a68c5eb0c22402e288f1bb9e1e8457fc1">totalPatternSize</a></td></tr>
<tr class="memdesc:a68c5eb0c22402e288f1bb9e1e8457fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>total_pattern_size</code> specification for PS methods in MethodSCOLIBPS <br /></td></tr>
<tr class="separator:a68c5eb0c22402e288f1bb9e1e8457fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cac75302407c20093c971f77c510729"><td class="memItemLeft" align="right" valign="top"><a id="a8cac75302407c20093c971f77c510729"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8cac75302407c20093c971f77c510729">randomizeOrderFlag</a></td></tr>
<tr class="memdesc:a8cac75302407c20093c971f77c510729"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>stochastic</code> specification for the PS method in MethodSCOLIBPS <br /></td></tr>
<tr class="separator:a8cac75302407c20093c971f77c510729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177f60017e1d7e53a2adc796b1947c5b"><td class="memItemLeft" align="right" valign="top"><a id="a177f60017e1d7e53a2adc796b1947c5b"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a177f60017e1d7e53a2adc796b1947c5b">selectionPressure</a></td></tr>
<tr class="memdesc:a177f60017e1d7e53a2adc796b1947c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>fitness_type</code> specification for EA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:a177f60017e1d7e53a2adc796b1947c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec10649204d54c7399b913846bbdd5a3"><td class="memItemLeft" align="right" valign="top"><a id="aec10649204d54c7399b913846bbdd5a3"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aec10649204d54c7399b913846bbdd5a3">replacementType</a></td></tr>
<tr class="memdesc:aec10649204d54c7399b913846bbdd5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>replacement_type</code> specification for EA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:aec10649204d54c7399b913846bbdd5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d7af094b1fd06c23b32bf5cf02b7e7"><td class="memItemLeft" align="right" valign="top"><a id="a89d7af094b1fd06c23b32bf5cf02b7e7"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a89d7af094b1fd06c23b32bf5cf02b7e7">crossoverType</a></td></tr>
<tr class="memdesc:a89d7af094b1fd06c23b32bf5cf02b7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>crossover_type</code> specification for EA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:a89d7af094b1fd06c23b32bf5cf02b7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1609ef13692165949a50614f84863b8b"><td class="memItemLeft" align="right" valign="top"><a id="a1609ef13692165949a50614f84863b8b"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1609ef13692165949a50614f84863b8b">mutationType</a></td></tr>
<tr class="memdesc:a1609ef13692165949a50614f84863b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>mutation_type</code> specification for EA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:a1609ef13692165949a50614f84863b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4e9a0025b92e520fbf1b888891015f"><td class="memItemLeft" align="right" valign="top"><a id="a2c4e9a0025b92e520fbf1b888891015f"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2c4e9a0025b92e520fbf1b888891015f">exploratoryMoves</a></td></tr>
<tr class="memdesc:a2c4e9a0025b92e520fbf1b888891015f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>exploratory_moves</code> specification for the PS method in MethodSCOLIBPS <br /></td></tr>
<tr class="separator:a2c4e9a0025b92e520fbf1b888891015f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab72e73af4b2cdf9244e2f79ff0ca9d9"><td class="memItemLeft" align="right" valign="top"><a id="aab72e73af4b2cdf9244e2f79ff0ca9d9"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aab72e73af4b2cdf9244e2f79ff0ca9d9">patternBasis</a></td></tr>
<tr class="memdesc:aab72e73af4b2cdf9244e2f79ff0ca9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>pattern_basis</code> specification for APPS/PS methods in MethodAPPS and MethodSCOLIBPS <br /></td></tr>
<tr class="separator:aab72e73af4b2cdf9244e2f79ff0ca9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba3ecf5f20987d77c94dc0b1512d85b"><td class="memItemLeft" align="right" valign="top"><a id="a5ba3ecf5f20987d77c94dc0b1512d85b"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5ba3ecf5f20987d77c94dc0b1512d85b">betaSolverName</a></td></tr>
<tr class="memdesc:a5ba3ecf5f20987d77c94dc0b1512d85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">beta solvers don't need documentation <br /></td></tr>
<tr class="separator:a5ba3ecf5f20987d77c94dc0b1512d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd0c584805f498c243a191b92c7ba3b"><td class="memItemLeft" align="right" valign="top"><a id="a8fd0c584805f498c243a191b92c7ba3b"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8fd0c584805f498c243a191b92c7ba3b">evalSynchronize</a></td></tr>
<tr class="memdesc:a8fd0c584805f498c243a191b92c7ba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>synchronization</code> setting for parallel pattern search methods in MethodSCOLIBPS and MethodAPPS <br /></td></tr>
<tr class="separator:a8fd0c584805f498c243a191b92c7ba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c97030f50c5fc97fa302222734dc08"><td class="memItemLeft" align="right" valign="top"><a id="ac2c97030f50c5fc97fa302222734dc08"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac2c97030f50c5fc97fa302222734dc08">numCrossPoints</a></td></tr>
<tr class="memdesc:ac2c97030f50c5fc97fa302222734dc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of crossover points or multi-point schemes. <br /></td></tr>
<tr class="separator:ac2c97030f50c5fc97fa302222734dc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b24cb101ec4d7c92d87f9a35f89b54d"><td class="memItemLeft" align="right" valign="top"><a id="a8b24cb101ec4d7c92d87f9a35f89b54d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8b24cb101ec4d7c92d87f9a35f89b54d">numParents</a></td></tr>
<tr class="memdesc:a8b24cb101ec4d7c92d87f9a35f89b54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of parents to use in a crossover operation. <br /></td></tr>
<tr class="separator:a8b24cb101ec4d7c92d87f9a35f89b54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556802a2746cd3a13b9881a5f835b72c"><td class="memItemLeft" align="right" valign="top"><a id="a556802a2746cd3a13b9881a5f835b72c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a556802a2746cd3a13b9881a5f835b72c">numOffspring</a></td></tr>
<tr class="memdesc:a556802a2746cd3a13b9881a5f835b72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of children to produce in a crossover operation. <br /></td></tr>
<tr class="separator:a556802a2746cd3a13b9881a5f835b72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a4d6b924770fd9ff8a241673ebd09c"><td class="memItemLeft" align="right" valign="top"><a id="a55a4d6b924770fd9ff8a241673ebd09c"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a55a4d6b924770fd9ff8a241673ebd09c">fitnessType</a></td></tr>
<tr class="memdesc:a55a4d6b924770fd9ff8a241673ebd09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the fitness assessment operator to use. <br /></td></tr>
<tr class="separator:a55a4d6b924770fd9ff8a241673ebd09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c623652a26ecc06d8dc9cf2e5ce541"><td class="memItemLeft" align="right" valign="top"><a id="a21c623652a26ecc06d8dc9cf2e5ce541"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a21c623652a26ecc06d8dc9cf2e5ce541">convergenceType</a></td></tr>
<tr class="memdesc:a21c623652a26ecc06d8dc9cf2e5ce541"><td class="mdescLeft">&#160;</td><td class="mdescRight">The means by which this JEGA should converge. <br /></td></tr>
<tr class="separator:a21c623652a26ecc06d8dc9cf2e5ce541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee2fd16a56148a2677e196aa7fcc8ee"><td class="memItemLeft" align="right" valign="top"><a id="adee2fd16a56148a2677e196aa7fcc8ee"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#adee2fd16a56148a2677e196aa7fcc8ee">percentChange</a></td></tr>
<tr class="memdesc:adee2fd16a56148a2677e196aa7fcc8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum percent change before convergence for a fitness tracker converger. <br /></td></tr>
<tr class="separator:adee2fd16a56148a2677e196aa7fcc8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6153f7f1851c1ae729b99f5895892ead"><td class="memItemLeft" align="right" valign="top"><a id="a6153f7f1851c1ae729b99f5895892ead"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6153f7f1851c1ae729b99f5895892ead">numGenerations</a></td></tr>
<tr class="memdesc:a6153f7f1851c1ae729b99f5895892ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of generations over which a fitness tracker converger should track. <br /></td></tr>
<tr class="separator:a6153f7f1851c1ae729b99f5895892ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae588576ef8764a25a1b35b7e3a770ee"><td class="memItemLeft" align="right" valign="top"><a id="aae588576ef8764a25a1b35b7e3a770ee"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aae588576ef8764a25a1b35b7e3a770ee">fitnessLimit</a></td></tr>
<tr class="memdesc:aae588576ef8764a25a1b35b7e3a770ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cutoff value for survival in fitness limiting selectors (e.g., below_limit selector). <br /></td></tr>
<tr class="separator:aae588576ef8764a25a1b35b7e3a770ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af815fd21659f3e606db36d17a36c1253"><td class="memItemLeft" align="right" valign="top"><a id="af815fd21659f3e606db36d17a36c1253"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af815fd21659f3e606db36d17a36c1253">shrinkagePercent</a></td></tr>
<tr class="memdesc:af815fd21659f3e606db36d17a36c1253"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum percentage of the requested number of selections that must take place on each call to the selector (0, 1). <br /></td></tr>
<tr class="separator:af815fd21659f3e606db36d17a36c1253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163a1184b4b235e3ca2f269bbae1314a"><td class="memItemLeft" align="right" valign="top"><a id="a163a1184b4b235e3ca2f269bbae1314a"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a163a1184b4b235e3ca2f269bbae1314a">nichingType</a></td></tr>
<tr class="memdesc:a163a1184b4b235e3ca2f269bbae1314a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The niching type. <br /></td></tr>
<tr class="separator:a163a1184b4b235e3ca2f269bbae1314a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb2fa4134ffd1246309a48b7c9ef6d3"><td class="memItemLeft" align="right" valign="top"><a id="abeb2fa4134ffd1246309a48b7c9ef6d3"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abeb2fa4134ffd1246309a48b7c9ef6d3">nicheVector</a></td></tr>
<tr class="memdesc:abeb2fa4134ffd1246309a48b7c9ef6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The discretization percentage along each objective. <br /></td></tr>
<tr class="separator:abeb2fa4134ffd1246309a48b7c9ef6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bebf878befdcd8face84b278ed35ab4"><td class="memItemLeft" align="right" valign="top"><a id="a0bebf878befdcd8face84b278ed35ab4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0bebf878befdcd8face84b278ed35ab4">numDesigns</a></td></tr>
<tr class="memdesc:a0bebf878befdcd8face84b278ed35ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of designs to keep when using the max_designs nicher. <br /></td></tr>
<tr class="separator:a0bebf878befdcd8face84b278ed35ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe904edb13f95ed88bfc59cf8b61d83"><td class="memItemLeft" align="right" valign="top"><a id="a4fe904edb13f95ed88bfc59cf8b61d83"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4fe904edb13f95ed88bfc59cf8b61d83">postProcessorType</a></td></tr>
<tr class="memdesc:a4fe904edb13f95ed88bfc59cf8b61d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">The post processor type. <br /></td></tr>
<tr class="separator:a4fe904edb13f95ed88bfc59cf8b61d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca1d9d9b77ce454b811d94929a3c33d"><td class="memItemLeft" align="right" valign="top"><a id="adca1d9d9b77ce454b811d94929a3c33d"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#adca1d9d9b77ce454b811d94929a3c33d">distanceVector</a></td></tr>
<tr class="memdesc:adca1d9d9b77ce454b811d94929a3c33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The discretization percentage along each objective. <br /></td></tr>
<tr class="separator:adca1d9d9b77ce454b811d94929a3c33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b795ee60ea5540218c6cd964f17cbe"><td class="memItemLeft" align="right" valign="top"><a id="a30b795ee60ea5540218c6cd964f17cbe"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a30b795ee60ea5540218c6cd964f17cbe">initializationType</a></td></tr>
<tr class="memdesc:a30b795ee60ea5540218c6cd964f17cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The means by which the JEGA should initialize the population. <br /></td></tr>
<tr class="separator:a30b795ee60ea5540218c6cd964f17cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dcb96833f8639ba37352c9831f50de"><td class="memItemLeft" align="right" valign="top"><a id="ad0dcb96833f8639ba37352c9831f50de"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad0dcb96833f8639ba37352c9831f50de">flatFile</a></td></tr>
<tr class="memdesc:ad0dcb96833f8639ba37352c9831f50de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filename to use for initialization. <br /></td></tr>
<tr class="separator:ad0dcb96833f8639ba37352c9831f50de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0edc409e32a53202db6919d4567df41"><td class="memItemLeft" align="right" valign="top"><a id="af0edc409e32a53202db6919d4567df41"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af0edc409e32a53202db6919d4567df41">logFile</a></td></tr>
<tr class="memdesc:af0edc409e32a53202db6919d4567df41"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filename to use for logging. <br /></td></tr>
<tr class="separator:af0edc409e32a53202db6919d4567df41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9fb649fcb8ba7492b3f24451bee021"><td class="memItemLeft" align="right" valign="top"><a id="a2d9fb649fcb8ba7492b3f24451bee021"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2d9fb649fcb8ba7492b3f24451bee021">populationSize</a></td></tr>
<tr class="memdesc:a2d9fb649fcb8ba7492b3f24451bee021"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>population_size</code> specification for GA methods in MethodSCOLIBEA <br /></td></tr>
<tr class="separator:a2d9fb649fcb8ba7492b3f24451bee021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0187e4360f9253167aee0a61d2286ab"><td class="memItemLeft" align="right" valign="top"><a id="ae0187e4360f9253167aee0a61d2286ab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae0187e4360f9253167aee0a61d2286ab">printPopFlag</a></td></tr>
<tr class="memdesc:ae0187e4360f9253167aee0a61d2286ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>print_each_pop</code> flag to set the printing of the population at each generation. <br /></td></tr>
<tr class="separator:ae0187e4360f9253167aee0a61d2286ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c46115bcd1b7e28bcfab387c0f008d"><td class="memItemLeft" align="right" valign="top"><a id="a72c46115bcd1b7e28bcfab387c0f008d"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a72c46115bcd1b7e28bcfab387c0f008d">volBoxSize</a></td></tr>
<tr class="memdesc:a72c46115bcd1b7e28bcfab387c0f008d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>volume_boxsize_limit</code> for the DIRECT method in MethodNCSUDC <br /></td></tr>
<tr class="separator:a72c46115bcd1b7e28bcfab387c0f008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3b5de6832a2d038412db9777352f78"><td class="memItemLeft" align="right" valign="top"><a id="a1d3b5de6832a2d038412db9777352f78"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1d3b5de6832a2d038412db9777352f78">numSymbols</a></td></tr>
<tr class="memdesc:a1d3b5de6832a2d038412db9777352f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>symbols</code> specification for DACE methods <br /></td></tr>
<tr class="separator:a1d3b5de6832a2d038412db9777352f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af847a0a9cc267a59b237eb71b4ac2fb6"><td class="memItemLeft" align="right" valign="top"><a id="af847a0a9cc267a59b237eb71b4ac2fb6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af847a0a9cc267a59b237eb71b4ac2fb6">mainEffectsFlag</a></td></tr>
<tr class="memdesc:af847a0a9cc267a59b237eb71b4ac2fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>main_effects</code> specification for sampling methods in MethodDDACE) <br /></td></tr>
<tr class="separator:af847a0a9cc267a59b237eb71b4ac2fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951ab33abe02dedc5ba8a0270c50d092"><td class="memItemLeft" align="right" valign="top"><a id="a951ab33abe02dedc5ba8a0270c50d092"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a951ab33abe02dedc5ba8a0270c50d092">latinizeFlag</a></td></tr>
<tr class="memdesc:a951ab33abe02dedc5ba8a0270c50d092"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>latinize</code> specification for FSU QMC and CVT methods in MethodFSUDACE <br /></td></tr>
<tr class="separator:a951ab33abe02dedc5ba8a0270c50d092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452efd1fe59307edafb9e629509fee96"><td class="memItemLeft" align="right" valign="top"><a id="a452efd1fe59307edafb9e629509fee96"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a452efd1fe59307edafb9e629509fee96">volQualityFlag</a></td></tr>
<tr class="memdesc:a452efd1fe59307edafb9e629509fee96"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>quality_metrics</code> specification for sampling methods (FSU QMC and CVT methods in MethodFSUDACE) <br /></td></tr>
<tr class="separator:a452efd1fe59307edafb9e629509fee96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b918a2f706a9e77654fcb43fc08463a"><td class="memItemLeft" align="right" valign="top"><a id="a1b918a2f706a9e77654fcb43fc08463a"></a>
IntVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1b918a2f706a9e77654fcb43fc08463a">sequenceStart</a></td></tr>
<tr class="memdesc:a1b918a2f706a9e77654fcb43fc08463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>sequenceStart</code> specification in MethodFSUDACE <br /></td></tr>
<tr class="separator:a1b918a2f706a9e77654fcb43fc08463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f27758d576f8f063daa04347d3a7bad"><td class="memItemLeft" align="right" valign="top"><a id="a3f27758d576f8f063daa04347d3a7bad"></a>
IntVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3f27758d576f8f063daa04347d3a7bad">sequenceLeap</a></td></tr>
<tr class="memdesc:a3f27758d576f8f063daa04347d3a7bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>sequenceLeap</code> specification in MethodFSUDACE <br /></td></tr>
<tr class="separator:a3f27758d576f8f063daa04347d3a7bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06315da64bead69a9a0535ed5cabc6be"><td class="memItemLeft" align="right" valign="top"><a id="a06315da64bead69a9a0535ed5cabc6be"></a>
IntVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a06315da64bead69a9a0535ed5cabc6be">primeBase</a></td></tr>
<tr class="memdesc:a06315da64bead69a9a0535ed5cabc6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>primeBase</code> specification in MethodFSUDACE <br /></td></tr>
<tr class="separator:a06315da64bead69a9a0535ed5cabc6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec852f8f503812b2e5101e0f2087623"><td class="memItemLeft" align="right" valign="top"><a id="a7ec852f8f503812b2e5101e0f2087623"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7ec852f8f503812b2e5101e0f2087623">numTrials</a></td></tr>
<tr class="memdesc:a7ec852f8f503812b2e5101e0f2087623"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>numTrials</code> specification in MethodFSUDACE <br /></td></tr>
<tr class="separator:a7ec852f8f503812b2e5101e0f2087623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ed3b1cf3b8f0fe6fed0004d9044449"><td class="memItemLeft" align="right" valign="top"><a id="ab1ed3b1cf3b8f0fe6fed0004d9044449"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab1ed3b1cf3b8f0fe6fed0004d9044449">trialType</a></td></tr>
<tr class="memdesc:ab1ed3b1cf3b8f0fe6fed0004d9044449"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>trial_type</code> specification in MethodFSUDACE <br /></td></tr>
<tr class="separator:ab1ed3b1cf3b8f0fe6fed0004d9044449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ab89411a148610c9749af8e95cd453"><td class="memItemLeft" align="right" valign="top"><a id="a81ab89411a148610c9749af8e95cd453"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a81ab89411a148610c9749af8e95cd453">randomSeed</a></td></tr>
<tr class="memdesc:a81ab89411a148610c9749af8e95cd453"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>seed</code> specification for COLINY, <a class="el" href="classDakota_1_1NonD.html" title="Base class for all nondetermistic iterators (the DAKOTA/UQ branch).">NonD</a>, &amp; DACE methods <br /></td></tr>
<tr class="separator:a81ab89411a148610c9749af8e95cd453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a44818413886a9c609386f4569384c"><td class="memItemLeft" align="right" valign="top"><a id="a07a44818413886a9c609386f4569384c"></a>
SizetArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a07a44818413886a9c609386f4569384c">randomSeedSeq</a></td></tr>
<tr class="memdesc:a07a44818413886a9c609386f4569384c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>seed_sequence</code> specification for multilevel UQ methods <br /></td></tr>
<tr class="separator:a07a44818413886a9c609386f4569384c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecd22e3f105b83000a81e68569937da"><td class="memItemLeft" align="right" valign="top"><a id="acecd22e3f105b83000a81e68569937da"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#acecd22e3f105b83000a81e68569937da">initMeshSize</a></td></tr>
<tr class="memdesc:acecd22e3f105b83000a81e68569937da"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>initMeshSize</code> choice for NOMAD in MethodNOMADDC <br /></td></tr>
<tr class="separator:acecd22e3f105b83000a81e68569937da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c2e7a623653bd1b339dc31d37fa3c1"><td class="memItemLeft" align="right" valign="top"><a id="a69c2e7a623653bd1b339dc31d37fa3c1"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a69c2e7a623653bd1b339dc31d37fa3c1">minMeshSize</a></td></tr>
<tr class="memdesc:a69c2e7a623653bd1b339dc31d37fa3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>minMeshSize</code> choice for NOMAD in MethodNOMADDC <br /></td></tr>
<tr class="separator:a69c2e7a623653bd1b339dc31d37fa3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4091d2dd13de8bf2cbe20fb08f737b4"><td class="memItemLeft" align="right" valign="top"><a id="aa4091d2dd13de8bf2cbe20fb08f737b4"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa4091d2dd13de8bf2cbe20fb08f737b4">historyFile</a></td></tr>
<tr class="memdesc:aa4091d2dd13de8bf2cbe20fb08f737b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>HISTORY_FILE</code> specification for NOMAD <br /></td></tr>
<tr class="separator:aa4091d2dd13de8bf2cbe20fb08f737b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e0cf68294d15342a71cb3d0b9642a7"><td class="memItemLeft" align="right" valign="top"><a id="a16e0cf68294d15342a71cb3d0b9642a7"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a16e0cf68294d15342a71cb3d0b9642a7">displayFormat</a></td></tr>
<tr class="memdesc:a16e0cf68294d15342a71cb3d0b9642a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>DISPLAY_STATS</code> specification for NOMAD <br /></td></tr>
<tr class="separator:a16e0cf68294d15342a71cb3d0b9642a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fd92eac4e15d47423a97fc00868fba"><td class="memItemLeft" align="right" valign="top"><a id="a20fd92eac4e15d47423a97fc00868fba"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a20fd92eac4e15d47423a97fc00868fba">vns</a></td></tr>
<tr class="memdesc:a20fd92eac4e15d47423a97fc00868fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>VNS</code> specification for NOMAD <br /></td></tr>
<tr class="separator:a20fd92eac4e15d47423a97fc00868fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb0e156f461dcdf62e11825a5f4e6e9"><td class="memItemLeft" align="right" valign="top"><a id="a6bb0e156f461dcdf62e11825a5f4e6e9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6bb0e156f461dcdf62e11825a5f4e6e9">neighborOrder</a></td></tr>
<tr class="memdesc:a6bb0e156f461dcdf62e11825a5f4e6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>NEIGHBOR_ORDER</code> specification for NOMAD <br /></td></tr>
<tr class="separator:a6bb0e156f461dcdf62e11825a5f4e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9ae71fd41d0fb96ac20ff35255f44c"><td class="memItemLeft" align="right" valign="top"><a id="a6c9ae71fd41d0fb96ac20ff35255f44c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6c9ae71fd41d0fb96ac20ff35255f44c">showAllEval</a></td></tr>
<tr class="memdesc:a6c9ae71fd41d0fb96ac20ff35255f44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>DISPLAY_ALL_EVAL</code> specification for NOMAD <br /></td></tr>
<tr class="separator:a6c9ae71fd41d0fb96ac20ff35255f44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbfc1a23d25f56d789639942a21cd10"><td class="memItemLeft" align="right" valign="top"><a id="a2fbfc1a23d25f56d789639942a21cd10"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2fbfc1a23d25f56d789639942a21cd10">useSurrogate</a></td></tr>
<tr class="memdesc:a2fbfc1a23d25f56d789639942a21cd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>HAS_SGTE</code> specification for NOMAD <br /></td></tr>
<tr class="separator:a2fbfc1a23d25f56d789639942a21cd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cb81ad8fd17670dd092a1a1105eb7e"><td class="memItemLeft" align="right" valign="top"><a id="a70cb81ad8fd17670dd092a1a1105eb7e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a70cb81ad8fd17670dd092a1a1105eb7e">maxCrossIterations</a></td></tr>
<tr class="memdesc:a70cb81ad8fd17670dd092a1a1105eb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of cross iterations <br /></td></tr>
<tr class="separator:a70cb81ad8fd17670dd092a1a1105eb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc158af923f11ae149201b1162ee6bf"><td class="memItemLeft" align="right" valign="top"><a id="a3cc158af923f11ae149201b1162ee6bf"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3cc158af923f11ae149201b1162ee6bf">solverTol</a></td></tr>
<tr class="memdesc:a3cc158af923f11ae149201b1162ee6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimization tolerance for FT regression <br /></td></tr>
<tr class="separator:a3cc158af923f11ae149201b1162ee6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc45d8727600d20ca4351d2674e17732"><td class="memItemLeft" align="right" valign="top"><a id="abc45d8727600d20ca4351d2674e17732"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abc45d8727600d20ca4351d2674e17732">solverRoundingTol</a></td></tr>
<tr class="memdesc:abc45d8727600d20ca4351d2674e17732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounding tolerance for FT regression. <br /></td></tr>
<tr class="separator:abc45d8727600d20ca4351d2674e17732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67471bc0a6d9ffc81c1f5c537e74566"><td class="memItemLeft" align="right" valign="top"><a id="af67471bc0a6d9ffc81c1f5c537e74566"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af67471bc0a6d9ffc81c1f5c537e74566">statsRoundingTol</a></td></tr>
<tr class="memdesc:af67471bc0a6d9ffc81c1f5c537e74566"><td class="mdescLeft">&#160;</td><td class="mdescRight">arithmetic (rounding) tolerance for FT sums and products <br /></td></tr>
<tr class="separator:af67471bc0a6d9ffc81c1f5c537e74566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99cd6686a623b27858ea6bc3768a061"><td class="memItemLeft" align="right" valign="top"><a id="ae99cd6686a623b27858ea6bc3768a061"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae99cd6686a623b27858ea6bc3768a061">startOrder</a></td></tr>
<tr class="memdesc:ae99cd6686a623b27858ea6bc3768a061"><td class="mdescLeft">&#160;</td><td class="mdescRight">starting polynomial order <br /></td></tr>
<tr class="separator:ae99cd6686a623b27858ea6bc3768a061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c7282bbe39c4b3c363e7293d96dea6"><td class="memItemLeft" align="right" valign="top"><a id="aa1c7282bbe39c4b3c363e7293d96dea6"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa1c7282bbe39c4b3c363e7293d96dea6">kickOrder</a></td></tr>
<tr class="memdesc:aa1c7282bbe39c4b3c363e7293d96dea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial order increment when adapting <br /></td></tr>
<tr class="separator:aa1c7282bbe39c4b3c363e7293d96dea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cac844b2eb92fec3a539d90ff96f4c0"><td class="memItemLeft" align="right" valign="top"><a id="a5cac844b2eb92fec3a539d90ff96f4c0"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5cac844b2eb92fec3a539d90ff96f4c0">maxOrder</a></td></tr>
<tr class="memdesc:a5cac844b2eb92fec3a539d90ff96f4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum order of basis polynomials <br /></td></tr>
<tr class="separator:a5cac844b2eb92fec3a539d90ff96f4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b8003d5be0fa5b5161e7daba20f2a3"><td class="memItemLeft" align="right" valign="top"><a id="a93b8003d5be0fa5b5161e7daba20f2a3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a93b8003d5be0fa5b5161e7daba20f2a3">adaptOrder</a></td></tr>
<tr class="memdesc:a93b8003d5be0fa5b5161e7daba20f2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether or not to adapt order by cross validation <br /></td></tr>
<tr class="separator:a93b8003d5be0fa5b5161e7daba20f2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af724c955091f8047f035ad1d286d61e8"><td class="memItemLeft" align="right" valign="top"><a id="af724c955091f8047f035ad1d286d61e8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af724c955091f8047f035ad1d286d61e8">startRank</a></td></tr>
<tr class="memdesc:af724c955091f8047f035ad1d286d61e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">starting rank <br /></td></tr>
<tr class="separator:af724c955091f8047f035ad1d286d61e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008e3cfcba257f97b7de63122782ce41"><td class="memItemLeft" align="right" valign="top"><a id="a008e3cfcba257f97b7de63122782ce41"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a008e3cfcba257f97b7de63122782ce41">kickRank</a></td></tr>
<tr class="memdesc:a008e3cfcba257f97b7de63122782ce41"><td class="mdescLeft">&#160;</td><td class="mdescRight">rank increment when adapting <br /></td></tr>
<tr class="separator:a008e3cfcba257f97b7de63122782ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d824c343ab8a7ee2601db1d82086c"><td class="memItemLeft" align="right" valign="top"><a id="a7b7d824c343ab8a7ee2601db1d82086c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7b7d824c343ab8a7ee2601db1d82086c">maxRank</a></td></tr>
<tr class="memdesc:a7b7d824c343ab8a7ee2601db1d82086c"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum rank <br /></td></tr>
<tr class="separator:a7b7d824c343ab8a7ee2601db1d82086c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43876b60a31050d716982ccac9a83e7e"><td class="memItemLeft" align="right" valign="top"><a id="a43876b60a31050d716982ccac9a83e7e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a43876b60a31050d716982ccac9a83e7e">adaptRank</a></td></tr>
<tr class="memdesc:a43876b60a31050d716982ccac9a83e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether or not to adapt rank <br /></td></tr>
<tr class="separator:a43876b60a31050d716982ccac9a83e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91401d50f13b2045042b502f9f844e29"><td class="memItemLeft" align="right" valign="top"><a id="a91401d50f13b2045042b502f9f844e29"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a91401d50f13b2045042b502f9f844e29">maxCVRankCandidates</a></td></tr>
<tr class="memdesc:a91401d50f13b2045042b502f9f844e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of cross-validation candidates for adaptRank <br /></td></tr>
<tr class="separator:a91401d50f13b2045042b502f9f844e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178291945d806f840e15d796872b1a24"><td class="memItemLeft" align="right" valign="top"><a id="a178291945d806f840e15d796872b1a24"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a178291945d806f840e15d796872b1a24">maxCVOrderCandidates</a></td></tr>
<tr class="memdesc:a178291945d806f840e15d796872b1a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of cross-validation candidates for adaptOrder <br /></td></tr>
<tr class="separator:a178291945d806f840e15d796872b1a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3911ac8806a10a24a7ef52e05ae66876"><td class="memItemLeft" align="right" valign="top"><a id="a3911ac8806a10a24a7ef52e05ae66876"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3911ac8806a10a24a7ef52e05ae66876">c3AdvanceType</a></td></tr>
<tr class="memdesc:a3911ac8806a10a24a7ef52e05ae66876"><td class="mdescLeft">&#160;</td><td class="mdescRight">quantity to increment (start rank, start order, max rank, max order, max rank + max order) for FT (uniform) p-refinement <br /></td></tr>
<tr class="separator:a3911ac8806a10a24a7ef52e05ae66876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ef92fd5a8fa16746d5a31b06c42d34"><td class="memItemLeft" align="right" valign="top"><a id="ac9ef92fd5a8fa16746d5a31b06c42d34"></a>
UShortArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac9ef92fd5a8fa16746d5a31b06c42d34">startOrderSeq</a></td></tr>
<tr class="memdesc:ac9ef92fd5a8fa16746d5a31b06c42d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">starting polynomial order <br /></td></tr>
<tr class="separator:ac9ef92fd5a8fa16746d5a31b06c42d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e0231050fe9ed415132d7467962b76"><td class="memItemLeft" align="right" valign="top"><a id="a00e0231050fe9ed415132d7467962b76"></a>
SizetArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a00e0231050fe9ed415132d7467962b76">startRankSeq</a></td></tr>
<tr class="memdesc:a00e0231050fe9ed415132d7467962b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">starting rank <br /></td></tr>
<tr class="separator:a00e0231050fe9ed415132d7467962b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f4bd05a5e400f6cf132f57c76208ce"><td class="memItemLeft" align="right" valign="top"><a id="a34f4bd05a5e400f6cf132f57c76208ce"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a34f4bd05a5e400f6cf132f57c76208ce">numSamples</a></td></tr>
<tr class="memdesc:a34f4bd05a5e400f6cf132f57c76208ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>samples</code> specification for <a class="el" href="classDakota_1_1NonD.html" title="Base class for all nondetermistic iterators (the DAKOTA/UQ branch).">NonD</a> &amp; DACE methods <br /></td></tr>
<tr class="separator:a34f4bd05a5e400f6cf132f57c76208ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af568e154b20556442588bc62dd29b8d5"><td class="memItemLeft" align="right" valign="top"><a id="af568e154b20556442588bc62dd29b8d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af568e154b20556442588bc62dd29b8d5">fixedSeedFlag</a></td></tr>
<tr class="memdesc:af568e154b20556442588bc62dd29b8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for fixing the value of the seed among different NonD/DACE sample sets. This results in the use of the same sampling stencil/pattern throughout an execution with repeated sampling. <br /></td></tr>
<tr class="separator:af568e154b20556442588bc62dd29b8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bba8c88b6a5a80847c56880468a0da4"><td class="memItemLeft" align="right" valign="top"><a id="a9bba8c88b6a5a80847c56880468a0da4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9bba8c88b6a5a80847c56880468a0da4">fixedSequenceFlag</a></td></tr>
<tr class="memdesc:a9bba8c88b6a5a80847c56880468a0da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for fixing the sequence for Halton or Hammersley QMC sample sets. This results in the use of the same sampling stencil/pattern throughout an execution with repeated sampling. <br /></td></tr>
<tr class="separator:a9bba8c88b6a5a80847c56880468a0da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7245a7ac6fed7086737a74de2d14e351"><td class="memItemLeft" align="right" valign="top"><a id="a7245a7ac6fed7086737a74de2d14e351"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7245a7ac6fed7086737a74de2d14e351">vbdFlag</a></td></tr>
<tr class="memdesc:a7245a7ac6fed7086737a74de2d14e351"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>var_based_decomp</code> specification for computing Sobol' indices via either PCE or sampling <br /></td></tr>
<tr class="separator:a7245a7ac6fed7086737a74de2d14e351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280b2c9aecdf24db39761e3113d9c3a5"><td class="memItemLeft" align="right" valign="top"><a id="a280b2c9aecdf24db39761e3113d9c3a5"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a280b2c9aecdf24db39761e3113d9c3a5">vbdDropTolerance</a></td></tr>
<tr class="memdesc:a280b2c9aecdf24db39761e3113d9c3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>var_based_decomp</code> tolerance for omitting Sobol' indices computed via either PCE or sampling <br /></td></tr>
<tr class="separator:a280b2c9aecdf24db39761e3113d9c3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39ef846b76478cddcfb3bfc809324a8"><td class="memItemLeft" align="right" valign="top"><a id="ac39ef846b76478cddcfb3bfc809324a8"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac39ef846b76478cddcfb3bfc809324a8">vbdViaSamplingMethod</a></td></tr>
<tr class="memdesc:ac39ef846b76478cddcfb3bfc809324a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling method for computing Sobol indices: Mahadevan (default) or Saltelli. <br /></td></tr>
<tr class="separator:ac39ef846b76478cddcfb3bfc809324a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6a23e93fc2f4764b5fb9522b59f176"><td class="memItemLeft" align="right" valign="top"><a id="a1a6a23e93fc2f4764b5fb9522b59f176"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1a6a23e93fc2f4764b5fb9522b59f176">vbdViaSamplingNumBins</a></td></tr>
<tr class="memdesc:a1a6a23e93fc2f4764b5fb9522b59f176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bins to use in case the Mahadevan method is selected (default is the square root of the number of samples) <br /></td></tr>
<tr class="separator:a1a6a23e93fc2f4764b5fb9522b59f176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b377af936160be1886065d0722aef85"><td class="memItemLeft" align="right" valign="top"><a id="a2b377af936160be1886065d0722aef85"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2b377af936160be1886065d0722aef85">backfillFlag</a></td></tr>
<tr class="memdesc:a2b377af936160be1886065d0722aef85"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>backfill</code> option allows one to augment in LHS sample by enforcing the addition of unique discrete variables to the sample <br /></td></tr>
<tr class="separator:a2b377af936160be1886065d0722aef85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac055413767a5be24e8a0843e1c2d8138"><td class="memItemLeft" align="right" valign="top"><a id="ac055413767a5be24e8a0843e1c2d8138"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac055413767a5be24e8a0843e1c2d8138">pcaFlag</a></td></tr>
<tr class="memdesc:ac055413767a5be24e8a0843e1c2d8138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to specify the calculation of principal components when using LHS. <br /></td></tr>
<tr class="separator:ac055413767a5be24e8a0843e1c2d8138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c78a07f6c1869623c602176902ae124"><td class="memItemLeft" align="right" valign="top"><a id="a7c78a07f6c1869623c602176902ae124"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7c78a07f6c1869623c602176902ae124">percentVarianceExplained</a></td></tr>
<tr class="memdesc:a7c78a07f6c1869623c602176902ae124"><td class="mdescLeft">&#160;</td><td class="mdescRight">The percentage of variance explained by using a truncated number of principal components in PCA. <br /></td></tr>
<tr class="separator:a7c78a07f6c1869623c602176902ae124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9b8077e04db895c2b908b34f80ce68"><td class="memItemLeft" align="right" valign="top"><a id="aed9b8077e04db895c2b908b34f80ce68"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aed9b8077e04db895c2b908b34f80ce68">wilksFlag</a></td></tr>
<tr class="memdesc:aed9b8077e04db895c2b908b34f80ce68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to specify use of Wilks formula to calculate num samples. <br /></td></tr>
<tr class="separator:aed9b8077e04db895c2b908b34f80ce68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2008a5d58ab093e949deadf94d7f6b61"><td class="memItemLeft" align="right" valign="top"><a id="a2008a5d58ab093e949deadf94d7f6b61"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2008a5d58ab093e949deadf94d7f6b61">wilksOrder</a></td></tr>
<tr class="memdesc:a2008a5d58ab093e949deadf94d7f6b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wilks order parameter. <br /></td></tr>
<tr class="separator:a2008a5d58ab093e949deadf94d7f6b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77256f1dce0351b05c88e35a20773ad"><td class="memItemLeft" align="right" valign="top"><a id="ab77256f1dce0351b05c88e35a20773ad"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab77256f1dce0351b05c88e35a20773ad">wilksConfidenceLevel</a></td></tr>
<tr class="memdesc:ab77256f1dce0351b05c88e35a20773ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wilks confidence interval parameter. <br /></td></tr>
<tr class="separator:ab77256f1dce0351b05c88e35a20773ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd6b144bd21b7fec2e115dc1d0f91eb"><td class="memItemLeft" align="right" valign="top"><a id="a1bd6b144bd21b7fec2e115dc1d0f91eb"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1bd6b144bd21b7fec2e115dc1d0f91eb">wilksSidedInterval</a></td></tr>
<tr class="memdesc:a1bd6b144bd21b7fec2e115dc1d0f91eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wilks sided interval type. <br /></td></tr>
<tr class="separator:a1bd6b144bd21b7fec2e115dc1d0f91eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2c9057d687ee1f866418c45f260a3d"><td class="memItemLeft" align="right" valign="top"><a id="aae2c9057d687ee1f866418c45f260a3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aae2c9057d687ee1f866418c45f260a3d">rank1LatticeFlag</a></td></tr>
<tr class="memdesc:aae2c9057d687ee1f866418c45f260a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate rank-1 lattice sampling. <br /></td></tr>
<tr class="separator:aae2c9057d687ee1f866418c45f260a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77468589a27923cac30b9473af75552c"><td class="memItemLeft" align="right" valign="top"><a id="a77468589a27923cac30b9473af75552c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a77468589a27923cac30b9473af75552c">noRandomShiftFlag</a></td></tr>
<tr class="memdesc:a77468589a27923cac30b9473af75552c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate randomization of rank-1 lattice rule. <br /></td></tr>
<tr class="separator:a77468589a27923cac30b9473af75552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4a1f8998003e91df63a24fb35020b4"><td class="memItemLeft" align="right" valign="top"><a id="adb4a1f8998003e91df63a24fb35020b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#adb4a1f8998003e91df63a24fb35020b4">log2MaxPoints</a></td></tr>
<tr class="memdesc:adb4a1f8998003e91df63a24fb35020b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(log2 of) maximum number of points of low-discrepancy generator <br /></td></tr>
<tr class="separator:adb4a1f8998003e91df63a24fb35020b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd75fbec43f1030266c1a545638e410"><td class="memItemLeft" align="right" valign="top"><a id="a7fd75fbec43f1030266c1a545638e410"></a>
IntVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7fd75fbec43f1030266c1a545638e410">generatingVector</a></td></tr>
<tr class="memdesc:a7fd75fbec43f1030266c1a545638e410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline generating vector of the rank-1 lattice rule. <br /></td></tr>
<tr class="separator:a7fd75fbec43f1030266c1a545638e410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae6316f21027b537703d49f444060df"><td class="memItemLeft" align="right" valign="top"><a id="aaae6316f21027b537703d49f444060df"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aaae6316f21027b537703d49f444060df">generatingVectorFileName</a></td></tr>
<tr class="memdesc:aaae6316f21027b537703d49f444060df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of file with generating vector. <br /></td></tr>
<tr class="separator:aaae6316f21027b537703d49f444060df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c385290e9b93b0f2ec609330902c64"><td class="memItemLeft" align="right" valign="top"><a id="a74c385290e9b93b0f2ec609330902c64"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a74c385290e9b93b0f2ec609330902c64">kuo</a></td></tr>
<tr class="memdesc:a74c385290e9b93b0f2ec609330902c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined generating vectors. <br /></td></tr>
<tr class="separator:a74c385290e9b93b0f2ec609330902c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e922acfdd02cc172d2f877e0323fe87"><td class="memItemLeft" align="right" valign="top"><a id="a4e922acfdd02cc172d2f877e0323fe87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cools_kuo_nuyens</b></td></tr>
<tr class="separator:a4e922acfdd02cc172d2f877e0323fe87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4b14aed1bb8fdb0b943600a353b0d5"><td class="memItemLeft" align="right" valign="top"><a id="a8f4b14aed1bb8fdb0b943600a353b0d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8f4b14aed1bb8fdb0b943600a353b0d5">naturalOrdering</a></td></tr>
<tr class="memdesc:a8f4b14aed1bb8fdb0b943600a353b0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordering of the lattice points. <br /></td></tr>
<tr class="separator:a8f4b14aed1bb8fdb0b943600a353b0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc09ea1a94708c741f4f55f019d2843d"><td class="memItemLeft" align="right" valign="top"><a id="afc09ea1a94708c741f4f55f019d2843d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>radicalInverseOrdering</b></td></tr>
<tr class="separator:afc09ea1a94708c741f4f55f019d2843d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02d5864e720df477d94fc3d2876f8db"><td class="memItemLeft" align="right" valign="top"><a id="af02d5864e720df477d94fc3d2876f8db"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af02d5864e720df477d94fc3d2876f8db">digitalNetFlag</a></td></tr>
<tr class="memdesc:af02d5864e720df477d94fc3d2876f8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate digital net sampling. <br /></td></tr>
<tr class="separator:af02d5864e720df477d94fc3d2876f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af555a8900f7313a4f6a223d5954176de"><td class="memItemLeft" align="right" valign="top"><a id="af555a8900f7313a4f6a223d5954176de"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af555a8900f7313a4f6a223d5954176de">noDigitalShiftFlag</a></td></tr>
<tr class="memdesc:af555a8900f7313a4f6a223d5954176de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate randomization of digital net. <br /></td></tr>
<tr class="separator:af555a8900f7313a4f6a223d5954176de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9782abbf06e477268aa550e3b74d3d"><td class="memItemLeft" align="right" valign="top"><a id="a3e9782abbf06e477268aa550e3b74d3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3e9782abbf06e477268aa550e3b74d3d">noScramblingFlag</a></td></tr>
<tr class="memdesc:a3e9782abbf06e477268aa550e3b74d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate scrambling of the digital net. <br /></td></tr>
<tr class="separator:a3e9782abbf06e477268aa550e3b74d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225950a4ce7bfe64b81329b8ac2f5314"><td class="memItemLeft" align="right" valign="top"><a id="a225950a4ce7bfe64b81329b8ac2f5314"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a225950a4ce7bfe64b81329b8ac2f5314">mostSignificantBitFirst</a></td></tr>
<tr class="memdesc:a225950a4ce7bfe64b81329b8ac2f5314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate integers in generating matrices are stored with most significant bit first. <br /></td></tr>
<tr class="separator:a225950a4ce7bfe64b81329b8ac2f5314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad013020fc63a856871742fc47d90b3a7"><td class="memItemLeft" align="right" valign="top"><a id="ad013020fc63a856871742fc47d90b3a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad013020fc63a856871742fc47d90b3a7">leastSignificantBitFirst</a></td></tr>
<tr class="memdesc:ad013020fc63a856871742fc47d90b3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate integers in generating matrices are stored with least significant bit first. <br /></td></tr>
<tr class="separator:ad013020fc63a856871742fc47d90b3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcab0bdec9f463f04926d0464c369ca9"><td class="memItemLeft" align="right" valign="top"><a id="afcab0bdec9f463f04926d0464c369ca9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#afcab0bdec9f463f04926d0464c369ca9">numberOfBits</a></td></tr>
<tr class="memdesc:afcab0bdec9f463f04926d0464c369ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in each integer in the generating matrices. <br /></td></tr>
<tr class="separator:afcab0bdec9f463f04926d0464c369ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fa01ea328916a05c502283b30f24ee"><td class="memItemLeft" align="right" valign="top"><a id="aa7fa01ea328916a05c502283b30f24ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa7fa01ea328916a05c502283b30f24ee">scrambleSize</a></td></tr>
<tr class="memdesc:aa7fa01ea328916a05c502283b30f24ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows in the linear scramble matrix. <br /></td></tr>
<tr class="separator:aa7fa01ea328916a05c502283b30f24ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d536c1224a08719512e4e92d24657cc"><td class="memItemLeft" align="right" valign="top"><a id="a5d536c1224a08719512e4e92d24657cc"></a>
IntVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5d536c1224a08719512e4e92d24657cc">generatingMatrices</a></td></tr>
<tr class="memdesc:a5d536c1224a08719512e4e92d24657cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline generating matrices of the digital net. <br /></td></tr>
<tr class="separator:a5d536c1224a08719512e4e92d24657cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e8522d281531dea37d3e4811bea03b"><td class="memItemLeft" align="right" valign="top"><a id="a34e8522d281531dea37d3e4811bea03b"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a34e8522d281531dea37d3e4811bea03b">generatingMatricesFileName</a></td></tr>
<tr class="memdesc:a34e8522d281531dea37d3e4811bea03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of file with generating matrices. <br /></td></tr>
<tr class="separator:a34e8522d281531dea37d3e4811bea03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b25b8651141e87ad32e6d3c9f7deca8"><td class="memItemLeft" align="right" valign="top"><a id="a8b25b8651141e87ad32e6d3c9f7deca8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8b25b8651141e87ad32e6d3c9f7deca8">joe_kuo</a></td></tr>
<tr class="memdesc:a8b25b8651141e87ad32e6d3c9f7deca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined generating matrices. <br /></td></tr>
<tr class="separator:a8b25b8651141e87ad32e6d3c9f7deca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f0962bce6a90e46aebfad0354d0206"><td class="memItemLeft" align="right" valign="top"><a id="af7f0962bce6a90e46aebfad0354d0206"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sobol_order_2</b></td></tr>
<tr class="separator:af7f0962bce6a90e46aebfad0354d0206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f1495f60cf0432b842e9b78b0baf9d"><td class="memItemLeft" align="right" valign="top"><a id="a52f1495f60cf0432b842e9b78b0baf9d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a52f1495f60cf0432b842e9b78b0baf9d">grayCodeOrdering</a></td></tr>
<tr class="memdesc:a52f1495f60cf0432b842e9b78b0baf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordering of the digital net points. <br /></td></tr>
<tr class="separator:a52f1495f60cf0432b842e9b78b0baf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9953f276b0ce432305257e95c9090068"><td class="memItemLeft" align="right" valign="top"><a id="a9953f276b0ce432305257e95c9090068"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9953f276b0ce432305257e95c9090068">stdRegressionCoeffs</a></td></tr>
<tr class="memdesc:a9953f276b0ce432305257e95c9090068"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating the calculation/output of standardized regression coefficients <br /></td></tr>
<tr class="separator:a9953f276b0ce432305257e95c9090068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7392d62b8dae9a5fa1ce4276f1336c"><td class="memItemLeft" align="right" valign="top"><a id="a4c7392d62b8dae9a5fa1ce4276f1336c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4c7392d62b8dae9a5fa1ce4276f1336c">toleranceIntervalsFlag</a></td></tr>
<tr class="memdesc:a4c7392d62b8dae9a5fa1ce4276f1336c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to specify use of double sided tolerance interval equivalent normal. <br /></td></tr>
<tr class="separator:a4c7392d62b8dae9a5fa1ce4276f1336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219f39ff6693c5af4443e2cbfb567a2b"><td class="memItemLeft" align="right" valign="top"><a id="a219f39ff6693c5af4443e2cbfb567a2b"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a219f39ff6693c5af4443e2cbfb567a2b">tiCoverage</a></td></tr>
<tr class="memdesc:a219f39ff6693c5af4443e2cbfb567a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coverage parameter for the calculation of double sided tolerance interval equivalent normal. <br /></td></tr>
<tr class="separator:a219f39ff6693c5af4443e2cbfb567a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868460a65317202122ca5edeb6f9a164"><td class="memItemLeft" align="right" valign="top"><a id="a868460a65317202122ca5edeb6f9a164"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a868460a65317202122ca5edeb6f9a164">tiConfidenceLevel</a></td></tr>
<tr class="memdesc:a868460a65317202122ca5edeb6f9a164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Confidence level parameter for the calculation of double sided tolerance interval equivalent normal. <br /></td></tr>
<tr class="separator:a868460a65317202122ca5edeb6f9a164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1909ea0663ef3b1d276c44251f38097c"><td class="memItemLeft" align="right" valign="top"><a id="a1909ea0663ef3b1d276c44251f38097c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1909ea0663ef3b1d276c44251f38097c">respScalingFlag</a></td></tr>
<tr class="memdesc:a1909ea0663ef3b1d276c44251f38097c"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate bounds-based scaling of current response data set prior to build in surrogate-based methods; important for ML/MF data fits of decaying discrepancy data using regression with absolute tolerances <br /></td></tr>
<tr class="separator:a1909ea0663ef3b1d276c44251f38097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fafde959d17199a1480a0c6c79e1a3"><td class="memItemLeft" align="right" valign="top"><a id="a09fafde959d17199a1480a0c6c79e1a3"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a09fafde959d17199a1480a0c6c79e1a3">vbdOrder</a></td></tr>
<tr class="memdesc:a09fafde959d17199a1480a0c6c79e1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">a sub-specification of vbdFlag: interaction order limit for calculation/output of component VBD indices <br /></td></tr>
<tr class="separator:a09fafde959d17199a1480a0c6c79e1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7165996c7e778196aacfde907f8ed86"><td class="memItemLeft" align="right" valign="top"><a id="aa7165996c7e778196aacfde907f8ed86"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa7165996c7e778196aacfde907f8ed86">covarianceControl</a></td></tr>
<tr class="memdesc:aa7165996c7e778196aacfde907f8ed86"><td class="mdescLeft">&#160;</td><td class="mdescRight">restrict the calculation of a full response covariance matrix for high dimensional outputs: {DEFAULT,DIAGONAL,FULL}_COVARIANCE <br /></td></tr>
<tr class="separator:aa7165996c7e778196aacfde907f8ed86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fa8de0dae42a07bc24b1bc2c99f36e"><td class="memItemLeft" align="right" valign="top"><a id="a96fa8de0dae42a07bc24b1bc2c99f36e"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a96fa8de0dae42a07bc24b1bc2c99f36e">rngName</a></td></tr>
<tr class="memdesc:a96fa8de0dae42a07bc24b1bc2c99f36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>basic</code> random-number generator for <a class="el" href="classDakota_1_1NonD.html" title="Base class for all nondetermistic iterators (the DAKOTA/UQ branch).">NonD</a> <br /></td></tr>
<tr class="separator:a96fa8de0dae42a07bc24b1bc2c99f36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f435f7e91b4bf59279df192b539ba91"><td class="memItemLeft" align="right" valign="top"><a id="a9f435f7e91b4bf59279df192b539ba91"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9f435f7e91b4bf59279df192b539ba91">refinementType</a></td></tr>
<tr class="memdesc:a9f435f7e91b4bf59279df192b539ba91"><td class="mdescLeft">&#160;</td><td class="mdescRight">refinement type for stochastic expansions: p-refinement, h-refinement <br /></td></tr>
<tr class="separator:a9f435f7e91b4bf59279df192b539ba91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4033241e94b02aa92e729aa158ce5f4b"><td class="memItemLeft" align="right" valign="top"><a id="a4033241e94b02aa92e729aa158ce5f4b"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4033241e94b02aa92e729aa158ce5f4b">refinementMetric</a></td></tr>
<tr class="memdesc:a4033241e94b02aa92e729aa158ce5f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">refinement metric for stochastic expansions: covariance or level mappings <br /></td></tr>
<tr class="separator:a4033241e94b02aa92e729aa158ce5f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220ded02774967c0e361d4f6707c47a1"><td class="memItemLeft" align="right" valign="top"><a id="a220ded02774967c0e361d4f6707c47a1"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a220ded02774967c0e361d4f6707c47a1">refinementControl</a></td></tr>
<tr class="memdesc:a220ded02774967c0e361d4f6707c47a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">refinement control for stochastic expansions: uniform, dimension-adaptive <br /></td></tr>
<tr class="separator:a220ded02774967c0e361d4f6707c47a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a5cd6e1303fb5fcb6d3b9b6503ae69"><td class="memItemLeft" align="right" valign="top"><a id="ae4a5cd6e1303fb5fcb6d3b9b6503ae69"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae4a5cd6e1303fb5fcb6d3b9b6503ae69">nestingOverride</a></td></tr>
<tr class="memdesc:ae4a5cd6e1303fb5fcb6d3b9b6503ae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">override for default point nesting policy: NO_NESTING_OVERRIDE, NESTED, or NON_NESTED <br /></td></tr>
<tr class="separator:ae4a5cd6e1303fb5fcb6d3b9b6503ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bc3d1f6d5d45d9a05d53f217f69451"><td class="memItemLeft" align="right" valign="top"><a id="a29bc3d1f6d5d45d9a05d53f217f69451"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a29bc3d1f6d5d45d9a05d53f217f69451">growthOverride</a></td></tr>
<tr class="memdesc:a29bc3d1f6d5d45d9a05d53f217f69451"><td class="mdescLeft">&#160;</td><td class="mdescRight">override for default point growth restriction policy: NO_GROWTH_OVERRIDE, RESTRICTED, or UNRESTRICTED <br /></td></tr>
<tr class="separator:a29bc3d1f6d5d45d9a05d53f217f69451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc8444fddf98a30be0ca5dc194b9060"><td class="memItemLeft" align="right" valign="top"><a id="a1bc8444fddf98a30be0ca5dc194b9060"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1bc8444fddf98a30be0ca5dc194b9060">expansionType</a></td></tr>
<tr class="memdesc:a1bc8444fddf98a30be0ca5dc194b9060"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration for u-space type that defines u-space variable targets for probability space transformations: EXTENDED_U (default), ASKEY_U, PARTIAL_ASKEY_U, STD_NORMAL_U, or STD_UNIFORM_U <br /></td></tr>
<tr class="separator:a1bc8444fddf98a30be0ca5dc194b9060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97d2f89ff8fe545aa9023279f71b5bc"><td class="memItemLeft" align="right" valign="top"><a id="ae97d2f89ff8fe545aa9023279f71b5bc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae97d2f89ff8fe545aa9023279f71b5bc">piecewiseBasis</a></td></tr>
<tr class="memdesc:ae97d2f89ff8fe545aa9023279f71b5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">boolean indicating presence of <code>piecewise</code> keyword <br /></td></tr>
<tr class="separator:ae97d2f89ff8fe545aa9023279f71b5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ebe4c324d2b70370969eabba13485e"><td class="memItemLeft" align="right" valign="top"><a id="ae9ebe4c324d2b70370969eabba13485e"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae9ebe4c324d2b70370969eabba13485e">expansionBasisType</a></td></tr>
<tr class="memdesc:ae9ebe4c324d2b70370969eabba13485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration for type of basis in sparse grid interpolation (Pecos::{NODAL,HIERARCHICAL}_INTERPOLANT) or regression (Pecos::{TENSOR_PRODUCT,TOTAL_ORDER,ADAPTED}_BASIS). <br /></td></tr>
<tr class="separator:ae9ebe4c324d2b70370969eabba13485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c103895257d4ecf1cf6b758184620d"><td class="memItemLeft" align="right" valign="top"><a id="a54c103895257d4ecf1cf6b758184620d"></a>
UShortArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a54c103895257d4ecf1cf6b758184620d">quadratureOrderSeq</a></td></tr>
<tr class="memdesc:a54c103895257d4ecf1cf6b758184620d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>quadrature_order_sequence</code> specification in MethodNonDPCE and MethodNonDSC <br /></td></tr>
<tr class="separator:a54c103895257d4ecf1cf6b758184620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985351915c00bec0340235303432936f"><td class="memItemLeft" align="right" valign="top"><a id="a985351915c00bec0340235303432936f"></a>
UShortArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a985351915c00bec0340235303432936f">sparseGridLevelSeq</a></td></tr>
<tr class="memdesc:a985351915c00bec0340235303432936f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>sparse_grid_level_sequence</code> specification in MethodNonDPCE and MethodNonDSC <br /></td></tr>
<tr class="separator:a985351915c00bec0340235303432936f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2b152107aa1a853a3a7f3f7cd664f9"><td class="memItemLeft" align="right" valign="top"><a id="aad2b152107aa1a853a3a7f3f7cd664f9"></a>
UShortArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aad2b152107aa1a853a3a7f3f7cd664f9">expansionOrderSeq</a></td></tr>
<tr class="memdesc:aad2b152107aa1a853a3a7f3f7cd664f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>expansion_order_sequence</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:aad2b152107aa1a853a3a7f3f7cd664f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77bef0aa2a512ae89e452a6e74c19ae"><td class="memItemLeft" align="right" valign="top"><a id="aa77bef0aa2a512ae89e452a6e74c19ae"></a>
SizetArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa77bef0aa2a512ae89e452a6e74c19ae">collocationPointsSeq</a></td></tr>
<tr class="memdesc:aa77bef0aa2a512ae89e452a6e74c19ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>collocation_points_sequence</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:aa77bef0aa2a512ae89e452a6e74c19ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe848d877dc34b5267d38f6407fc7e"><td class="memItemLeft" align="right" valign="top"><a id="a6cfe848d877dc34b5267d38f6407fc7e"></a>
SizetArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6cfe848d877dc34b5267d38f6407fc7e">expansionSamplesSeq</a></td></tr>
<tr class="memdesc:a6cfe848d877dc34b5267d38f6407fc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>expansion_samples_sequence</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:a6cfe848d877dc34b5267d38f6407fc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94e53542fcb814b8fa40118bdd66914"><td class="memItemLeft" align="right" valign="top"><a id="aa94e53542fcb814b8fa40118bdd66914"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa94e53542fcb814b8fa40118bdd66914">quadratureOrder</a></td></tr>
<tr class="memdesc:aa94e53542fcb814b8fa40118bdd66914"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>quadrature_order</code> specification in MethodNonDPCE and MethodNonDSC <br /></td></tr>
<tr class="separator:aa94e53542fcb814b8fa40118bdd66914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701f968c69d80972a40c20eea6ca5696"><td class="memItemLeft" align="right" valign="top"><a id="a701f968c69d80972a40c20eea6ca5696"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a701f968c69d80972a40c20eea6ca5696">sparseGridLevel</a></td></tr>
<tr class="memdesc:a701f968c69d80972a40c20eea6ca5696"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>sparse_grid_level</code> specification in MethodNonDPCE and MethodNonDSC <br /></td></tr>
<tr class="separator:a701f968c69d80972a40c20eea6ca5696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e85d496ac6a03333b22f3c25909e9ec"><td class="memItemLeft" align="right" valign="top"><a id="a8e85d496ac6a03333b22f3c25909e9ec"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8e85d496ac6a03333b22f3c25909e9ec">expansionOrder</a></td></tr>
<tr class="memdesc:a8e85d496ac6a03333b22f3c25909e9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>expansion_order</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:a8e85d496ac6a03333b22f3c25909e9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bee6d672ce3b1a8ae906d256c8d16d7"><td class="memItemLeft" align="right" valign="top"><a id="a6bee6d672ce3b1a8ae906d256c8d16d7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6bee6d672ce3b1a8ae906d256c8d16d7">collocationPoints</a></td></tr>
<tr class="memdesc:a6bee6d672ce3b1a8ae906d256c8d16d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>collocation_points</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:a6bee6d672ce3b1a8ae906d256c8d16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cfb195bd82189a1311447078efe370"><td class="memItemLeft" align="right" valign="top"><a id="a93cfb195bd82189a1311447078efe370"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a93cfb195bd82189a1311447078efe370">expansionSamples</a></td></tr>
<tr class="memdesc:a93cfb195bd82189a1311447078efe370"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>expansion_samples</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:a93cfb195bd82189a1311447078efe370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c712644955bd5ce5091ca2683760f3"><td class="memItemLeft" align="right" valign="top"><a id="a73c712644955bd5ce5091ca2683760f3"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a73c712644955bd5ce5091ca2683760f3">anisoDimPref</a></td></tr>
<tr class="memdesc:a73c712644955bd5ce5091ca2683760f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>dimension_preference</code> specification for tensor and sparse grids and expansion orders in MethodNonDPCE and MethodNonDSC <br /></td></tr>
<tr class="separator:a73c712644955bd5ce5091ca2683760f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22b4fc33948e49cc61891bb154e9acc"><td class="memItemLeft" align="right" valign="top"><a id="ab22b4fc33948e49cc61891bb154e9acc"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab22b4fc33948e49cc61891bb154e9acc">cubIntOrder</a></td></tr>
<tr class="memdesc:ab22b4fc33948e49cc61891bb154e9acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>cubature_integrand</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:ab22b4fc33948e49cc61891bb154e9acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b1ae15a923a3cfab811ee993758e76"><td class="memItemLeft" align="right" valign="top"><a id="a37b1ae15a923a3cfab811ee993758e76"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a37b1ae15a923a3cfab811ee993758e76">collocationRatio</a></td></tr>
<tr class="memdesc:a37b1ae15a923a3cfab811ee993758e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>collocation_ratio</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:a37b1ae15a923a3cfab811ee993758e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ffe7b89f160d3f2f67c59af063430a"><td class="memItemLeft" align="right" valign="top"><a id="a27ffe7b89f160d3f2f67c59af063430a"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a27ffe7b89f160d3f2f67c59af063430a">collocRatioTermsOrder</a></td></tr>
<tr class="memdesc:a27ffe7b89f160d3f2f67c59af063430a"><td class="mdescLeft">&#160;</td><td class="mdescRight">order applied to the number of expansion terms when applying or computing the collocation ratio within regression PCE; based on the <code>ratio_order</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:a27ffe7b89f160d3f2f67c59af063430a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e33f4350b2840e173b37a103552f27"><td class="memItemLeft" align="right" valign="top"><a id="aa3e33f4350b2840e173b37a103552f27"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa3e33f4350b2840e173b37a103552f27">regressionType</a></td></tr>
<tr class="memdesc:aa3e33f4350b2840e173b37a103552f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of regression: LS, OMP, BP, BPDN, LARS, or LASSO <br /></td></tr>
<tr class="separator:aa3e33f4350b2840e173b37a103552f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5236fa10b449fc399185a4b26556b0"><td class="memItemLeft" align="right" valign="top"><a id="a5d5236fa10b449fc399185a4b26556b0"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5d5236fa10b449fc399185a4b26556b0">lsRegressionType</a></td></tr>
<tr class="memdesc:a5d5236fa10b449fc399185a4b26556b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of least squares regression: SVD or EQ_CON_QR <br /></td></tr>
<tr class="separator:a5d5236fa10b449fc399185a4b26556b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fda89ab803e58d26247a61d95e887c6"><td class="memItemLeft" align="right" valign="top"><a id="a5fda89ab803e58d26247a61d95e887c6"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5fda89ab803e58d26247a61d95e887c6">regressionNoiseTol</a></td></tr>
<tr class="memdesc:a5fda89ab803e58d26247a61d95e887c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">noise tolerance(s) for OMP, BPDN, LARS, and LASSO <br /></td></tr>
<tr class="separator:a5fda89ab803e58d26247a61d95e887c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180f9961dd70f0bbf0b60138fbb9c5f0"><td class="memItemLeft" align="right" valign="top"><a id="a180f9961dd70f0bbf0b60138fbb9c5f0"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a180f9961dd70f0bbf0b60138fbb9c5f0">regressionL2Penalty</a></td></tr>
<tr class="memdesc:a180f9961dd70f0bbf0b60138fbb9c5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">L2 regression penalty for a variant of LASSO known as the elastic net method (default of 0 gives standard LASSO) <br /></td></tr>
<tr class="separator:a180f9961dd70f0bbf0b60138fbb9c5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba5c334e2daf8be3edc89f827ea125c"><td class="memItemLeft" align="right" valign="top"><a id="a0ba5c334e2daf8be3edc89f827ea125c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0ba5c334e2daf8be3edc89f827ea125c">crossValidation</a></td></tr>
<tr class="memdesc:a0ba5c334e2daf8be3edc89f827ea125c"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating the use of cross-validation across expansion orders (given a prescribed maximum order) and, for some methods, noise tolerances <br /></td></tr>
<tr class="separator:a0ba5c334e2daf8be3edc89f827ea125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752c167c63d9374fe0d8fdadca28cb8e"><td class="memItemLeft" align="right" valign="top"><a id="a752c167c63d9374fe0d8fdadca28cb8e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a752c167c63d9374fe0d8fdadca28cb8e">crossValidNoiseOnly</a></td></tr>
<tr class="memdesc:a752c167c63d9374fe0d8fdadca28cb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating the restriction of cross-validation to estimate only the most effective noise tolerance; used to reduce cost from performing CV over both noise tolerances and expansion orders <br /></td></tr>
<tr class="separator:a752c167c63d9374fe0d8fdadca28cb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44303abfbe9d734faade4dd6ce72ffb"><td class="memItemLeft" align="right" valign="top"><a id="ad44303abfbe9d734faade4dd6ce72ffb"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad44303abfbe9d734faade4dd6ce72ffb">adaptedBasisAdvancements</a></td></tr>
<tr class="memdesc:ad44303abfbe9d734faade4dd6ce72ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">initial grid level for the ADAPTED_BASIS_EXPANDING_FRONT approach to defining the candidate basis for sparse recovery (compressed sensing) <br /></td></tr>
<tr class="separator:ad44303abfbe9d734faade4dd6ce72ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a0bfba5f70ebdefc29c5b73cd8a964"><td class="memItemLeft" align="right" valign="top"><a id="aa8a0bfba5f70ebdefc29c5b73cd8a964"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa8a0bfba5f70ebdefc29c5b73cd8a964">normalizedCoeffs</a></td></tr>
<tr class="memdesc:aa8a0bfba5f70ebdefc29c5b73cd8a964"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating the output of PCE coefficients corresponding to normalized basis polynomials <br /></td></tr>
<tr class="separator:aa8a0bfba5f70ebdefc29c5b73cd8a964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84069a2ddaad44a28455cfbc55640fcc"><td class="memItemLeft" align="right" valign="top"><a id="a84069a2ddaad44a28455cfbc55640fcc"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a84069a2ddaad44a28455cfbc55640fcc">pointReuse</a></td></tr>
<tr class="memdesc:a84069a2ddaad44a28455cfbc55640fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows PCE construction to reuse points from previous sample sets or data import using the <code>reuse_points</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:a84069a2ddaad44a28455cfbc55640fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bed8af67c73e98c93b3c1049a13769b"><td class="memItemLeft" align="right" valign="top"><a id="a7bed8af67c73e98c93b3c1049a13769b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7bed8af67c73e98c93b3c1049a13769b">tensorGridFlag</a></td></tr>
<tr class="memdesc:a7bed8af67c73e98c93b3c1049a13769b"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for usage of a sub-sampled set of tensor-product grid points within regression PCE; based on the <code>tensor_grid</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:a7bed8af67c73e98c93b3c1049a13769b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd571986be7d7a7887b7cfcea9c390d"><td class="memItemLeft" align="right" valign="top"><a id="a0bd571986be7d7a7887b7cfcea9c390d"></a>
UShortArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0bd571986be7d7a7887b7cfcea9c390d">tensorGridOrder</a></td></tr>
<tr class="memdesc:a0bd571986be7d7a7887b7cfcea9c390d"><td class="mdescLeft">&#160;</td><td class="mdescRight">order of tensor-product grid points that are sub-sampled within orthogonal least interpolation PCE; based on the <code>tensor_grid</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:a0bd571986be7d7a7887b7cfcea9c390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf68341f54cbc20656b6f8b5b3404eeb"><td class="memItemLeft" align="right" valign="top"><a id="aaf68341f54cbc20656b6f8b5b3404eeb"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aaf68341f54cbc20656b6f8b5b3404eeb">importExpansionFile</a></td></tr>
<tr class="memdesc:aaf68341f54cbc20656b6f8b5b3404eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>import_expansion_file</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:aaf68341f54cbc20656b6f8b5b3404eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2292e0ba7d88252d95f7f1afd328435"><td class="memItemLeft" align="right" valign="top"><a id="ac2292e0ba7d88252d95f7f1afd328435"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac2292e0ba7d88252d95f7f1afd328435">exportExpansionFile</a></td></tr>
<tr class="memdesc:ac2292e0ba7d88252d95f7f1afd328435"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>export_expansion_file</code> specification in MethodNonDPCE <br /></td></tr>
<tr class="separator:ac2292e0ba7d88252d95f7f1afd328435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f14cca36ff99b36626a7b93ae60782"><td class="memItemLeft" align="right" valign="top"><a id="ac8f14cca36ff99b36626a7b93ae60782"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac8f14cca36ff99b36626a7b93ae60782">sampleType</a></td></tr>
<tr class="memdesc:ac8f14cca36ff99b36626a7b93ae60782"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>sample_type</code> specification in MethodNonDMC, MethodNonDPCE, and MethodNonDSC <br /></td></tr>
<tr class="separator:ac8f14cca36ff99b36626a7b93ae60782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7080b5abeff51a4ea709028fa1e7ce9c"><td class="memItemLeft" align="right" valign="top"><a id="a7080b5abeff51a4ea709028fa1e7ce9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7080b5abeff51a4ea709028fa1e7ce9c">dOptimal</a></td></tr>
<tr class="memdesc:a7080b5abeff51a4ea709028fa1e7ce9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to generate D-optimal designs <br /></td></tr>
<tr class="separator:a7080b5abeff51a4ea709028fa1e7ce9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71919d67af28f1714f603d2733fb9d0"><td class="memItemLeft" align="right" valign="top"><a id="ad71919d67af28f1714f603d2733fb9d0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad71919d67af28f1714f603d2733fb9d0">numCandidateDesigns</a></td></tr>
<tr class="memdesc:ad71919d67af28f1714f603d2733fb9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of candidate designss in D-optimal design selection <br /></td></tr>
<tr class="separator:ad71919d67af28f1714f603d2733fb9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daf127264b7ad732ca0f972e60b066a"><td class="memItemLeft" align="right" valign="top"><a id="a0daf127264b7ad732ca0f972e60b066a"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0daf127264b7ad732ca0f972e60b066a">reliabilityIntegration</a></td></tr>
<tr class="memdesc:a0daf127264b7ad732ca0f972e60b066a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>first_order</code> or <code>second_order</code> integration selection in MethodNonDLocalRel <br /></td></tr>
<tr class="separator:a0daf127264b7ad732ca0f972e60b066a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d880a807fc9ba40fd3865aebc171e9d"><td class="memItemLeft" align="right" valign="top"><a id="a0d880a807fc9ba40fd3865aebc171e9d"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0d880a807fc9ba40fd3865aebc171e9d">integrationRefine</a></td></tr>
<tr class="memdesc:a0d880a807fc9ba40fd3865aebc171e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>import</code>, <code>adapt_import</code>, or <code>mm_adapt_import</code> integration refinement selection in MethodNonDLocalRel, MethodNonDPCE, and MethodNonDSC <br /></td></tr>
<tr class="separator:a0d880a807fc9ba40fd3865aebc171e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d433959679e6a21e477e880fa95c3a"><td class="memItemLeft" align="right" valign="top"><a id="a82d433959679e6a21e477e880fa95c3a"></a>
IntVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a82d433959679e6a21e477e880fa95c3a">refineSamples</a></td></tr>
<tr class="memdesc:a82d433959679e6a21e477e880fa95c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of refinement samples, e.g., the size of the batch (e.g. number of supplemental points added) to be added to be added to the build points for an emulator at each iteration. <br /></td></tr>
<tr class="separator:a82d433959679e6a21e477e880fa95c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6bb2e174727151e878eebbf2a84b26"><td class="memItemLeft" align="right" valign="top"><a id="a0a6bb2e174727151e878eebbf2a84b26"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0a6bb2e174727151e878eebbf2a84b26">optSubProbSolver</a></td></tr>
<tr class="memdesc:a0a6bb2e174727151e878eebbf2a84b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">the method used for solving an optimization sub-problem (e.g., pre-solve for the MAP point) <br /></td></tr>
<tr class="separator:a0a6bb2e174727151e878eebbf2a84b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a8f9c3762e512b25440f68c8a02a2d"><td class="memItemLeft" align="right" valign="top"><a id="a14a8f9c3762e512b25440f68c8a02a2d"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a14a8f9c3762e512b25440f68c8a02a2d">numericalSolveMode</a></td></tr>
<tr class="memdesc:a14a8f9c3762e512b25440f68c8a02a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">approach for overriding an analytic solution based on simplifying assumptions that might be violated, suggesting a fallback approach, or lacking robustness, suggesting an optional override replacement <br /></td></tr>
<tr class="separator:a14a8f9c3762e512b25440f68c8a02a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5ab4780dd7e3bf8e1e030b2badc165"><td class="memItemLeft" align="right" valign="top"><a id="a7b5ab4780dd7e3bf8e1e030b2badc165"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7b5ab4780dd7e3bf8e1e030b2badc165">estVarMetricType</a></td></tr>
<tr class="memdesc:a7b5ab4780dd7e3bf8e1e030b2badc165"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of solver metric used in variance minimization / accuracy specification (average, max, or norm of estimator variance across QoI) <br /></td></tr>
<tr class="separator:a7b5ab4780dd7e3bf8e1e030b2badc165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba917867e80c9efcb96bf55267060ada"><td class="memItemLeft" align="right" valign="top"><a id="aba917867e80c9efcb96bf55267060ada"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aba917867e80c9efcb96bf55267060ada">estVarMetricNormOrder</a></td></tr>
<tr class="memdesc:aba917867e80c9efcb96bf55267060ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">for a norm-based solver metric (see estVarMetricType), the order of the norm employed across the QoI estimator variances <br /></td></tr>
<tr class="separator:aba917867e80c9efcb96bf55267060ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceb98535c150bcb26318cbb9fd35992"><td class="memItemLeft" align="right" valign="top"><a id="acceb98535c150bcb26318cbb9fd35992"></a>
SizetArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#acceb98535c150bcb26318cbb9fd35992">pilotSamples</a></td></tr>
<tr class="memdesc:acceb98535c150bcb26318cbb9fd35992"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>pilot_samples</code> selection in ML/MF methods <br /></td></tr>
<tr class="separator:acceb98535c150bcb26318cbb9fd35992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eb073188d05ee7324806feed2ee066"><td class="memItemLeft" align="right" valign="top"><a id="a97eb073188d05ee7324806feed2ee066"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a97eb073188d05ee7324806feed2ee066">ensemblePilotSolnMode</a></td></tr>
<tr class="memdesc:a97eb073188d05ee7324806feed2ee066"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>solution_mode</code> selection for ML/MF sampling methods <br /></td></tr>
<tr class="separator:a97eb073188d05ee7324806feed2ee066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8f5bc535aebe50fe79e477a3c13718"><td class="memItemLeft" align="right" valign="top"><a id="aee8f5bc535aebe50fe79e477a3c13718"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aee8f5bc535aebe50fe79e477a3c13718">pilotGroupSampling</a></td></tr>
<tr class="memdesc:aee8f5bc535aebe50fe79e477a3c13718"><td class="mdescLeft">&#160;</td><td class="mdescRight">the group sampling approach for pilot sampling in ML BLUE: independent or shared <br /></td></tr>
<tr class="separator:aee8f5bc535aebe50fe79e477a3c13718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60742572de1890abf49aa9e6f73390dd"><td class="memItemLeft" align="right" valign="top"><a id="a60742572de1890abf49aa9e6f73390dd"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a60742572de1890abf49aa9e6f73390dd">groupThrottleType</a></td></tr>
<tr class="memdesc:a60742572de1890abf49aa9e6f73390dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">approach to restricting the total number of groups in group estimators <br /></td></tr>
<tr class="separator:a60742572de1890abf49aa9e6f73390dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775c93c79aec8c9545da026282509074"><td class="memItemLeft" align="right" valign="top"><a id="a775c93c79aec8c9545da026282509074"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a775c93c79aec8c9545da026282509074">groupSizeThrottle</a></td></tr>
<tr class="memdesc:a775c93c79aec8c9545da026282509074"><td class="mdescLeft">&#160;</td><td class="mdescRight">restricting the number of group combinations in group estimators by enforcing a maximum size in terms of the number of models per group <br /></td></tr>
<tr class="separator:a775c93c79aec8c9545da026282509074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036b8803f0e3e33203b778a4f60cd1ab"><td class="memItemLeft" align="right" valign="top"><a id="a036b8803f0e3e33203b778a4f60cd1ab"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a036b8803f0e3e33203b778a4f60cd1ab">rCondBestThrottle</a></td></tr>
<tr class="memdesc:a036b8803f0e3e33203b778a4f60cd1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">restricting group combinations in group estimators by ranking and selecting the best subset of specified count in terms of group covariance conditioning <br /></td></tr>
<tr class="separator:a036b8803f0e3e33203b778a4f60cd1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeee365a9b5aeac88b3fe8c0b853a502"><td class="memItemLeft" align="right" valign="top"><a id="abeee365a9b5aeac88b3fe8c0b853a502"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abeee365a9b5aeac88b3fe8c0b853a502">rCondTolThrottle</a></td></tr>
<tr class="memdesc:abeee365a9b5aeac88b3fe8c0b853a502"><td class="mdescLeft">&#160;</td><td class="mdescRight">restricting group combinations in group estimators by enforcing a lower bound on group covariance conditioning (rcond is inverse of condition number) <br /></td></tr>
<tr class="separator:abeee365a9b5aeac88b3fe8c0b853a502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565a83d4f141c4c70d234eaf054a7af9"><td class="memItemLeft" align="right" valign="top"><a id="a565a83d4f141c4c70d234eaf054a7af9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a565a83d4f141c4c70d234eaf054a7af9">truthPilotConstraint</a></td></tr>
<tr class="memdesc:a565a83d4f141c4c70d234eaf054a7af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>truth_fixed_by_pilot</code> flag for ACV methods <br /></td></tr>
<tr class="separator:a565a83d4f141c4c70d234eaf054a7af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3578f6108c8c5a12d2bffae6186fe0d0"><td class="memItemLeft" align="right" valign="top"><a id="a3578f6108c8c5a12d2bffae6186fe0d0"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3578f6108c8c5a12d2bffae6186fe0d0">dagRecursionType</a></td></tr>
<tr class="memdesc:a3578f6108c8c5a12d2bffae6186fe0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">option specified for extent of DAG enumeration within <code>search_model_graphs</code> for generalized ACV methods <br /></td></tr>
<tr class="separator:a3578f6108c8c5a12d2bffae6186fe0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bc2a8ecfa5300c6836da346619c5ae"><td class="memItemLeft" align="right" valign="top"><a id="ad8bc2a8ecfa5300c6836da346619c5ae"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad8bc2a8ecfa5300c6836da346619c5ae">dagDepthLimit</a></td></tr>
<tr class="memdesc:ad8bc2a8ecfa5300c6836da346619c5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">option specified for <code>depth_limit</code> in generalized ACV methods with partial graph recursion <br /></td></tr>
<tr class="separator:ad8bc2a8ecfa5300c6836da346619c5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6804b1e330ecd6afecd9cd2ffe0dc2bd"><td class="memItemLeft" align="right" valign="top"><a id="a6804b1e330ecd6afecd9cd2ffe0dc2bd"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6804b1e330ecd6afecd9cd2ffe0dc2bd">modelSelectType</a></td></tr>
<tr class="memdesc:a6804b1e330ecd6afecd9cd2ffe0dc2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">option specified for <code>model_selection</code> within <code>search_model_graphs</code> for generalized ACV methods <br /></td></tr>
<tr class="separator:a6804b1e330ecd6afecd9cd2ffe0dc2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dc13ddc34eb3493459c81b7b1f5c05"><td class="memItemLeft" align="right" valign="top"><a id="a78dc13ddc34eb3493459c81b7b1f5c05"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a78dc13ddc34eb3493459c81b7b1f5c05">relaxFactorSequence</a></td></tr>
<tr class="memdesc:a78dc13ddc34eb3493459c81b7b1f5c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">sequence of (under-)relaxation factors that are applied to sample increments computed in the latest ML/MF allocation solution: f_i = f_seq[i] for iter &lt;= len, f_seq[last_i] for iter &gt; len <br /></td></tr>
<tr class="separator:a78dc13ddc34eb3493459c81b7b1f5c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7731d02cb16d6ac32cdb3e5c3786c3"><td class="memItemLeft" align="right" valign="top"><a id="a3c7731d02cb16d6ac32cdb3e5c3786c3"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3c7731d02cb16d6ac32cdb3e5c3786c3">relaxFixedFactor</a></td></tr>
<tr class="memdesc:a3c7731d02cb16d6ac32cdb3e5c3786c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">fixed (under-)relaxation factor applied to sample increments computed in the latest ML/MF allocation solution: f_i = f_fixed for all iter <br /></td></tr>
<tr class="separator:a3c7731d02cb16d6ac32cdb3e5c3786c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50df0554d4f79a93f9a421b550c91cfa"><td class="memItemLeft" align="right" valign="top"><a id="a50df0554d4f79a93f9a421b550c91cfa"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a50df0554d4f79a93f9a421b550c91cfa">relaxRecursiveFactor</a></td></tr>
<tr class="memdesc:a50df0554d4f79a93f9a421b550c91cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">(under-)relaxation factor that is applied to sample increments computed in the latest ML/MF allocation solution. The relaxation factor for each iteration (f_i) is defined from recursive application of the user specification (f_recur) to the remaining partition of unity: f_{i+1} = f_i + f_recur (1 - f_i), where f_0 = 0 gives f_1 = f_recur. E.g., f_recur = 0.5 gives f_i = 0.5, .75, .875, .9375, ... <br /></td></tr>
<tr class="separator:a50df0554d4f79a93f9a421b550c91cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783cfc538ca832a9e322cdebc6a0f792"><td class="memItemLeft" align="right" valign="top"><a id="a783cfc538ca832a9e322cdebc6a0f792"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a783cfc538ca832a9e322cdebc6a0f792">allocationTarget</a></td></tr>
<tr class="memdesc:a783cfc538ca832a9e322cdebc6a0f792"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>allocationTarget</code> selection in MethodMultilevelMC <br /></td></tr>
<tr class="separator:a783cfc538ca832a9e322cdebc6a0f792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a82e05ecb84892c754885ce1edae88"><td class="memItemLeft" align="right" valign="top"><a id="ac0a82e05ecb84892c754885ce1edae88"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac0a82e05ecb84892c754885ce1edae88">useTargetVarianceOptimizationFlag</a></td></tr>
<tr class="memdesc:ac0a82e05ecb84892c754885ce1edae88"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>allocation_target</code> selection in MethodMultilevelMC <br /></td></tr>
<tr class="separator:ac0a82e05ecb84892c754885ce1edae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9df29f199776524851c63462aab237"><td class="memItemLeft" align="right" valign="top"><a id="aca9df29f199776524851c63462aab237"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aca9df29f199776524851c63462aab237">qoiAggregation</a></td></tr>
<tr class="memdesc:aca9df29f199776524851c63462aab237"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>qoi_aggregation_norm</code> selection in MethodMultilevelMC <br /></td></tr>
<tr class="separator:aca9df29f199776524851c63462aab237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaad680fb1d09532f2d6eb4cceae713f"><td class="memItemLeft" align="right" valign="top"><a id="abaad680fb1d09532f2d6eb4cceae713f"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abaad680fb1d09532f2d6eb4cceae713f">scalarizationRespCoeffs</a></td></tr>
<tr class="memdesc:abaad680fb1d09532f2d6eb4cceae713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>scalarization_response_mapping</code> for defining the statistical goal in multilevel UQ methods <br /></td></tr>
<tr class="separator:abaad680fb1d09532f2d6eb4cceae713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69c001e9eddeea50efa2ae9d49a0b28"><td class="memItemLeft" align="right" valign="top"><a id="af69c001e9eddeea50efa2ae9d49a0b28"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af69c001e9eddeea50efa2ae9d49a0b28">convergenceToleranceType</a></td></tr>
<tr class="memdesc:af69c001e9eddeea50efa2ae9d49a0b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>convergence_tolerance_type</code> selection in MethodMultilevelMC <br /></td></tr>
<tr class="separator:af69c001e9eddeea50efa2ae9d49a0b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae861f83f4b121fd612be3a8a7a6cdc27"><td class="memItemLeft" align="right" valign="top"><a id="ae861f83f4b121fd612be3a8a7a6cdc27"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae861f83f4b121fd612be3a8a7a6cdc27">convergenceToleranceTarget</a></td></tr>
<tr class="memdesc:ae861f83f4b121fd612be3a8a7a6cdc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>convergence_tolerance_target</code> selection in MethodMultilevelMC <br /></td></tr>
<tr class="separator:ae861f83f4b121fd612be3a8a7a6cdc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205b741420ab9690bf6f50a719e7bc89"><td class="memItemLeft" align="right" valign="top"><a id="a205b741420ab9690bf6f50a719e7bc89"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a205b741420ab9690bf6f50a719e7bc89">multilevAllocControl</a></td></tr>
<tr class="memdesc:a205b741420ab9690bf6f50a719e7bc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>allocation_control</code> selection in MethodMultilevelPCE <br /></td></tr>
<tr class="separator:a205b741420ab9690bf6f50a719e7bc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa9beed4a8941eb15d7f793b3cdfe2a"><td class="memItemLeft" align="right" valign="top"><a id="adfa9beed4a8941eb15d7f793b3cdfe2a"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#adfa9beed4a8941eb15d7f793b3cdfe2a">multilevEstimatorRate</a></td></tr>
<tr class="memdesc:adfa9beed4a8941eb15d7f793b3cdfe2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>estimator_rate</code> selection in MethodMultilevelPCE <br /></td></tr>
<tr class="separator:adfa9beed4a8941eb15d7f793b3cdfe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a03158524e05f6c008f2ab8248e725"><td class="memItemLeft" align="right" valign="top"><a id="ad6a03158524e05f6c008f2ab8248e725"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad6a03158524e05f6c008f2ab8248e725">multilevDiscrepEmulation</a></td></tr>
<tr class="memdesc:ad6a03158524e05f6c008f2ab8248e725"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of discrepancy emulation in multilevel methods: distinct or recursive <br /></td></tr>
<tr class="separator:ad6a03158524e05f6c008f2ab8248e725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d23ec5310d446e98d975470b85851d"><td class="memItemLeft" align="right" valign="top"><a id="a80d23ec5310d446e98d975470b85851d"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a80d23ec5310d446e98d975470b85851d">finalStatsType</a></td></tr>
<tr class="memdesc:a80d23ec5310d446e98d975470b85851d"><td class="mdescLeft">&#160;</td><td class="mdescRight">specification of the type of final statistics in MethodNonD <br /></td></tr>
<tr class="separator:a80d23ec5310d446e98d975470b85851d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7e61c30e92b13fdb9c647e9b9b97a5"><td class="memItemLeft" align="right" valign="top"><a id="a0d7e61c30e92b13fdb9c647e9b9b97a5"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0d7e61c30e92b13fdb9c647e9b9b97a5">finalMomentsType</a></td></tr>
<tr class="memdesc:a0d7e61c30e92b13fdb9c647e9b9b97a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>final_moments</code> specification in MethodNonD, subordinate to the type of final statistics <br /></td></tr>
<tr class="separator:a0d7e61c30e92b13fdb9c647e9b9b97a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885e61a742d9580b5d4df39f997cb706"><td class="memItemLeft" align="right" valign="top"><a id="a885e61a742d9580b5d4df39f997cb706"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a885e61a742d9580b5d4df39f997cb706">distributionType</a></td></tr>
<tr class="memdesc:a885e61a742d9580b5d4df39f997cb706"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>distribution</code> <code>cumulative</code> or <code>complementary</code> specification in MethodNonD <br /></td></tr>
<tr class="separator:a885e61a742d9580b5d4df39f997cb706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0759c98efddd8ae5fca304b5bb87d275"><td class="memItemLeft" align="right" valign="top"><a id="a0759c98efddd8ae5fca304b5bb87d275"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0759c98efddd8ae5fca304b5bb87d275">responseLevelTarget</a></td></tr>
<tr class="memdesc:a0759c98efddd8ae5fca304b5bb87d275"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>compute</code> <code>probabilities</code>, <code>reliabilities</code>, or <code>gen_reliabilities</code> specification in MethodNonD <br /></td></tr>
<tr class="separator:a0759c98efddd8ae5fca304b5bb87d275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f552fcfb2c206111ac006a08c5df4ea"><td class="memItemLeft" align="right" valign="top"><a id="a2f552fcfb2c206111ac006a08c5df4ea"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2f552fcfb2c206111ac006a08c5df4ea">responseLevelTargetReduce</a></td></tr>
<tr class="memdesc:a2f552fcfb2c206111ac006a08c5df4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>system</code> <code>series</code> or <code>parallel</code> specification in MethodNonD <br /></td></tr>
<tr class="separator:a2f552fcfb2c206111ac006a08c5df4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862ac84e41371d92e61c500f40c1343a"><td class="memItemLeft" align="right" valign="top"><a id="a862ac84e41371d92e61c500f40c1343a"></a>
RealVectorArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a862ac84e41371d92e61c500f40c1343a">responseLevels</a></td></tr>
<tr class="memdesc:a862ac84e41371d92e61c500f40c1343a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>response_levels</code> specification in MethodNonD <br /></td></tr>
<tr class="separator:a862ac84e41371d92e61c500f40c1343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4126941096963a13ed7742134d1856"><td class="memItemLeft" align="right" valign="top"><a id="acc4126941096963a13ed7742134d1856"></a>
RealVectorArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#acc4126941096963a13ed7742134d1856">probabilityLevels</a></td></tr>
<tr class="memdesc:acc4126941096963a13ed7742134d1856"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>probability_levels</code> specification in MethodNonD <br /></td></tr>
<tr class="separator:acc4126941096963a13ed7742134d1856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0ee1af6ea3d4c633fc085361e5d1f0"><td class="memItemLeft" align="right" valign="top"><a id="acc0ee1af6ea3d4c633fc085361e5d1f0"></a>
RealVectorArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#acc0ee1af6ea3d4c633fc085361e5d1f0">reliabilityLevels</a></td></tr>
<tr class="memdesc:acc0ee1af6ea3d4c633fc085361e5d1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>reliability_levels</code> specification in MethodNonD <br /></td></tr>
<tr class="separator:acc0ee1af6ea3d4c633fc085361e5d1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf47c64d05904e0f2f793eb565f7ff21"><td class="memItemLeft" align="right" valign="top"><a id="acf47c64d05904e0f2f793eb565f7ff21"></a>
RealVectorArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#acf47c64d05904e0f2f793eb565f7ff21">genReliabilityLevels</a></td></tr>
<tr class="memdesc:acf47c64d05904e0f2f793eb565f7ff21"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>gen_reliability_levels</code> specification in MethodNonD <br /></td></tr>
<tr class="separator:acf47c64d05904e0f2f793eb565f7ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33da7d968598ce1643a1af4e058ef24"><td class="memItemLeft" align="right" valign="top"><a id="ac33da7d968598ce1643a1af4e058ef24"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac33da7d968598ce1643a1af4e058ef24">chainSamples</a></td></tr>
<tr class="memdesc:ac33da7d968598ce1643a1af4e058ef24"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of MCMC chain samples <br /></td></tr>
<tr class="separator:ac33da7d968598ce1643a1af4e058ef24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd74bb75c5cd34c607bf4570cc03724"><td class="memItemLeft" align="right" valign="top"><a id="a9cd74bb75c5cd34c607bf4570cc03724"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9cd74bb75c5cd34c607bf4570cc03724">buildSamples</a></td></tr>
<tr class="memdesc:a9cd74bb75c5cd34c607bf4570cc03724"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of samples to construct an emulator, e.g., for Bayesian calibration methods <br /></td></tr>
<tr class="separator:a9cd74bb75c5cd34c607bf4570cc03724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbfd181d407695212c6a97a515b14d7"><td class="memItemLeft" align="right" valign="top"><a id="a1bbfd181d407695212c6a97a515b14d7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1bbfd181d407695212c6a97a515b14d7">samplesOnEmulator</a></td></tr>
<tr class="memdesc:a1bbfd181d407695212c6a97a515b14d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of samples to perform on emulator <br /></td></tr>
<tr class="separator:a1bbfd181d407695212c6a97a515b14d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf527cce5ff09ba157d0fbe6f3d15e0e"><td class="memItemLeft" align="right" valign="top"><a id="acf527cce5ff09ba157d0fbe6f3d15e0e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#acf527cce5ff09ba157d0fbe6f3d15e0e">emulatorOrder</a></td></tr>
<tr class="memdesc:acf527cce5ff09ba157d0fbe6f3d15e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total order to be used in construction of a VPS surrogate. <br /></td></tr>
<tr class="separator:acf527cce5ff09ba157d0fbe6f3d15e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a0c43f1e2551ad9380f58c7ddf68a2"><td class="memItemLeft" align="right" valign="top"><a id="a38a0c43f1e2551ad9380f58c7ddf68a2"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a38a0c43f1e2551ad9380f58c7ddf68a2">emulatorType</a></td></tr>
<tr class="memdesc:a38a0c43f1e2551ad9380f58c7ddf68a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>emulator</code> specification in MethodNonDBayesCalib <br /></td></tr>
<tr class="separator:a38a0c43f1e2551ad9380f58c7ddf68a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc472ee0067e717246231ac16ca4e44"><td class="memItemLeft" align="right" valign="top"><a id="a3dc472ee0067e717246231ac16ca4e44"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3dc472ee0067e717246231ac16ca4e44">mcmcType</a></td></tr>
<tr class="memdesc:a3dc472ee0067e717246231ac16ca4e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>mcmc</code> type specification in MethodNonDBayesCalib <br /></td></tr>
<tr class="separator:a3dc472ee0067e717246231ac16ca4e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7393cf10007f085712931ecab57c4cb2"><td class="memItemLeft" align="right" valign="top"><a id="a7393cf10007f085712931ecab57c4cb2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7393cf10007f085712931ecab57c4cb2">standardizedSpace</a></td></tr>
<tr class="memdesc:a7393cf10007f085712931ecab57c4cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">use of standardized probability spaces for MCMC within Bayesian inference <br /></td></tr>
<tr class="separator:a7393cf10007f085712931ecab57c4cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dc7ca5916626b4210831ee3ae11226"><td class="memItemLeft" align="right" valign="top"><a id="a32dc7ca5916626b4210831ee3ae11226"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a32dc7ca5916626b4210831ee3ae11226">adaptPosteriorRefine</a></td></tr>
<tr class="memdesc:a32dc7ca5916626b4210831ee3ae11226"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating adaptive refinement of the emulator in regions of high posterior probability <br /></td></tr>
<tr class="separator:a32dc7ca5916626b4210831ee3ae11226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da1962e88c63e2c6d54e6816073d90a"><td class="memItemLeft" align="right" valign="top"><a id="a4da1962e88c63e2c6d54e6816073d90a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4da1962e88c63e2c6d54e6816073d90a">logitTransform</a></td></tr>
<tr class="memdesc:a4da1962e88c63e2c6d54e6816073d90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating user activation of logit transform option within QUESO <br /></td></tr>
<tr class="separator:a4da1962e88c63e2c6d54e6816073d90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da7768b1edd731e6c4cd6acd3e52c7f"><td class="memItemLeft" align="right" valign="top"><a id="a7da7768b1edd731e6c4cd6acd3e52c7f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7da7768b1edd731e6c4cd6acd3e52c7f">gpmsaNormalize</a></td></tr>
<tr class="memdesc:a7da7768b1edd731e6c4cd6acd3e52c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to apply GPMSA-internal normalization <br /></td></tr>
<tr class="separator:a7da7768b1edd731e6c4cd6acd3e52c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387848e990296344455ba2d5eca27093"><td class="memItemLeft" align="right" valign="top"><a id="a387848e990296344455ba2d5eca27093"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a387848e990296344455ba2d5eca27093">posteriorStatsKL</a></td></tr>
<tr class="memdesc:a387848e990296344455ba2d5eca27093"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating the calculation of KL divergence between prior and posterior in Bayesian methods <br /></td></tr>
<tr class="separator:a387848e990296344455ba2d5eca27093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf9f5c50e490634b05f5f34dbe213a0"><td class="memItemLeft" align="right" valign="top"><a id="aabf9f5c50e490634b05f5f34dbe213a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aabf9f5c50e490634b05f5f34dbe213a0">posteriorStatsMutual</a></td></tr>
<tr class="memdesc:aabf9f5c50e490634b05f5f34dbe213a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating the calculation of mutual information between prior and posterior in Bayesian methods <br /></td></tr>
<tr class="separator:aabf9f5c50e490634b05f5f34dbe213a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c24f7acdadf4ce32b7db427891169aa"><td class="memItemLeft" align="right" valign="top"><a id="a5c24f7acdadf4ce32b7db427891169aa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5c24f7acdadf4ce32b7db427891169aa">posteriorStatsKDE</a></td></tr>
<tr class="memdesc:a5c24f7acdadf4ce32b7db427891169aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating calculation of kernel density estimate of posterior distributions <br /></td></tr>
<tr class="separator:a5c24f7acdadf4ce32b7db427891169aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbebd4ad1735c9186d95a68675ad81b"><td class="memItemLeft" align="right" valign="top"><a id="a9fbebd4ad1735c9186d95a68675ad81b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9fbebd4ad1735c9186d95a68675ad81b">chainDiagnostics</a></td></tr>
<tr class="memdesc:a9fbebd4ad1735c9186d95a68675ad81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating calculation of chain diagnostics <br /></td></tr>
<tr class="separator:a9fbebd4ad1735c9186d95a68675ad81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bc22fc0cdbb870c2b6f0744b0129a4"><td class="memItemLeft" align="right" valign="top"><a id="a39bc22fc0cdbb870c2b6f0744b0129a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a39bc22fc0cdbb870c2b6f0744b0129a4">chainDiagnosticsCI</a></td></tr>
<tr class="memdesc:a39bc22fc0cdbb870c2b6f0744b0129a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating calculation of confidence intervals as a chain diagnositc <br /></td></tr>
<tr class="separator:a39bc22fc0cdbb870c2b6f0744b0129a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccbeaf980fa6b286c0ded937b99f6e8"><td class="memItemLeft" align="right" valign="top"><a id="acccbeaf980fa6b286c0ded937b99f6e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#acccbeaf980fa6b286c0ded937b99f6e8">modelEvidence</a></td></tr>
<tr class="memdesc:acccbeaf980fa6b286c0ded937b99f6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating calculation of the evidence of the model <br /></td></tr>
<tr class="separator:acccbeaf980fa6b286c0ded937b99f6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab448dc0c1828b35ff331084357b02a77"><td class="memItemLeft" align="right" valign="top"><a id="ab448dc0c1828b35ff331084357b02a77"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab448dc0c1828b35ff331084357b02a77">modelEvidMC</a></td></tr>
<tr class="memdesc:ab448dc0c1828b35ff331084357b02a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating use of Monte Carlo approximation for evidence calc. <br /></td></tr>
<tr class="separator:ab448dc0c1828b35ff331084357b02a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78513b159363444aa40332d2ac3c938"><td class="memItemLeft" align="right" valign="top"><a id="ad78513b159363444aa40332d2ac3c938"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad78513b159363444aa40332d2ac3c938">evidenceSamples</a></td></tr>
<tr class="memdesc:ad78513b159363444aa40332d2ac3c938"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of prior samples to use in model evidence calculation <br /></td></tr>
<tr class="separator:ad78513b159363444aa40332d2ac3c938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8dbd03e294b5e92831987e725b5141"><td class="memItemLeft" align="right" valign="top"><a id="abe8dbd03e294b5e92831987e725b5141"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abe8dbd03e294b5e92831987e725b5141">modelEvidLaplace</a></td></tr>
<tr class="memdesc:abe8dbd03e294b5e92831987e725b5141"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating use of Laplace approximation for evidence calc. <br /></td></tr>
<tr class="separator:abe8dbd03e294b5e92831987e725b5141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993fc5709d42022077f239accb6a180"><td class="memItemLeft" align="right" valign="top"><a id="a4993fc5709d42022077f239accb6a180"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4993fc5709d42022077f239accb6a180">proposalCovType</a></td></tr>
<tr class="memdesc:a4993fc5709d42022077f239accb6a180"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of proposal covariance: user, derivatives, or prior <br /></td></tr>
<tr class="separator:a4993fc5709d42022077f239accb6a180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74c4d8816e4650d20fcfea53edf372c"><td class="memItemLeft" align="right" valign="top"><a id="aa74c4d8816e4650d20fcfea53edf372c"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa74c4d8816e4650d20fcfea53edf372c">priorPropCovMult</a></td></tr>
<tr class="memdesc:aa74c4d8816e4650d20fcfea53edf372c"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional multiplier for prior-based proposal covariance <br /></td></tr>
<tr class="separator:aa74c4d8816e4650d20fcfea53edf372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85296972432091c1319a795342588d82"><td class="memItemLeft" align="right" valign="top"><a id="a85296972432091c1319a795342588d82"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a85296972432091c1319a795342588d82">proposalCovUpdatePeriod</a></td></tr>
<tr class="memdesc:a85296972432091c1319a795342588d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of samples after which to update the proposal covariance from misfit Hessian (using residual values and derivatives) <br /></td></tr>
<tr class="separator:a85296972432091c1319a795342588d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4154a57df147d9c2d424b8068c93449"><td class="memItemLeft" align="right" valign="top"><a id="ad4154a57df147d9c2d424b8068c93449"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad4154a57df147d9c2d424b8068c93449">proposalCovInputType</a></td></tr>
<tr class="memdesc:ad4154a57df147d9c2d424b8068c93449"><td class="mdescLeft">&#160;</td><td class="mdescRight">the format of proposal covariance input: diagonal or matrix <br /></td></tr>
<tr class="separator:ad4154a57df147d9c2d424b8068c93449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56245387e70b4cfe91772e5edae5706e"><td class="memItemLeft" align="right" valign="top"><a id="a56245387e70b4cfe91772e5edae5706e"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a56245387e70b4cfe91772e5edae5706e">proposalCovData</a></td></tr>
<tr class="memdesc:a56245387e70b4cfe91772e5edae5706e"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw list of real data for the proposal covariance <br /></td></tr>
<tr class="separator:a56245387e70b4cfe91772e5edae5706e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ec998fd5688abf031e329dc889165b"><td class="memItemLeft" align="right" valign="top"><a id="ad7ec998fd5688abf031e329dc889165b"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad7ec998fd5688abf031e329dc889165b">proposalCovFile</a></td></tr>
<tr class="memdesc:ad7ec998fd5688abf031e329dc889165b"><td class="mdescLeft">&#160;</td><td class="mdescRight">file from which to read proposal covariance in diagonal or matrix format <br /></td></tr>
<tr class="separator:ad7ec998fd5688abf031e329dc889165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e25ef67d40b0e50f92475caeb6923"><td class="memItemLeft" align="right" valign="top"><a id="ab45e25ef67d40b0e50f92475caeb6923"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab45e25ef67d40b0e50f92475caeb6923">advancedOptionsFilename</a></td></tr>
<tr class="memdesc:ab45e25ef67d40b0e50f92475caeb6923"><td class="mdescLeft">&#160;</td><td class="mdescRight">file containing advanced ROL option overrides <br /></td></tr>
<tr class="separator:ab45e25ef67d40b0e50f92475caeb6923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebfd9eb3d391021cdeb3c20910da2a6"><td class="memItemLeft" align="right" valign="top"><a id="abebfd9eb3d391021cdeb3c20910da2a6"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abebfd9eb3d391021cdeb3c20910da2a6">quesoOptionsFilename</a></td></tr>
<tr class="memdesc:abebfd9eb3d391021cdeb3c20910da2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">file containing advanced QUESO option overrides <br /></td></tr>
<tr class="separator:abebfd9eb3d391021cdeb3c20910da2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150cd5568c2ed871b6650b25294dc04b"><td class="memItemLeft" align="right" valign="top"><a id="a150cd5568c2ed871b6650b25294dc04b"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a150cd5568c2ed871b6650b25294dc04b">fitnessMetricType</a></td></tr>
<tr class="memdesc:a150cd5568c2ed871b6650b25294dc04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>fitness</code> metric type specification in MethodNonDAdaptive <br /></td></tr>
<tr class="separator:a150cd5568c2ed871b6650b25294dc04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b30a4eb955facdcd18961c2d12cffb8"><td class="memItemLeft" align="right" valign="top"><a id="a6b30a4eb955facdcd18961c2d12cffb8"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6b30a4eb955facdcd18961c2d12cffb8">batchSelectionType</a></td></tr>
<tr class="memdesc:a6b30a4eb955facdcd18961c2d12cffb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>batch</code> selection type specification in MethodNonDAdaptive <br /></td></tr>
<tr class="separator:a6b30a4eb955facdcd18961c2d12cffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fefb736adcb15ae4a7fe3ec161b656"><td class="memItemLeft" align="right" valign="top"><a id="a51fefb736adcb15ae4a7fe3ec161b656"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a51fefb736adcb15ae4a7fe3ec161b656">lipschitzType</a></td></tr>
<tr class="memdesc:a51fefb736adcb15ae4a7fe3ec161b656"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>Lipschitz</code> type specification in MethodNonDPOFDarts (e.g. either local or global estimation) <br /></td></tr>
<tr class="separator:a51fefb736adcb15ae4a7fe3ec161b656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898b3efda1459c883fa5607e3ae99c2e"><td class="memItemLeft" align="right" valign="top"><a id="a898b3efda1459c883fa5607e3ae99c2e"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a898b3efda1459c883fa5607e3ae99c2e">calibrateErrorMode</a></td></tr>
<tr class="memdesc:a898b3efda1459c883fa5607e3ae99c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calibration mode for observation error multipliers (CALIBRATE_*) <br /></td></tr>
<tr class="separator:a898b3efda1459c883fa5607e3ae99c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9272e7742779a8bb4e0e7704a5e13773"><td class="memItemLeft" align="right" valign="top"><a id="a9272e7742779a8bb4e0e7704a5e13773"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9272e7742779a8bb4e0e7704a5e13773">hyperPriorAlphas</a></td></tr>
<tr class="memdesc:a9272e7742779a8bb4e0e7704a5e13773"><td class="mdescLeft">&#160;</td><td class="mdescRight">hyperparameters inverse gamma prior alphas <br /></td></tr>
<tr class="separator:a9272e7742779a8bb4e0e7704a5e13773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248a055e0da16385abeeb153d600f2fc"><td class="memItemLeft" align="right" valign="top"><a id="a248a055e0da16385abeeb153d600f2fc"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a248a055e0da16385abeeb153d600f2fc">hyperPriorBetas</a></td></tr>
<tr class="memdesc:a248a055e0da16385abeeb153d600f2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">hyperparameters inverse gamma prior alphas <br /></td></tr>
<tr class="separator:a248a055e0da16385abeeb153d600f2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5ad684ed465b6bd83757b41dead0d8"><td class="memItemLeft" align="right" valign="top"><a id="a1f5ad684ed465b6bd83757b41dead0d8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1f5ad684ed465b6bd83757b41dead0d8">burnInSamples</a></td></tr>
<tr class="memdesc:a1f5ad684ed465b6bd83757b41dead0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of MCMC samples to discard from acceptance chain <br /></td></tr>
<tr class="separator:a1f5ad684ed465b6bd83757b41dead0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303fb8110a3b0739ea9a3e3b41277d8b"><td class="memItemLeft" align="right" valign="top"><a id="a303fb8110a3b0739ea9a3e3b41277d8b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a303fb8110a3b0739ea9a3e3b41277d8b">subSamplingPeriod</a></td></tr>
<tr class="memdesc:a303fb8110a3b0739ea9a3e3b41277d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">period or skip in post-processing the acceptance chain <br /></td></tr>
<tr class="separator:a303fb8110a3b0739ea9a3e3b41277d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec80e7a5e38fef3a77a695a776891c8c"><td class="memItemLeft" align="right" valign="top"><a id="aec80e7a5e38fef3a77a695a776891c8c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aec80e7a5e38fef3a77a695a776891c8c">calModelDiscrepancy</a></td></tr>
<tr class="memdesc:aec80e7a5e38fef3a77a695a776891c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to calculate model discrepancy <br /></td></tr>
<tr class="separator:aec80e7a5e38fef3a77a695a776891c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4ef7e7b6c61541389fcd2e8668c391"><td class="memItemLeft" align="right" valign="top"><a id="a7a4ef7e7b6c61541389fcd2e8668c391"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7a4ef7e7b6c61541389fcd2e8668c391">numPredConfigs</a></td></tr>
<tr class="memdesc:a7a4ef7e7b6c61541389fcd2e8668c391"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of prediction configurations at which to calculate model discrepancy <br /></td></tr>
<tr class="separator:a7a4ef7e7b6c61541389fcd2e8668c391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a8f3ffa64eb7d2ecf3563a32f901ea"><td class="memItemLeft" align="right" valign="top"><a id="a09a8f3ffa64eb7d2ecf3563a32f901ea"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a09a8f3ffa64eb7d2ecf3563a32f901ea">predictionConfigList</a></td></tr>
<tr class="memdesc:a09a8f3ffa64eb7d2ecf3563a32f901ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of prediction configurations at which to calculate model discrepancy <br /></td></tr>
<tr class="separator:a09a8f3ffa64eb7d2ecf3563a32f901ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca50bcef7429db418cf9ac25f96b6ba"><td class="memItemLeft" align="right" valign="top"><a id="a7ca50bcef7429db418cf9ac25f96b6ba"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7ca50bcef7429db418cf9ac25f96b6ba">importPredConfigs</a></td></tr>
<tr class="memdesc:a7ca50bcef7429db418cf9ac25f96b6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to import prediction configurations at which to calculate model discrepancy <br /></td></tr>
<tr class="separator:a7ca50bcef7429db418cf9ac25f96b6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350b934d8d7ed42e6b6df5599abc3891"><td class="memItemLeft" align="right" valign="top"><a id="a350b934d8d7ed42e6b6df5599abc3891"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a350b934d8d7ed42e6b6df5599abc3891">importPredConfigFormat</a></td></tr>
<tr class="memdesc:a350b934d8d7ed42e6b6df5599abc3891"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for prediction configurations import file <br /></td></tr>
<tr class="separator:a350b934d8d7ed42e6b6df5599abc3891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e28239e5e8a1f37f15772dbc183bcc8"><td class="memItemLeft" align="right" valign="top"><a id="a4e28239e5e8a1f37f15772dbc183bcc8"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4e28239e5e8a1f37f15772dbc183bcc8">modelDiscrepancyType</a></td></tr>
<tr class="memdesc:a4e28239e5e8a1f37f15772dbc183bcc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of model discrepancy emulation <br /></td></tr>
<tr class="separator:a4e28239e5e8a1f37f15772dbc183bcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d6d61ae7dc57c1d899a23fda3ea31"><td class="memItemLeft" align="right" valign="top"><a id="a7c0d6d61ae7dc57c1d899a23fda3ea31"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7c0d6d61ae7dc57c1d899a23fda3ea31">polynomialOrder</a></td></tr>
<tr class="memdesc:a7c0d6d61ae7dc57c1d899a23fda3ea31"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial order for model discrepancy calculations: either gaussian process trend order or polynomial basis order <br /></td></tr>
<tr class="separator:a7c0d6d61ae7dc57c1d899a23fda3ea31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab97f382de5ae73426112078f8d5c69"><td class="memItemLeft" align="right" valign="top"><a id="aaab97f382de5ae73426112078f8d5c69"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aaab97f382de5ae73426112078f8d5c69">exportCorrModelFile</a></td></tr>
<tr class="memdesc:aaab97f382de5ae73426112078f8d5c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify the name of file to which corrected model (model+discrepancy) calculations are output <br /></td></tr>
<tr class="separator:aaab97f382de5ae73426112078f8d5c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0608f10ec757fc7d7da09351691e9369"><td class="memItemLeft" align="right" valign="top"><a id="a0608f10ec757fc7d7da09351691e9369"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0608f10ec757fc7d7da09351691e9369">exportCorrModelFormat</a></td></tr>
<tr class="memdesc:a0608f10ec757fc7d7da09351691e9369"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for corrected model (model+discrepancy) export file <br /></td></tr>
<tr class="separator:a0608f10ec757fc7d7da09351691e9369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881294698b800d07bbe810e22e0d8679"><td class="memItemLeft" align="right" valign="top"><a id="a881294698b800d07bbe810e22e0d8679"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a881294698b800d07bbe810e22e0d8679">exportCorrVarFile</a></td></tr>
<tr class="memdesc:a881294698b800d07bbe810e22e0d8679"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify the name of file to which corrected model variance calculations are output <br /></td></tr>
<tr class="separator:a881294698b800d07bbe810e22e0d8679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdb3b18034e7a7ef26b0f89d3b6d8f4"><td class="memItemLeft" align="right" valign="top"><a id="abcdb3b18034e7a7ef26b0f89d3b6d8f4"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#abcdb3b18034e7a7ef26b0f89d3b6d8f4">exportCorrVarFormat</a></td></tr>
<tr class="memdesc:abcdb3b18034e7a7ef26b0f89d3b6d8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for corrected model variance export file <br /></td></tr>
<tr class="separator:abcdb3b18034e7a7ef26b0f89d3b6d8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98090b59e8ae6f10a510d63fe027e427"><td class="memItemLeft" align="right" valign="top"><a id="a98090b59e8ae6f10a510d63fe027e427"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a98090b59e8ae6f10a510d63fe027e427">exportDiscrepFile</a></td></tr>
<tr class="memdesc:a98090b59e8ae6f10a510d63fe027e427"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify the name of file to which discrepancy calculations are output <br /></td></tr>
<tr class="separator:a98090b59e8ae6f10a510d63fe027e427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb5d9d72c52b352400479aeba10e141"><td class="memItemLeft" align="right" valign="top"><a id="a6eb5d9d72c52b352400479aeba10e141"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6eb5d9d72c52b352400479aeba10e141">exportDiscrepFormat</a></td></tr>
<tr class="memdesc:a6eb5d9d72c52b352400479aeba10e141"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for model discrepancy export file <br /></td></tr>
<tr class="separator:a6eb5d9d72c52b352400479aeba10e141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a30d2e37883d45b7b1768a12f3039c"><td class="memItemLeft" align="right" valign="top"><a id="a77a30d2e37883d45b7b1768a12f3039c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a77a30d2e37883d45b7b1768a12f3039c">adaptExpDesign</a></td></tr>
<tr class="memdesc:a77a30d2e37883d45b7b1768a12f3039c"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to perform adaptive Bayesian design of experiments <br /></td></tr>
<tr class="separator:a77a30d2e37883d45b7b1768a12f3039c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08d555ac16129934e8d9db3dce7a056"><td class="memItemLeft" align="right" valign="top"><a id="ac08d555ac16129934e8d9db3dce7a056"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac08d555ac16129934e8d9db3dce7a056">importCandPtsFile</a></td></tr>
<tr class="memdesc:ac08d555ac16129934e8d9db3dce7a056"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to import candidate design points for adaptive Bayesian experimental design <br /></td></tr>
<tr class="separator:ac08d555ac16129934e8d9db3dce7a056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93281b29986a97af8585681174b000e9"><td class="memItemLeft" align="right" valign="top"><a id="a93281b29986a97af8585681174b000e9"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a93281b29986a97af8585681174b000e9">importCandFormat</a></td></tr>
<tr class="memdesc:a93281b29986a97af8585681174b000e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for the candidate design points import file <br /></td></tr>
<tr class="separator:a93281b29986a97af8585681174b000e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d6ea8170fec592ae75b72caa919c94"><td class="memItemLeft" align="right" valign="top"><a id="a21d6ea8170fec592ae75b72caa919c94"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a21d6ea8170fec592ae75b72caa919c94">numCandidates</a></td></tr>
<tr class="memdesc:a21d6ea8170fec592ae75b72caa919c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of candidate designs for adaptive Bayesian experimental design <br /></td></tr>
<tr class="separator:a21d6ea8170fec592ae75b72caa919c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e2e7a3df753eef21d712b01c0fa9e2"><td class="memItemLeft" align="right" valign="top"><a id="ae6e2e7a3df753eef21d712b01c0fa9e2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae6e2e7a3df753eef21d712b01c0fa9e2">maxHifiEvals</a></td></tr>
<tr class="memdesc:ae6e2e7a3df753eef21d712b01c0fa9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of highfidelity model runs to be used for adaptive Bayesian experimental design <br /></td></tr>
<tr class="separator:ae6e2e7a3df753eef21d712b01c0fa9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1308bf8270beedf52432b840eac4beb"><td class="memItemLeft" align="right" valign="top"><a id="ae1308bf8270beedf52432b840eac4beb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae1308bf8270beedf52432b840eac4beb">batchSize</a></td></tr>
<tr class="memdesc:ae1308bf8270beedf52432b840eac4beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of optimal designs selected per iteration of experimental design algorithm; also number of concurrent GP refinement points for EGO <br /></td></tr>
<tr class="separator:ae1308bf8270beedf52432b840eac4beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3d18b1aed102866f6e6e555e207bed"><td class="memItemLeft" align="right" valign="top"><a id="aba3d18b1aed102866f6e6e555e207bed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aba3d18b1aed102866f6e6e555e207bed">batchSizeExplore</a></td></tr>
<tr class="memdesc:aba3d18b1aed102866f6e6e555e207bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">portion of batchSize earmarked for exploration rather than acquisition <br /></td></tr>
<tr class="separator:aba3d18b1aed102866f6e6e555e207bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8614e80318cae6bfef35375f51f90033"><td class="memItemLeft" align="right" valign="top"><a id="a8614e80318cae6bfef35375f51f90033"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8614e80318cae6bfef35375f51f90033">mutualInfoKSG2</a></td></tr>
<tr class="memdesc:a8614e80318cae6bfef35375f51f90033"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate that the KSG2 algorithm is to be employed in the calculation of the mutual information <br /></td></tr>
<tr class="separator:a8614e80318cae6bfef35375f51f90033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e2cdaa957abe49dbd0ae6e08fa5c33"><td class="memItemLeft" align="right" valign="top"><a id="ae9e2cdaa957abe49dbd0ae6e08fa5c33"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae9e2cdaa957abe49dbd0ae6e08fa5c33">numChains</a></td></tr>
<tr class="memdesc:ae9e2cdaa957abe49dbd0ae6e08fa5c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of concurrent chains <br /></td></tr>
<tr class="separator:ae9e2cdaa957abe49dbd0ae6e08fa5c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b310b70b00890f4e2b244d6ee553b9"><td class="memItemLeft" align="right" valign="top"><a id="a88b310b70b00890f4e2b244d6ee553b9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a88b310b70b00890f4e2b244d6ee553b9">numCR</a></td></tr>
<tr class="memdesc:a88b310b70b00890f4e2b244d6ee553b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of CR-factors <br /></td></tr>
<tr class="separator:a88b310b70b00890f4e2b244d6ee553b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a909b23c76cd038a772944142c447b6"><td class="memItemLeft" align="right" valign="top"><a id="a8a909b23c76cd038a772944142c447b6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8a909b23c76cd038a772944142c447b6">crossoverChainPairs</a></td></tr>
<tr class="memdesc:a8a909b23c76cd038a772944142c447b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of crossover chain pairs <br /></td></tr>
<tr class="separator:a8a909b23c76cd038a772944142c447b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864d3d687f8fa19d501a6360573b8a02"><td class="memItemLeft" align="right" valign="top"><a id="a864d3d687f8fa19d501a6360573b8a02"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a864d3d687f8fa19d501a6360573b8a02">grThreshold</a></td></tr>
<tr class="memdesc:a864d3d687f8fa19d501a6360573b8a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">threshold for the Gelmin-Rubin statistic <br /></td></tr>
<tr class="separator:a864d3d687f8fa19d501a6360573b8a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd576e70eeedd067be48f5d5a9e7477"><td class="memItemLeft" align="right" valign="top"><a id="a7bd576e70eeedd067be48f5d5a9e7477"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7bd576e70eeedd067be48f5d5a9e7477">jumpStep</a></td></tr>
<tr class="memdesc:a7bd576e70eeedd067be48f5d5a9e7477"><td class="mdescLeft">&#160;</td><td class="mdescRight">how often to perform a long jump in generations <br /></td></tr>
<tr class="separator:a7bd576e70eeedd067be48f5d5a9e7477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac903326d71e456798ea0b01912a14688"><td class="memItemLeft" align="right" valign="top"><a id="ac903326d71e456798ea0b01912a14688"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac903326d71e456798ea0b01912a14688">numPushforwardSamples</a></td></tr>
<tr class="memdesc:ac903326d71e456798ea0b01912a14688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of samples from the prior that is pushed forward through the model to obtain the initial set of pushforward samples. <br /></td></tr>
<tr class="separator:ac903326d71e456798ea0b01912a14688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725c8aba2a89d1337a170751de1e9b41"><td class="memItemLeft" align="right" valign="top"><a id="a725c8aba2a89d1337a170751de1e9b41"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a725c8aba2a89d1337a170751de1e9b41">dataDistType</a></td></tr>
<tr class="memdesc:a725c8aba2a89d1337a170751de1e9b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of data distribution: kde, or gaussian <br /></td></tr>
<tr class="separator:a725c8aba2a89d1337a170751de1e9b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa9f42cfce0e2bec8e50762ad38cfe9"><td class="memItemLeft" align="right" valign="top"><a id="a9fa9f42cfce0e2bec8e50762ad38cfe9"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9fa9f42cfce0e2bec8e50762ad38cfe9">dataDistCovInputType</a></td></tr>
<tr class="memdesc:a9fa9f42cfce0e2bec8e50762ad38cfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the format of data distribution gaussian covariance input: diagonal or matrix <br /></td></tr>
<tr class="separator:a9fa9f42cfce0e2bec8e50762ad38cfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf462cfca5c7819320d91bba288751"><td class="memItemLeft" align="right" valign="top"><a id="aacdf462cfca5c7819320d91bba288751"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aacdf462cfca5c7819320d91bba288751">dataDistMeans</a></td></tr>
<tr class="memdesc:aacdf462cfca5c7819320d91bba288751"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw list of real data for the data distribution gaussian means <br /></td></tr>
<tr class="separator:aacdf462cfca5c7819320d91bba288751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289a7179764067999fc8aafbca45c5be"><td class="memItemLeft" align="right" valign="top"><a id="a289a7179764067999fc8aafbca45c5be"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a289a7179764067999fc8aafbca45c5be">dataDistCovariance</a></td></tr>
<tr class="memdesc:a289a7179764067999fc8aafbca45c5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw list of real data for the data distribution gaussian covariance <br /></td></tr>
<tr class="separator:a289a7179764067999fc8aafbca45c5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3201d9a93422d714c76ba2d034ab6280"><td class="memItemLeft" align="right" valign="top"><a id="a3201d9a93422d714c76ba2d034ab6280"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3201d9a93422d714c76ba2d034ab6280">dataDistFile</a></td></tr>
<tr class="memdesc:a3201d9a93422d714c76ba2d034ab6280"><td class="mdescLeft">&#160;</td><td class="mdescRight">file from which to read data distribution data (covariance or samples ) <br /></td></tr>
<tr class="separator:a3201d9a93422d714c76ba2d034ab6280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4a90098ed28bf4988b679acf775052"><td class="memItemLeft" align="right" valign="top"><a id="a5f4a90098ed28bf4988b679acf775052"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5f4a90098ed28bf4988b679acf775052">posteriorDensityExportFilename</a></td></tr>
<tr class="memdesc:a5f4a90098ed28bf4988b679acf775052"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filename of the export file containing an arbitrary set of samples and their corresponding density values. <br /></td></tr>
<tr class="separator:a5f4a90098ed28bf4988b679acf775052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ab95cf67a4ee15ee84933f23dd2ec7"><td class="memItemLeft" align="right" valign="top"><a id="a91ab95cf67a4ee15ee84933f23dd2ec7"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a91ab95cf67a4ee15ee84933f23dd2ec7">posteriorSamplesExportFilename</a></td></tr>
<tr class="memdesc:a91ab95cf67a4ee15ee84933f23dd2ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filename of the export file containing samples from the posterior and their corresponding density values. <br /></td></tr>
<tr class="separator:a91ab95cf67a4ee15ee84933f23dd2ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d1572785a82b2e62c3c2766dffc38e"><td class="memItemLeft" align="right" valign="top"><a id="a59d1572785a82b2e62c3c2766dffc38e"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a59d1572785a82b2e62c3c2766dffc38e">posteriorSamplesImportFilename</a></td></tr>
<tr class="memdesc:a59d1572785a82b2e62c3c2766dffc38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filename of the import file containing samples at which the posterior will be evaluated. <br /></td></tr>
<tr class="separator:a59d1572785a82b2e62c3c2766dffc38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45776b04652cc5e65b699657e47f1678"><td class="memItemLeft" align="right" valign="top"><a id="a45776b04652cc5e65b699657e47f1678"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a45776b04652cc5e65b699657e47f1678">generatePosteriorSamples</a></td></tr>
<tr class="memdesc:a45776b04652cc5e65b699657e47f1678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag specifying whether to generate random samples from the posterior. <br /></td></tr>
<tr class="separator:a45776b04652cc5e65b699657e47f1678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21affda1864aee07bcf2dfeacef449df"><td class="memItemLeft" align="right" valign="top"><a id="a21affda1864aee07bcf2dfeacef449df"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a21affda1864aee07bcf2dfeacef449df">evaluatePosteriorDensity</a></td></tr>
<tr class="memdesc:a21affda1864aee07bcf2dfeacef449df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag specifying whether to evaluate the posterior density at a set of samples. <br /></td></tr>
<tr class="separator:a21affda1864aee07bcf2dfeacef449df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339b86c576153e8135720d335ed1e557"><td class="memItemLeft" align="right" valign="top"><a id="a339b86c576153e8135720d335ed1e557"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a339b86c576153e8135720d335ed1e557">drNumStages</a></td></tr>
<tr class="memdesc:a339b86c576153e8135720d335ed1e557"><td class="mdescLeft">&#160;</td><td class="mdescRight">DR num stages. <br /></td></tr>
<tr class="separator:a339b86c576153e8135720d335ed1e557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932dc82b4dd45971e6e09c760728f33e"><td class="memItemLeft" align="right" valign="top"><a id="a932dc82b4dd45971e6e09c760728f33e"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a932dc82b4dd45971e6e09c760728f33e">drScaleType</a></td></tr>
<tr class="memdesc:a932dc82b4dd45971e6e09c760728f33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DR scale type. <br /></td></tr>
<tr class="separator:a932dc82b4dd45971e6e09c760728f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa708c648e7da896be1b22ac65cd05e70"><td class="memItemLeft" align="right" valign="top"><a id="aa708c648e7da896be1b22ac65cd05e70"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aa708c648e7da896be1b22ac65cd05e70">drScale</a></td></tr>
<tr class="memdesc:aa708c648e7da896be1b22ac65cd05e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">DR scale. <br /></td></tr>
<tr class="separator:aa708c648e7da896be1b22ac65cd05e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0e7e73a6d024178bc1a3601be4e7a8"><td class="memItemLeft" align="right" valign="top"><a id="a9d0e7e73a6d024178bc1a3601be4e7a8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9d0e7e73a6d024178bc1a3601be4e7a8">amPeriodNumSteps</a></td></tr>
<tr class="memdesc:a9d0e7e73a6d024178bc1a3601be4e7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">AM period num steps. <br /></td></tr>
<tr class="separator:a9d0e7e73a6d024178bc1a3601be4e7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af302b9cd636db0371b6ef83808f882ab"><td class="memItemLeft" align="right" valign="top"><a id="af302b9cd636db0371b6ef83808f882ab"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af302b9cd636db0371b6ef83808f882ab">amStartingStep</a></td></tr>
<tr class="memdesc:af302b9cd636db0371b6ef83808f882ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">AM staring step. <br /></td></tr>
<tr class="separator:af302b9cd636db0371b6ef83808f882ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467d03e0fe8eac6ca5a082cd9f3eacaf"><td class="memItemLeft" align="right" valign="top"><a id="a467d03e0fe8eac6ca5a082cd9f3eacaf"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a467d03e0fe8eac6ca5a082cd9f3eacaf">amScale</a></td></tr>
<tr class="memdesc:a467d03e0fe8eac6ca5a082cd9f3eacaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">AM scale. <br /></td></tr>
<tr class="separator:a467d03e0fe8eac6ca5a082cd9f3eacaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537877a30a82ea2c3d3c9de0c0b4ffa2"><td class="memItemLeft" align="right" valign="top"><a id="a537877a30a82ea2c3d3c9de0c0b4ffa2"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a537877a30a82ea2c3d3c9de0c0b4ffa2">malaStepSize</a></td></tr>
<tr class="memdesc:a537877a30a82ea2c3d3c9de0c0b4ffa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">MALA step size. <br /></td></tr>
<tr class="separator:a537877a30a82ea2c3d3c9de0c0b4ffa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cea3b1b549ec9f2a5a5303d86f5d46"><td class="memItemLeft" align="right" valign="top"><a id="a83cea3b1b549ec9f2a5a5303d86f5d46"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a83cea3b1b549ec9f2a5a5303d86f5d46">diliHessianType</a></td></tr>
<tr class="memdesc:a83cea3b1b549ec9f2a5a5303d86f5d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI Hessian type. <br /></td></tr>
<tr class="separator:a83cea3b1b549ec9f2a5a5303d86f5d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac513fb980c9c8dc3ff01476a7ad3426"><td class="memItemLeft" align="right" valign="top"><a id="aac513fb980c9c8dc3ff01476a7ad3426"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aac513fb980c9c8dc3ff01476a7ad3426">diliAdaptInterval</a></td></tr>
<tr class="memdesc:aac513fb980c9c8dc3ff01476a7ad3426"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI adaptation interval. <br /></td></tr>
<tr class="separator:aac513fb980c9c8dc3ff01476a7ad3426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b14925c44c2fd5406caa17fc77db79"><td class="memItemLeft" align="right" valign="top"><a id="a20b14925c44c2fd5406caa17fc77db79"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a20b14925c44c2fd5406caa17fc77db79">diliAdaptStart</a></td></tr>
<tr class="memdesc:a20b14925c44c2fd5406caa17fc77db79"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI adaptation start. <br /></td></tr>
<tr class="separator:a20b14925c44c2fd5406caa17fc77db79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814be06972c57e841b900f9f36582a19"><td class="memItemLeft" align="right" valign="top"><a id="a814be06972c57e841b900f9f36582a19"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a814be06972c57e841b900f9f36582a19">diliAdaptEnd</a></td></tr>
<tr class="memdesc:a814be06972c57e841b900f9f36582a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI adaptation end. <br /></td></tr>
<tr class="separator:a814be06972c57e841b900f9f36582a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1c72bb74b1e248168773c145d97b96"><td class="memItemLeft" align="right" valign="top"><a id="a7c1c72bb74b1e248168773c145d97b96"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a7c1c72bb74b1e248168773c145d97b96">diliInitialWeight</a></td></tr>
<tr class="memdesc:a7c1c72bb74b1e248168773c145d97b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI initial weight. <br /></td></tr>
<tr class="separator:a7c1c72bb74b1e248168773c145d97b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600c998cbc6162d366cd23b5cc62418e"><td class="memItemLeft" align="right" valign="top"><a id="a600c998cbc6162d366cd23b5cc62418e"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a600c998cbc6162d366cd23b5cc62418e">diliHessTolerance</a></td></tr>
<tr class="memdesc:a600c998cbc6162d366cd23b5cc62418e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI Hessian tolerance. <br /></td></tr>
<tr class="separator:a600c998cbc6162d366cd23b5cc62418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2c335f1a7542bd851a00e5f8c40c21"><td class="memItemLeft" align="right" valign="top"><a id="a2a2c335f1a7542bd851a00e5f8c40c21"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2a2c335f1a7542bd851a00e5f8c40c21">diliLISTolerance</a></td></tr>
<tr class="memdesc:a2a2c335f1a7542bd851a00e5f8c40c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI LIS tolerance. <br /></td></tr>
<tr class="separator:a2a2c335f1a7542bd851a00e5f8c40c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecdec797596efb1e4032185d4c08683"><td class="memItemLeft" align="right" valign="top"><a id="adecdec797596efb1e4032185d4c08683"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#adecdec797596efb1e4032185d4c08683">diliSesNumEigs</a></td></tr>
<tr class="memdesc:adecdec797596efb1e4032185d4c08683"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI stochastic eigensolver maximum number of eigenvalues to compute. <br /></td></tr>
<tr class="separator:adecdec797596efb1e4032185d4c08683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab856e713d18cba1f4183be5758b6e837"><td class="memItemLeft" align="right" valign="top"><a id="ab856e713d18cba1f4183be5758b6e837"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab856e713d18cba1f4183be5758b6e837">diliSesRelTol</a></td></tr>
<tr class="memdesc:ab856e713d18cba1f4183be5758b6e837"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI stochastic eigensolver relative tolerance. <br /></td></tr>
<tr class="separator:ab856e713d18cba1f4183be5758b6e837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97408f688ba26a0eb25ae6f7f6fc870"><td class="memItemLeft" align="right" valign="top"><a id="ae97408f688ba26a0eb25ae6f7f6fc870"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae97408f688ba26a0eb25ae6f7f6fc870">diliSesAbsTol</a></td></tr>
<tr class="memdesc:ae97408f688ba26a0eb25ae6f7f6fc870"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI stochastic eigensolver absolute tolerance. <br /></td></tr>
<tr class="separator:ae97408f688ba26a0eb25ae6f7f6fc870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4feb0d1185fb692529bbe30fa6f295"><td class="memItemLeft" align="right" valign="top"><a id="a4f4feb0d1185fb692529bbe30fa6f295"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4f4feb0d1185fb692529bbe30fa6f295">diliSesExpRank</a></td></tr>
<tr class="memdesc:a4f4feb0d1185fb692529bbe30fa6f295"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI stochastic eigensolver expected number of eigenvalues that are larger than the tolerances. <br /></td></tr>
<tr class="separator:a4f4feb0d1185fb692529bbe30fa6f295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dcf3ce9de36473a8608ddcf64b1ac1"><td class="memItemLeft" align="right" valign="top"><a id="ac8dcf3ce9de36473a8608ddcf64b1ac1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ac8dcf3ce9de36473a8608ddcf64b1ac1">diliSesOversFactor</a></td></tr>
<tr class="memdesc:ac8dcf3ce9de36473a8608ddcf64b1ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI stochastic eigensolver oversampling factor. <br /></td></tr>
<tr class="separator:ac8dcf3ce9de36473a8608ddcf64b1ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6748f04f3c915e61cb9b0d8c81632fa5"><td class="memItemLeft" align="right" valign="top"><a id="a6748f04f3c915e61cb9b0d8c81632fa5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6748f04f3c915e61cb9b0d8c81632fa5">diliSesBlockSize</a></td></tr>
<tr class="memdesc:a6748f04f3c915e61cb9b0d8c81632fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">DILI stochastic eigensolver block size. <br /></td></tr>
<tr class="separator:a6748f04f3c915e61cb9b0d8c81632fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad979351a19da6e713517117db0d4b616"><td class="memItemLeft" align="right" valign="top"><a id="ad979351a19da6e713517117db0d4b616"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ad979351a19da6e713517117db0d4b616">mlmcmcInitialChainSamples</a></td></tr>
<tr class="memdesc:ad979351a19da6e713517117db0d4b616"><td class="mdescLeft">&#160;</td><td class="mdescRight">MLMCMC Number of initial samples. <br /></td></tr>
<tr class="separator:ad979351a19da6e713517117db0d4b616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d128649c717378c9c5736c19e5399b"><td class="memItemLeft" align="right" valign="top"><a id="a52d128649c717378c9c5736c19e5399b"></a>
IntVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a52d128649c717378c9c5736c19e5399b">mlmcmcSubsamplingSteps</a></td></tr>
<tr class="memdesc:a52d128649c717378c9c5736c19e5399b"><td class="mdescLeft">&#160;</td><td class="mdescRight">MLMCMC Estimator variance for the greedy algorithm. <br /></td></tr>
<tr class="separator:a52d128649c717378c9c5736c19e5399b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b15d4be88c1e5e4a373f37a3aef0c85"><td class="memItemLeft" align="right" valign="top"><a id="a3b15d4be88c1e5e4a373f37a3aef0c85"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3b15d4be88c1e5e4a373f37a3aef0c85">mlmcmcTargetVariance</a></td></tr>
<tr class="memdesc:a3b15d4be88c1e5e4a373f37a3aef0c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">MLMCMC Subsampling steps. <br /></td></tr>
<tr class="separator:a3b15d4be88c1e5e4a373f37a3aef0c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282f4ad70b94c1ea95e774bccf6c3ce6"><td class="memItemLeft" align="right" valign="top"><a id="a282f4ad70b94c1ea95e774bccf6c3ce6"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a282f4ad70b94c1ea95e774bccf6c3ce6">mlmcmcGreedyResamplingFactor</a></td></tr>
<tr class="memdesc:a282f4ad70b94c1ea95e774bccf6c3ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">MLMCMC Greedy Resampling Factor. <br /></td></tr>
<tr class="separator:a282f4ad70b94c1ea95e774bccf6c3ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1810a7ed1223c9a12260302750effa57"><td class="memItemLeft" align="right" valign="top"><a id="a1810a7ed1223c9a12260302750effa57"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1810a7ed1223c9a12260302750effa57">finalPoint</a></td></tr>
<tr class="memdesc:a1810a7ed1223c9a12260302750effa57"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>final_point</code> specification in MethodPSVPS <br /></td></tr>
<tr class="separator:a1810a7ed1223c9a12260302750effa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9c2f3053afc2d8865f3b05bcf83068"><td class="memItemLeft" align="right" valign="top"><a id="a5f9c2f3053afc2d8865f3b05bcf83068"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a5f9c2f3053afc2d8865f3b05bcf83068">stepVector</a></td></tr>
<tr class="memdesc:a5f9c2f3053afc2d8865f3b05bcf83068"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>step_vector</code> specification in MethodPSVPS and MethodPSCPS <br /></td></tr>
<tr class="separator:a5f9c2f3053afc2d8865f3b05bcf83068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaa75f9bf3f960f493f709068678132"><td class="memItemLeft" align="right" valign="top"><a id="aacaa75f9bf3f960f493f709068678132"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aacaa75f9bf3f960f493f709068678132">numSteps</a></td></tr>
<tr class="memdesc:aacaa75f9bf3f960f493f709068678132"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>num_steps</code> specification in MethodPSVPS <br /></td></tr>
<tr class="separator:aacaa75f9bf3f960f493f709068678132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1701ab6c387514ea086f5c5ad312a237"><td class="memItemLeft" align="right" valign="top"><a id="a1701ab6c387514ea086f5c5ad312a237"></a>
IntVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a1701ab6c387514ea086f5c5ad312a237">stepsPerVariable</a></td></tr>
<tr class="memdesc:a1701ab6c387514ea086f5c5ad312a237"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>deltas_per_variable</code> specification in MethodPSCPS <br /></td></tr>
<tr class="separator:a1701ab6c387514ea086f5c5ad312a237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b03e42b6b7868dd01d5f768943f932f"><td class="memItemLeft" align="right" valign="top"><a id="a4b03e42b6b7868dd01d5f768943f932f"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4b03e42b6b7868dd01d5f768943f932f">listOfPoints</a></td></tr>
<tr class="memdesc:a4b03e42b6b7868dd01d5f768943f932f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>list_of_points</code> specification in MethodPSLPS <br /></td></tr>
<tr class="separator:a4b03e42b6b7868dd01d5f768943f932f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a14b69b601251540ab133f2581543b5"><td class="memItemLeft" align="right" valign="top"><a id="a8a14b69b601251540ab133f2581543b5"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8a14b69b601251540ab133f2581543b5">pstudyFilename</a></td></tr>
<tr class="memdesc:a8a14b69b601251540ab133f2581543b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>import_points_file</code> spec for a file-based parameter study <br /></td></tr>
<tr class="separator:a8a14b69b601251540ab133f2581543b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31c4a93514435ca0e15146d068e4a1a"><td class="memItemLeft" align="right" valign="top"><a id="ae31c4a93514435ca0e15146d068e4a1a"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae31c4a93514435ca0e15146d068e4a1a">pstudyFileFormat</a></td></tr>
<tr class="memdesc:ae31c4a93514435ca0e15146d068e4a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for the parameter study points file <br /></td></tr>
<tr class="separator:ae31c4a93514435ca0e15146d068e4a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad24846d51644bf9a1feddabe5ac614"><td class="memItemLeft" align="right" valign="top"><a id="a3ad24846d51644bf9a1feddabe5ac614"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a3ad24846d51644bf9a1feddabe5ac614">pstudyFileActive</a></td></tr>
<tr class="memdesc:a3ad24846d51644bf9a1feddabe5ac614"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to import active variables only <br /></td></tr>
<tr class="separator:a3ad24846d51644bf9a1feddabe5ac614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf63d4e82777ef9817ce23d04bdb181"><td class="memItemLeft" align="right" valign="top"><a id="adbf63d4e82777ef9817ce23d04bdb181"></a>
UShortArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#adbf63d4e82777ef9817ce23d04bdb181">varPartitions</a></td></tr>
<tr class="memdesc:adbf63d4e82777ef9817ce23d04bdb181"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code>partitions</code> specification for PStudy method in MethodPSMPS <br /></td></tr>
<tr class="separator:adbf63d4e82777ef9817ce23d04bdb181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a51e28da90fbc555160cfee072b7b9"><td class="memItemLeft" align="right" valign="top"><a id="af2a51e28da90fbc555160cfee072b7b9"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af2a51e28da90fbc555160cfee072b7b9">refinementRate</a></td></tr>
<tr class="memdesc:af2a51e28da90fbc555160cfee072b7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">rate of mesh refinement in Richardson extrapolation <br /></td></tr>
<tr class="separator:af2a51e28da90fbc555160cfee072b7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae92527a35fbfb1b6a61ed7e660d377"><td class="memItemLeft" align="right" valign="top"><a id="a9ae92527a35fbfb1b6a61ed7e660d377"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a9ae92527a35fbfb1b6a61ed7e660d377">importBuildPtsFile</a></td></tr>
<tr class="memdesc:a9ae92527a35fbfb1b6a61ed7e660d377"><td class="mdescLeft">&#160;</td><td class="mdescRight">the file name from the <code>import_build_points_file</code> specification <br /></td></tr>
<tr class="separator:a9ae92527a35fbfb1b6a61ed7e660d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6acedddd27754cccf65f03c2ddfb7b"><td class="memItemLeft" align="right" valign="top"><a id="a6f6acedddd27754cccf65f03c2ddfb7b"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6f6acedddd27754cccf65f03c2ddfb7b">importBuildFormat</a></td></tr>
<tr class="memdesc:a6f6acedddd27754cccf65f03c2ddfb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for the build point import file <br /></td></tr>
<tr class="separator:a6f6acedddd27754cccf65f03c2ddfb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8238e61a38855a8b032b1199b526823a"><td class="memItemLeft" align="right" valign="top"><a id="a8238e61a38855a8b032b1199b526823a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a8238e61a38855a8b032b1199b526823a">importBuildActive</a></td></tr>
<tr class="memdesc:a8238e61a38855a8b032b1199b526823a"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to import active variables only <br /></td></tr>
<tr class="separator:a8238e61a38855a8b032b1199b526823a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51501d0a0c66d710ae834dc7f0f50dd"><td class="memItemLeft" align="right" valign="top"><a id="ae51501d0a0c66d710ae834dc7f0f50dd"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ae51501d0a0c66d710ae834dc7f0f50dd">importApproxPtsFile</a></td></tr>
<tr class="memdesc:ae51501d0a0c66d710ae834dc7f0f50dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">the file name from the <code>import_approx_points_file</code> specification <br /></td></tr>
<tr class="separator:ae51501d0a0c66d710ae834dc7f0f50dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d6ae63ff2d0d499e5cd06a0d492dfa"><td class="memItemLeft" align="right" valign="top"><a id="a31d6ae63ff2d0d499e5cd06a0d492dfa"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a31d6ae63ff2d0d499e5cd06a0d492dfa">importApproxFormat</a></td></tr>
<tr class="memdesc:a31d6ae63ff2d0d499e5cd06a0d492dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for the approx point import file <br /></td></tr>
<tr class="separator:a31d6ae63ff2d0d499e5cd06a0d492dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635f31bb22b9b537b767033d0fe55052"><td class="memItemLeft" align="right" valign="top"><a id="a635f31bb22b9b537b767033d0fe55052"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a635f31bb22b9b537b767033d0fe55052">importApproxActive</a></td></tr>
<tr class="memdesc:a635f31bb22b9b537b767033d0fe55052"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to import active variables only <br /></td></tr>
<tr class="separator:a635f31bb22b9b537b767033d0fe55052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d555b8347e8364edfb2b4b012ac0c87"><td class="memItemLeft" align="right" valign="top"><a id="a4d555b8347e8364edfb2b4b012ac0c87"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4d555b8347e8364edfb2b4b012ac0c87">exportApproxPtsFile</a></td></tr>
<tr class="memdesc:a4d555b8347e8364edfb2b4b012ac0c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">the file name from the <code>export_approx_points_file</code> specification <br /></td></tr>
<tr class="separator:a4d555b8347e8364edfb2b4b012ac0c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c69de707a19145d2a352ffcfd83b657"><td class="memItemLeft" align="right" valign="top"><a id="a6c69de707a19145d2a352ffcfd83b657"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6c69de707a19145d2a352ffcfd83b657">exportApproxFormat</a></td></tr>
<tr class="memdesc:a6c69de707a19145d2a352ffcfd83b657"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for the approx point export file <br /></td></tr>
<tr class="separator:a6c69de707a19145d2a352ffcfd83b657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e83d5c414a5ed2225b74d785668e17d"><td class="memItemLeft" align="right" valign="top"><a id="a4e83d5c414a5ed2225b74d785668e17d"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a4e83d5c414a5ed2225b74d785668e17d">exportMCMCPtsFile</a></td></tr>
<tr class="memdesc:a4e83d5c414a5ed2225b74d785668e17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the file name from the <code>export_mcmc_points_file</code> specification <br /></td></tr>
<tr class="separator:a4e83d5c414a5ed2225b74d785668e17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428804ed08d0dc9efe970cf0a4b7c86f"><td class="memItemLeft" align="right" valign="top"><a id="a428804ed08d0dc9efe970cf0a4b7c86f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a428804ed08d0dc9efe970cf0a4b7c86f">exportSampleSeqFlag</a></td></tr>
<tr class="memdesc:a428804ed08d0dc9efe970cf0a4b7c86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for exporting the sequence of sample increments within multilevel sampling from the <code>export_sample_sequence</code> specification <br /></td></tr>
<tr class="separator:a428804ed08d0dc9efe970cf0a4b7c86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31073b74e8a2ce613e37eb023c833ba5"><td class="memItemLeft" align="right" valign="top"><a id="a31073b74e8a2ce613e37eb023c833ba5"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a31073b74e8a2ce613e37eb023c833ba5">exportSamplesFormat</a></td></tr>
<tr class="memdesc:a31073b74e8a2ce613e37eb023c833ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">tabular format for the MCMC chain and MLMC sample sequence exports <br /></td></tr>
<tr class="separator:a31073b74e8a2ce613e37eb023c833ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8650f4b069c5429ff675b25a8aa8f9"><td class="memItemLeft" align="right" valign="top"><a id="aac8650f4b069c5429ff675b25a8aa8f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#aac8650f4b069c5429ff675b25a8aa8f9">exportSurrogate</a></td></tr>
<tr class="memdesc:aac8650f4b069c5429ff675b25a8aa8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to turn on surrogate model export (export_model) <br /></td></tr>
<tr class="separator:aac8650f4b069c5429ff675b25a8aa8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3252533c597603a3975ebfc3095b37c"><td class="memItemLeft" align="right" valign="top"><a id="ab3252533c597603a3975ebfc3095b37c"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab3252533c597603a3975ebfc3095b37c">modelExportPrefix</a></td></tr>
<tr class="memdesc:ab3252533c597603a3975ebfc3095b37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the filename prefix for export_model <br /></td></tr>
<tr class="separator:ab3252533c597603a3975ebfc3095b37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23b1a1fe2943ffe35dea39acddcad48"><td class="memItemLeft" align="right" valign="top"><a id="af23b1a1fe2943ffe35dea39acddcad48"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#af23b1a1fe2943ffe35dea39acddcad48">modelExportFormat</a></td></tr>
<tr class="memdesc:af23b1a1fe2943ffe35dea39acddcad48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format selection for export_model. <br /></td></tr>
<tr class="separator:af23b1a1fe2943ffe35dea39acddcad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0a1047f11e2785887c41450eb3a7ca7c"><td class="memItemLeft" align="right" valign="top"><a id="a0a1047f11e2785887c41450eb3a7ca7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0a1047f11e2785887c41450eb3a7ca7c">DataMethodRep</a> ()</td></tr>
<tr class="memdesc:a0a1047f11e2785887c41450eb3a7ca7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor <br /></td></tr>
<tr class="separator:a0a1047f11e2785887c41450eb3a7ca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e460df6d4678b93ed44e0552a259404"><td class="memItemLeft" align="right" valign="top"><a id="a6e460df6d4678b93ed44e0552a259404"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a6e460df6d4678b93ed44e0552a259404">write</a> (std::ostream &amp;s) const</td></tr>
<tr class="memdesc:a6e460df6d4678b93ed44e0552a259404"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a DataInterfaceRep object to an std::ostream <br /></td></tr>
<tr class="separator:a6e460df6d4678b93ed44e0552a259404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2967d719f50f43ca99b854be968b8687"><td class="memItemLeft" align="right" valign="top"><a id="a2967d719f50f43ca99b854be968b8687"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a2967d719f50f43ca99b854be968b8687">read</a> (<a class="el" href="classDakota_1_1MPIUnpackBuffer.html">MPIUnpackBuffer</a> &amp;s)</td></tr>
<tr class="memdesc:a2967d719f50f43ca99b854be968b8687"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a DataInterfaceRep object from a packed MPI buffer <br /></td></tr>
<tr class="separator:a2967d719f50f43ca99b854be968b8687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caf1f977529e7d415f2c8e74752ed8e"><td class="memItemLeft" align="right" valign="top"><a id="a0caf1f977529e7d415f2c8e74752ed8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#a0caf1f977529e7d415f2c8e74752ed8e">write</a> (<a class="el" href="classDakota_1_1MPIPackBuffer.html">MPIPackBuffer</a> &amp;s) const</td></tr>
<tr class="memdesc:a0caf1f977529e7d415f2c8e74752ed8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a DataInterfaceRep object to a packed MPI buffer <br /></td></tr>
<tr class="separator:a0caf1f977529e7d415f2c8e74752ed8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab2bc42d4b7246b5a9ff34f585688ce51"><td class="memItemLeft" align="right" valign="top"><a id="ab2bc42d4b7246b5a9ff34f585688ce51"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1DataMethodRep.html#ab2bc42d4b7246b5a9ff34f585688ce51">DataMethod</a></td></tr>
<tr class="memdesc:ab2bc42d4b7246b5a9ff34f585688ce51"><td class="mdescLeft">&#160;</td><td class="mdescRight">the handle class can access attributes of the body class directly <br /></td></tr>
<tr class="separator:ab2bc42d4b7246b5a9ff34f585688ce51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Body class for method specification data. </p>
<p>The <a class="el" href="classDakota_1_1DataMethodRep.html" title="Body class for method specification data.">DataMethodRep</a> class is used to contain the data from a method keyword specification. Default values are managed in the <a class="el" href="classDakota_1_1DataMethodRep.html" title="Body class for method specification data.">DataMethodRep</a> constructor. Data is public to avoid maintaining set/get functions, but is still encapsulated within <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> since <a class="el" href="classDakota_1_1ProblemDescDB.html#add43584a6533c7e67c2d6918012fb295" title="list of method specifications, one for each call to method_kwhandler() or insert_node()">ProblemDescDB::dataMethodList</a> is private. </p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li>DataMethod.hpp</li>
<li>DataMethod.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
