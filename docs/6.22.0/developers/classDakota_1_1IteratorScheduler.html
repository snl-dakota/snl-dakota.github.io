<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Dakota Developers Manual" />
<meta name="keywords" content="optimization, uncertainty quantification, model calibration, parameter estimation, sensitivity analysis, parallel computing, developers manual" />
<meta name="sandia.approval_type" content="formal" />
<meta name="sandia.approved" content="2010-2185" />
<link rev="owns" title="Brian M. Adams" href="mailto:briadam@sandia.gov" />
<meta name="Author" content="Brian M. Adams" />
<title>Dakota: IteratorScheduler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DAKOTA_Arrow_Name_77x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dakota
   &#160;<span id="projectnumber">Version 6.22</span>
   </div>
   <div id="projectbrief">Explore and Predict with Confidence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDakota.html">Dakota</a></li><li class="navelem"><a class="el" href="classDakota_1_1IteratorScheduler.html">IteratorScheduler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDakota_1_1IteratorScheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IteratorScheduler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class encapsulates scheduling operations for concurrent sub-iteration within an outer level context (e.g., meta-iteration, nested models).  
 <a href="classDakota_1_1IteratorScheduler.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39681e89c46a901f96a058218e64940a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a39681e89c46a901f96a058218e64940a">IteratorScheduler</a> (<a class="el" href="classDakota_1_1ParallelLibrary.html">ParallelLibrary</a> &amp;parallel_lib, bool peer_assign_jobs, int num_servers=0, int procs_per_iterator=0, short scheduling=DEFAULT_SCHEDULING)</td></tr>
<tr class="memdesc:a39681e89c46a901f96a058218e64940a"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="classDakota_1_1IteratorScheduler.html#a39681e89c46a901f96a058218e64940a">More...</a><br /></td></tr>
<tr class="separator:a39681e89c46a901f96a058218e64940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a97b29599eac31d56fed5ad0eda3437"><td class="memItemLeft" align="right" valign="top"><a id="a0a97b29599eac31d56fed5ad0eda3437"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a0a97b29599eac31d56fed5ad0eda3437">~IteratorScheduler</a> ()</td></tr>
<tr class="memdesc:a0a97b29599eac31d56fed5ad0eda3437"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a0a97b29599eac31d56fed5ad0eda3437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ed5b6b67386584b99689484ea98568"><td class="memItemLeft" align="right" valign="top"><a id="a58ed5b6b67386584b99689484ea98568"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a58ed5b6b67386584b99689484ea98568">construct_sub_iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;sub_iterator, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt; sub_model, const String &amp;method_ptr, const String &amp;method_name, const String &amp;model_ptr)</td></tr>
<tr class="memdesc:a58ed5b6b67386584b99689484ea98568"><td class="mdescLeft">&#160;</td><td class="mdescRight">instantiate sub_iterator on the current rank if not already constructed <br /></td></tr>
<tr class="separator:a58ed5b6b67386584b99689484ea98568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5829c452ebf44b9231e8e91b6c37e6"><td class="memItemLeft" align="right" valign="top">IntIntPair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#acf5829c452ebf44b9231e8e91b6c37e6">configure</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;sub_iterator, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt; sub_model)</td></tr>
<tr class="memdesc:acf5829c452ebf44b9231e8e91b6c37e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs sufficient initialization to define partitioning controls (min and max processors per iterator server)  <a href="classDakota_1_1IteratorScheduler.html#acf5829c452ebf44b9231e8e91b6c37e6">More...</a><br /></td></tr>
<tr class="separator:acf5829c452ebf44b9231e8e91b6c37e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb91c628ae3ca224432415ca687943"><td class="memItemLeft" align="right" valign="top">IntIntPair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#acaeb91c628ae3ca224432415ca687943">configure</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, const String &amp;method_string, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;sub_iterator, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt; sub_model)</td></tr>
<tr class="memdesc:acaeb91c628ae3ca224432415ca687943"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs sufficient initialization to define partitioning controls (min and max processors per iterator server)  <a href="classDakota_1_1IteratorScheduler.html#acaeb91c628ae3ca224432415ca687943">More...</a><br /></td></tr>
<tr class="separator:acaeb91c628ae3ca224432415ca687943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cc1bd28f90e68687c571e92ff9cda5"><td class="memItemLeft" align="right" valign="top">IntIntPair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a06cc1bd28f90e68687c571e92ff9cda5">configure</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;sub_iterator)</td></tr>
<tr class="memdesc:a06cc1bd28f90e68687c571e92ff9cda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs sufficient initialization to define partitioning controls (min and max processors per iterator server)  <a href="classDakota_1_1IteratorScheduler.html#a06cc1bd28f90e68687c571e92ff9cda5">More...</a><br /></td></tr>
<tr class="separator:a06cc1bd28f90e68687c571e92ff9cda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03445df3298900088e70328ffbd4e6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ab03445df3298900088e70328ffbd4e6a">partition</a> (int max_iterator_concurrency, IntIntPair &amp;ppi_pr)</td></tr>
<tr class="memdesc:ab03445df3298900088e70328ffbd4e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for initializing iterator communicators, setting parallel configuration attributes, and managing outputs and restart.  <a href="classDakota_1_1IteratorScheduler.html#ab03445df3298900088e70328ffbd4e6a">More...</a><br /></td></tr>
<tr class="separator:ab03445df3298900088e70328ffbd4e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79bdb9dd61e3064c2eecd343247cc93"><td class="memItemLeft" align="right" valign="top"><a id="ad79bdb9dd61e3064c2eecd343247cc93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ad79bdb9dd61e3064c2eecd343247cc93">init_iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;sub_iterator, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt; sub_model)</td></tr>
<tr class="memdesc:ad79bdb9dd61e3064c2eecd343247cc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">invokes static version of this function with appropriate parallelism level <br /></td></tr>
<tr class="separator:ad79bdb9dd61e3064c2eecd343247cc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba9e455ffb9aab27ce97817963a24b8"><td class="memItemLeft" align="right" valign="top"><a id="a8ba9e455ffb9aab27ce97817963a24b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a8ba9e455ffb9aab27ce97817963a24b8">init_iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, const String &amp;method_string, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;sub_iterator, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt; sub_model)</td></tr>
<tr class="memdesc:a8ba9e455ffb9aab27ce97817963a24b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">invokes static version of this function with appropriate parallelism level <br /></td></tr>
<tr class="separator:a8ba9e455ffb9aab27ce97817963a24b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54803857231ddd06485af3612e48bf7"><td class="memItemLeft" align="right" valign="top"><a id="ae54803857231ddd06485af3612e48bf7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ae54803857231ddd06485af3612e48bf7">set_iterator</a> (<a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;sub_iterator)</td></tr>
<tr class="memdesc:ae54803857231ddd06485af3612e48bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">invokes static version of this function with appropriate parallelism level <br /></td></tr>
<tr class="separator:ae54803857231ddd06485af3612e48bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80084d7d99894057d8de61a1bc46ae96"><td class="memItemLeft" align="right" valign="top"><a id="a80084d7d99894057d8de61a1bc46ae96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a80084d7d99894057d8de61a1bc46ae96">run_iterator</a> (<a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;sub_iterator)</td></tr>
<tr class="memdesc:a80084d7d99894057d8de61a1bc46ae96"><td class="mdescLeft">&#160;</td><td class="mdescRight">invokes static version of this function with appropriate parallelism level <br /></td></tr>
<tr class="separator:a80084d7d99894057d8de61a1bc46ae96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6763b7f8acdd4b3277a51221262f8dbc"><td class="memItemLeft" align="right" valign="top"><a id="a6763b7f8acdd4b3277a51221262f8dbc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a6763b7f8acdd4b3277a51221262f8dbc">free_iterator</a> (<a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;sub_iterator)</td></tr>
<tr class="memdesc:a6763b7f8acdd4b3277a51221262f8dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">invokes static version of this function with appropriate parallelism level <br /></td></tr>
<tr class="separator:a6763b7f8acdd4b3277a51221262f8dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af83e96e40811ecfa40eb2c7844a6e"><td class="memItemLeft" align="right" valign="top"><a id="a23af83e96e40811ecfa40eb2c7844a6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a23af83e96e40811ecfa40eb2c7844a6e">free_iterator_parallelism</a> ()</td></tr>
<tr class="memdesc:a23af83e96e40811ecfa40eb2c7844a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for deallocating the concurrent iterator parallelism level <br /></td></tr>
<tr class="separator:a23af83e96e40811ecfa40eb2c7844a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4fc096237fec333bb036b44dee6e02"><td class="memTemplParams" colspan="2">template&lt;typename MetaType &gt; </td></tr>
<tr class="memitem:a3b4fc096237fec333bb036b44dee6e02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a3b4fc096237fec333bb036b44dee6e02">schedule_iterators</a> (MetaType &amp;meta_object, <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;sub_iterator)</td></tr>
<tr class="memdesc:a3b4fc096237fec333bb036b44dee6e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">short convenience function for distributing control among <a class="el" href="classDakota_1_1IteratorScheduler.html#a51455680837e78349909b2ecc353be14" title="executed by the dedicated scheduler to manage a dynamic schedule of iterator jobs among iterator serv...">dedicated_dynamic_scheduler_iterators()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ad5424d037c6b68eb0068ade39540701f" title="executed on the iterator servers to perform iterator jobs assigned by the dedicated scheduler">serve_iterators()</a>, and <a class="el" href="classDakota_1_1IteratorScheduler.html#a3923cc1379f3fbc5a15234e4357daafd" title="executed on iterator peers to manage a static schedule of iterator jobs">peer_static_schedule_iterators()</a>  <a href="classDakota_1_1IteratorScheduler.html#a3b4fc096237fec333bb036b44dee6e02">More...</a><br /></td></tr>
<tr class="separator:a3b4fc096237fec333bb036b44dee6e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51455680837e78349909b2ecc353be14"><td class="memTemplParams" colspan="2">template&lt;typename MetaType &gt; </td></tr>
<tr class="memitem:a51455680837e78349909b2ecc353be14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a51455680837e78349909b2ecc353be14">dedicated_dynamic_scheduler_iterators</a> (MetaType &amp;meta_object)</td></tr>
<tr class="memdesc:a51455680837e78349909b2ecc353be14"><td class="mdescLeft">&#160;</td><td class="mdescRight">executed by the dedicated scheduler to manage a dynamic schedule of iterator jobs among iterator servers  <a href="classDakota_1_1IteratorScheduler.html#a51455680837e78349909b2ecc353be14">More...</a><br /></td></tr>
<tr class="separator:a51455680837e78349909b2ecc353be14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014b4ab207bdeb86b98455ec3e2c4cde"><td class="memItemLeft" align="right" valign="top"><a id="a014b4ab207bdeb86b98455ec3e2c4cde"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a014b4ab207bdeb86b98455ec3e2c4cde">stop_iterator_servers</a> ()</td></tr>
<tr class="memdesc:a014b4ab207bdeb86b98455ec3e2c4cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">executed by the dedicated scheduler to terminate iterator servers <br /></td></tr>
<tr class="separator:a014b4ab207bdeb86b98455ec3e2c4cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5424d037c6b68eb0068ade39540701f"><td class="memTemplParams" colspan="2">template&lt;typename MetaType &gt; </td></tr>
<tr class="memitem:ad5424d037c6b68eb0068ade39540701f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ad5424d037c6b68eb0068ade39540701f">serve_iterators</a> (MetaType &amp;meta_object, <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;sub_iterator)</td></tr>
<tr class="memdesc:ad5424d037c6b68eb0068ade39540701f"><td class="mdescLeft">&#160;</td><td class="mdescRight">executed on the iterator servers to perform iterator jobs assigned by the dedicated scheduler  <a href="classDakota_1_1IteratorScheduler.html#ad5424d037c6b68eb0068ade39540701f">More...</a><br /></td></tr>
<tr class="separator:ad5424d037c6b68eb0068ade39540701f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3923cc1379f3fbc5a15234e4357daafd"><td class="memTemplParams" colspan="2"><a id="a3923cc1379f3fbc5a15234e4357daafd"></a>
template&lt;typename MetaType &gt; </td></tr>
<tr class="memitem:a3923cc1379f3fbc5a15234e4357daafd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a3923cc1379f3fbc5a15234e4357daafd">peer_static_schedule_iterators</a> (MetaType &amp;meta_object, <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;sub_iterator)</td></tr>
<tr class="memdesc:a3923cc1379f3fbc5a15234e4357daafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">executed on iterator peers to manage a static schedule of iterator jobs <br /></td></tr>
<tr class="separator:a3923cc1379f3fbc5a15234e4357daafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a72bc79a35c5a3f92c148d8ad35ab6"><td class="memItemLeft" align="right" valign="top"><a id="ae7a72bc79a35c5a3f92c148d8ad35ab6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ae7a72bc79a35c5a3f92c148d8ad35ab6">update</a> (ParConfigLIter pc_iter)</td></tr>
<tr class="memdesc:ae7a72bc79a35c5a3f92c148d8ad35ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">update schedPCIter <br /></td></tr>
<tr class="separator:ae7a72bc79a35c5a3f92c148d8ad35ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4382357baeeaad5c720368cea68224d9"><td class="memItemLeft" align="right" valign="top"><a id="a4382357baeeaad5c720368cea68224d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a4382357baeeaad5c720368cea68224d9">update</a> (size_t index)</td></tr>
<tr class="memdesc:a4382357baeeaad5c720368cea68224d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">update miPLIndex as well as associated settings for concurrent iterator scheduling from the corresponding <a class="el" href="classDakota_1_1ParallelLevel.html" title="Container class for the data associated with a single level of communicator partitioning.">ParallelLevel</a> <br /></td></tr>
<tr class="separator:a4382357baeeaad5c720368cea68224d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae823003a7758ef937f4f05a532871f0e"><td class="memItemLeft" align="right" valign="top"><a id="ae823003a7758ef937f4f05a532871f0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ae823003a7758ef937f4f05a532871f0e">update</a> (ParConfigLIter pc_iter, size_t index)</td></tr>
<tr class="memdesc:ae823003a7758ef937f4f05a532871f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke <a class="el" href="classDakota_1_1IteratorScheduler.html#ae7a72bc79a35c5a3f92c148d8ad35ab6" title="update schedPCIter">update(ParConfigLIter)</a> and <a class="el" href="classDakota_1_1IteratorScheduler.html#a4382357baeeaad5c720368cea68224d9" title="update miPLIndex as well as associated settings for concurrent iterator scheduling from the correspon...">update(size_t)</a> in sequence <br /></td></tr>
<tr class="separator:ae823003a7758ef937f4f05a532871f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb9d030d1532dfa0c05211bead6f717"><td class="memItemLeft" align="right" valign="top"><a id="a0bb9d030d1532dfa0c05211bead6f717"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a0bb9d030d1532dfa0c05211bead6f717">iterator_message_lengths</a> (int params_msg_len, int results_msg_len)</td></tr>
<tr class="memdesc:a0bb9d030d1532dfa0c05211bead6f717"><td class="mdescLeft">&#160;</td><td class="mdescRight">update paramsMsgLen and resultsMsgLen <br /></td></tr>
<tr class="separator:a0bb9d030d1532dfa0c05211bead6f717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3200e7ac334bd52eb4e406c5a6687ef"><td class="memItemLeft" align="right" valign="top"><a id="af3200e7ac334bd52eb4e406c5a6687ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#af3200e7ac334bd52eb4e406c5a6687ef">lead_rank</a> () const</td></tr>
<tr class="memdesc:af3200e7ac334bd52eb4e406c5a6687ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines if current processor is rank 0 of the parent comm <br /></td></tr>
<tr class="separator:af3200e7ac334bd52eb4e406c5a6687ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acb136690915bbd94ea628614709fee14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#acb136690915bbd94ea628614709fee14">init_iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;sub_iterator, ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:acb136690915bbd94ea628614709fee14"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for allocation of an iterator and (parallel) initialization of its comms  <a href="classDakota_1_1IteratorScheduler.html#acb136690915bbd94ea628614709fee14">More...</a><br /></td></tr>
<tr class="separator:acb136690915bbd94ea628614709fee14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ae0e9998a84af203a84c90ee462091"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a65ae0e9998a84af203a84c90ee462091">init_iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;sub_iterator, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt; sub_model, ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:a65ae0e9998a84af203a84c90ee462091"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for allocation of an iterator and (parallel) initialization of its comms  <a href="classDakota_1_1IteratorScheduler.html#a65ae0e9998a84af203a84c90ee462091">More...</a><br /></td></tr>
<tr class="separator:a65ae0e9998a84af203a84c90ee462091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e6cc1f954357e2a72b63437adc6b93"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a11e6cc1f954357e2a72b63437adc6b93">init_iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, const String &amp;method_string, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;sub_iterator, std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt;, ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:a11e6cc1f954357e2a72b63437adc6b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for lightweight allocation of an iterator and (parallel) initialization of its comms  <a href="classDakota_1_1IteratorScheduler.html#a11e6cc1f954357e2a72b63437adc6b93">More...</a><br /></td></tr>
<tr class="separator:a11e6cc1f954357e2a72b63437adc6b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1004a039a5fc40dd310ad0e5692b6704"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a1004a039a5fc40dd310ad0e5692b6704">set_iterator</a> (<a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;sub_iterator, ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:a1004a039a5fc40dd310ad0e5692b6704"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for setting comms prior to running an iterator  <a href="classDakota_1_1IteratorScheduler.html#a1004a039a5fc40dd310ad0e5692b6704">More...</a><br /></td></tr>
<tr class="separator:a1004a039a5fc40dd310ad0e5692b6704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ac7e8166717a58785e0d47d16cb16b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ad0ac7e8166717a58785e0d47d16cb16b">run_iterator</a> (<a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;sub_iterator, ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:ad0ac7e8166717a58785e0d47d16cb16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for invoking an iterator and managing parallelism. This version omits communicator repartitioning. Function must be public due to use by MINLPNode.  <a href="classDakota_1_1IteratorScheduler.html#ad0ac7e8166717a58785e0d47d16cb16b">More...</a><br /></td></tr>
<tr class="separator:ad0ac7e8166717a58785e0d47d16cb16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddabd2d4777e2c3ff7274aa9d4d5978"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a8ddabd2d4777e2c3ff7274aa9d4d5978">free_iterator</a> (<a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;sub_iterator, ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:a8ddabd2d4777e2c3ff7274aa9d4d5978"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for deallocating comms after running an iterator  <a href="classDakota_1_1IteratorScheduler.html#a8ddabd2d4777e2c3ff7274aa9d4d5978">More...</a><br /></td></tr>
<tr class="separator:a8ddabd2d4777e2c3ff7274aa9d4d5978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a702abf9be22e51f1e67167d5db1b08d3"><td class="memItemLeft" align="right" valign="top"><a id="a702abf9be22e51f1e67167d5db1b08d3"></a>
<a class="el" href="classDakota_1_1ParallelLibrary.html">ParallelLibrary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a702abf9be22e51f1e67167d5db1b08d3">parallelLib</a></td></tr>
<tr class="memdesc:a702abf9be22e51f1e67167d5db1b08d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to the <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a> instance <br /></td></tr>
<tr class="separator:a702abf9be22e51f1e67167d5db1b08d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21940665c2cebd322266e006534b8c3"><td class="memItemLeft" align="right" valign="top"><a id="aa21940665c2cebd322266e006534b8c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#aa21940665c2cebd322266e006534b8c3">numIteratorJobs</a></td></tr>
<tr class="memdesc:aa21940665c2cebd322266e006534b8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of iterator executions to schedule <br /></td></tr>
<tr class="separator:aa21940665c2cebd322266e006534b8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db56f9d2e4ef9258da7fb3252b9d4ae"><td class="memItemLeft" align="right" valign="top"><a id="a2db56f9d2e4ef9258da7fb3252b9d4ae"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a2db56f9d2e4ef9258da7fb3252b9d4ae">numIteratorServers</a></td></tr>
<tr class="memdesc:a2db56f9d2e4ef9258da7fb3252b9d4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of concurrent iterator partitions <br /></td></tr>
<tr class="separator:a2db56f9d2e4ef9258da7fb3252b9d4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432ffa52174dc1fc45eef54a0e46c873"><td class="memItemLeft" align="right" valign="top"><a id="a432ffa52174dc1fc45eef54a0e46c873"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a432ffa52174dc1fc45eef54a0e46c873">procsPerIterator</a></td></tr>
<tr class="memdesc:a432ffa52174dc1fc45eef54a0e46c873"><td class="mdescLeft">&#160;</td><td class="mdescRight">partition size request <br /></td></tr>
<tr class="separator:a432ffa52174dc1fc45eef54a0e46c873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f0a3a3df16046123e8a234bfa39736"><td class="memItemLeft" align="right" valign="top"><a id="ab4f0a3a3df16046123e8a234bfa39736"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ab4f0a3a3df16046123e8a234bfa39736">iteratorCommRank</a></td></tr>
<tr class="memdesc:ab4f0a3a3df16046123e8a234bfa39736"><td class="mdescLeft">&#160;</td><td class="mdescRight">processor rank in iteratorComm <br /></td></tr>
<tr class="separator:ab4f0a3a3df16046123e8a234bfa39736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7bd63ee74d6bea2b43bfa23a6fff26"><td class="memItemLeft" align="right" valign="top"><a id="aaa7bd63ee74d6bea2b43bfa23a6fff26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#aaa7bd63ee74d6bea2b43bfa23a6fff26">iteratorCommSize</a></td></tr>
<tr class="memdesc:aaa7bd63ee74d6bea2b43bfa23a6fff26"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of processors in iteratorComm <br /></td></tr>
<tr class="separator:aaa7bd63ee74d6bea2b43bfa23a6fff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f8abf2751c7fecc652b9520cc8af1e"><td class="memItemLeft" align="right" valign="top"><a id="a37f8abf2751c7fecc652b9520cc8af1e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a37f8abf2751c7fecc652b9520cc8af1e">iteratorServerId</a></td></tr>
<tr class="memdesc:a37f8abf2751c7fecc652b9520cc8af1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">identifier for an iterator server <br /></td></tr>
<tr class="separator:a37f8abf2751c7fecc652b9520cc8af1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898e7c1549d90f4978e558fd7f7f14fb"><td class="memItemLeft" align="right" valign="top"><a id="a898e7c1549d90f4978e558fd7f7f14fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a898e7c1549d90f4978e558fd7f7f14fb">messagePass</a></td></tr>
<tr class="memdesc:a898e7c1549d90f4978e558fd7f7f14fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for message passing among iterator servers <br /></td></tr>
<tr class="separator:a898e7c1549d90f4978e558fd7f7f14fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae793b078d1ed1301588506725ad1738e"><td class="memItemLeft" align="right" valign="top"><a id="ae793b078d1ed1301588506725ad1738e"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ae793b078d1ed1301588506725ad1738e">iteratorScheduling</a></td></tr>
<tr class="memdesc:ae793b078d1ed1301588506725ad1738e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEDICATED_SCHEDULER,DEFAULT,PEER*. <br /></td></tr>
<tr class="separator:ae793b078d1ed1301588506725ad1738e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88197a24c7047c69631011478be3ac4"><td class="memItemLeft" align="right" valign="top"><a id="af88197a24c7047c69631011478be3ac4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#af88197a24c7047c69631011478be3ac4">peerAssignJobs</a></td></tr>
<tr class="memdesc:af88197a24c7047c69631011478be3ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating need for peer 1 to assign jobs to peers 2-n <br /></td></tr>
<tr class="separator:af88197a24c7047c69631011478be3ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91b3bbd5b7b622ffac8c496c9334f72"><td class="memItemLeft" align="right" valign="top"><a id="ae91b3bbd5b7b622ffac8c496c9334f72"></a>
ParConfigLIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#ae91b3bbd5b7b622ffac8c496c9334f72">schedPCIter</a></td></tr>
<tr class="memdesc:ae91b3bbd5b7b622ffac8c496c9334f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator for active parallel configuration <br /></td></tr>
<tr class="separator:ae91b3bbd5b7b622ffac8c496c9334f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e795130df5da70292b937b0f52bb6e0"><td class="memItemLeft" align="right" valign="top"><a id="a3e795130df5da70292b937b0f52bb6e0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a3e795130df5da70292b937b0f52bb6e0">miPLIndex</a></td></tr>
<tr class="memdesc:a3e795130df5da70292b937b0f52bb6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of active parallel level (corresponding to <a class="el" href="classDakota_1_1ParallelConfiguration.html#abf54ee73a55414f0f9b39251d67bf101" title="list iterator for world level followed by any concurrent iterator partitions (there may be multiple p...">ParallelConfiguration::miPLIters</a>) to use for parallelLib send/recv <br /></td></tr>
<tr class="separator:a3e795130df5da70292b937b0f52bb6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a61ddc429d6d40524a902d6aaa3265071"><td class="memItemLeft" align="right" valign="top"><a id="a61ddc429d6d40524a902d6aaa3265071"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#a61ddc429d6d40524a902d6aaa3265071">paramsMsgLen</a></td></tr>
<tr class="memdesc:a61ddc429d6d40524a902d6aaa3265071"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of MPI buffer for parameter input instance(s) <br /></td></tr>
<tr class="separator:a61ddc429d6d40524a902d6aaa3265071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add773579b6173c0ccb74370c5c3343a2"><td class="memItemLeft" align="right" valign="top"><a id="add773579b6173c0ccb74370c5c3343a2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1IteratorScheduler.html#add773579b6173c0ccb74370c5c3343a2">resultsMsgLen</a></td></tr>
<tr class="memdesc:add773579b6173c0ccb74370c5c3343a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of MPI buffer for results output instance(s) <br /></td></tr>
<tr class="separator:add773579b6173c0ccb74370c5c3343a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class encapsulates scheduling operations for concurrent sub-iteration within an outer level context (e.g., meta-iteration, nested models). </p>
<p>In time, a Scheduler class hierarchy is envisioned, but for now, this class is not part of a hierarchy. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a39681e89c46a901f96a058218e64940a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39681e89c46a901f96a058218e64940a">&#9670;&nbsp;</a></span>IteratorScheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1IteratorScheduler.html">IteratorScheduler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ParallelLibrary.html">ParallelLibrary</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>peer_assign_jobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_servers</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procs_per_iterator</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>scheduling</em> = <code>DEFAULT_SCHEDULING</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor </p>
<p>Current constructor parameters are the input specification components, which are requests subject to override by <a class="el" href="classDakota_1_1ParallelLibrary.html#a09f0a78268e894c696872fd580a8b2b9" title="split MPI_COMM_WORLD into iterator communicators">ParallelLibrary::init_iterator_communicators()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acb136690915bbd94ea628614709fee14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb136690915bbd94ea628614709fee14">&#9670;&nbsp;</a></span>init_iterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParLevLIter&#160;</td>
          <td class="paramname"><em>pl_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience function for allocation of an iterator and (parallel) initialization of its comms </p>
<p>This is a convenience function for encapsulating the allocation of communicators prior to running an iterator. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ProblemDescDB.html#aa31a389d3119b97459700aa0ad2dabdd">ProblemDescDB::get_iterator()</a>, <a class="el" href="classDakota_1_1ProblemDescDB.html#a4850a09a8b87e7a43db4556209ef83aa">ProblemDescDB::get_model()</a>, and <a class="el" href="classDakota_1_1ProblemDescDB.html#ad3ea82c15d1bca2480538fb84a216edc">ProblemDescDB::get_ushort()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1MetaIterator.html#a54de35f67944473976c92831124f0841">MetaIterator::allocate_by_name()</a>, <a class="el" href="classDakota_1_1MetaIterator.html#a0e95fde9d70bd89e10518bd089470524">MetaIterator::allocate_by_pointer()</a>, <a class="el" href="classDakota_1_1Environment.html#a97d237dc32ef45f08c6397353f2ced4a">Environment::construct()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a67e0dc5174c06067b66bb394e991ebc4">ConcurrentMetaIterator::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NestedModel.html#ac3c996ef7944f6e09c454784247170bd">NestedModel::derived_init_communicators()</a>, and <a class="el" href="classDakota_1_1IteratorScheduler.html#ad79bdb9dd61e3064c2eecd343247cc93">IteratorScheduler::init_iterator()</a>.</p>

</div>
</div>
<a id="a65ae0e9998a84af203a84c90ee462091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ae0e9998a84af203a84c90ee462091">&#9670;&nbsp;</a></span>init_iterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt;&#160;</td>
          <td class="paramname"><em>sub_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParLevLIter&#160;</td>
          <td class="paramname"><em>pl_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience function for allocation of an iterator and (parallel) initialization of its comms </p>
<p>This is a convenience function for encapsulating the allocation of communicators prior to running an iterator. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ProblemDescDB.html#aa31a389d3119b97459700aa0ad2dabdd">ProblemDescDB::get_iterator()</a>, and <a class="el" href="classDakota_1_1ProblemDescDB.html#ad3ea82c15d1bca2480538fb84a216edc">ProblemDescDB::get_ushort()</a>.</p>

</div>
</div>
<a id="a11e6cc1f954357e2a72b63437adc6b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e6cc1f954357e2a72b63437adc6b93">&#9670;&nbsp;</a></span>init_iterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>method_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt;&#160;</td>
          <td class="paramname"><em>sub_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParLevLIter&#160;</td>
          <td class="paramname"><em>pl_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience function for lightweight allocation of an iterator and (parallel) initialization of its comms </p>
<p>This is a convenience function for encapsulating the allocation of communicators prior to running an iterator. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ProblemDescDB.html#aa31a389d3119b97459700aa0ad2dabdd">ProblemDescDB::get_iterator()</a>.</p>

</div>
</div>
<a id="a1004a039a5fc40dd310ad0e5692b6704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1004a039a5fc40dd310ad0e5692b6704">&#9670;&nbsp;</a></span>set_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParLevLIter&#160;</td>
          <td class="paramname"><em>pl_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience function for setting comms prior to running an iterator </p>
<p>This is a convenience function for encapsulating the deallocation of communicators after running an iterator. </p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#ae89bef5ad711f51ceea37e61bcde54d5">Iterator::derived_set_communicators()</a>, and <a class="el" href="classDakota_1_1Iterator.html#a23a2988e8289ea23b5ef6a9f75335493">Iterator::set_communicators()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1CollabHybridMetaIterator.html#a700fe9071f885ebd0cb735059d0c9f89">CollabHybridMetaIterator::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a700fe9071f885ebd0cb735059d0c9f89">ConcurrentMetaIterator::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1EmbedHybridMetaIterator.html#a700fe9071f885ebd0cb735059d0c9f89">EmbedHybridMetaIterator::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a700fe9071f885ebd0cb735059d0c9f89">SeqHybridMetaIterator::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1NestedModel.html#a5dc01eeb753d92707f44eef2bc68353b">NestedModel::derived_set_communicators()</a>, and <a class="el" href="classDakota_1_1IteratorScheduler.html#ae54803857231ddd06485af3612e48bf7">IteratorScheduler::set_iterator()</a>.</p>

</div>
</div>
<a id="ad0ac7e8166717a58785e0d47d16cb16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ac7e8166717a58785e0d47d16cb16b">&#9670;&nbsp;</a></span>run_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void run_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParLevLIter&#160;</td>
          <td class="paramname"><em>pl_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function for invoking an iterator and managing parallelism. This version omits communicator repartitioning. Function must be public due to use by MINLPNode. </p>
<p>This is a convenience function for encapsulating the parallel features (run/serve) of running an iterator. This function omits allocation/deallocation of communicators to provide greater efficiency in approaches that involve multiple iterator executions but only require communicator allocation/deallocation to be performed once. </p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a10975a77bd40017f5b209e325a18f347">Iterator::iterated_model()</a>, <a class="el" href="classDakota_1_1Iterator.html#af574c51ff1ee5be0a2c885e851f632d5">Iterator::maximum_evaluation_concurrency()</a>, <a class="el" href="classDakota_1_1Iterator.html#ae9f6c96808d09fa4a881e70ea5752aee">Iterator::method_name()</a>, <a class="el" href="classDakota_1_1Iterator.html#a6f8c40b3cee982c73152b661f079e3c4">Iterator::resize()</a>, <a class="el" href="classDakota_1_1Iterator.html#a3f57321282ae3e2d47dddb807166cd4e">Iterator::resize_communicators()</a>, and <a class="el" href="classDakota_1_1Iterator.html#a92cf4e7fbd96f3bccdcac2267be56e79">Iterator::run()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1NestedModel.html#a170ee6900f87485e07b8dd01fea7c8ae">NestedModel::derived_evaluate()</a>, <a class="el" href="classDakota_1_1Environment.html#a61af3e60b94ae3e748f6fbac1e794af7">Environment::execute()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a3923cc1379f3fbc5a15234e4357daafd">IteratorScheduler::peer_static_schedule_iterators()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a80084d7d99894057d8de61a1bc46ae96">IteratorScheduler::run_iterator()</a>, and <a class="el" href="classDakota_1_1IteratorScheduler.html#ad5424d037c6b68eb0068ade39540701f">IteratorScheduler::serve_iterators()</a>.</p>

</div>
</div>
<a id="a8ddabd2d4777e2c3ff7274aa9d4d5978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddabd2d4777e2c3ff7274aa9d4d5978">&#9670;&nbsp;</a></span>free_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParLevLIter&#160;</td>
          <td class="paramname"><em>pl_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience function for deallocating comms after running an iterator </p>
<p>This is a convenience function for encapsulating the deallocation of communicators after running an iterator. </p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#ac52bd656bac37cbf7cc8926b025a0b5a">Iterator::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1Iterator.html#a6b321b6a360f66235a6aff7352f67061">Iterator::free_communicators()</a>, and <a class="el" href="classDakota_1_1Iterator.html#ae9f6c96808d09fa4a881e70ea5752aee">Iterator::method_name()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1CollabHybridMetaIterator.html#a73ed9eb6149d020753991feb03f3aed0">CollabHybridMetaIterator::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a73ed9eb6149d020753991feb03f3aed0">ConcurrentMetaIterator::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1EmbedHybridMetaIterator.html#a73ed9eb6149d020753991feb03f3aed0">EmbedHybridMetaIterator::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a73ed9eb6149d020753991feb03f3aed0">SeqHybridMetaIterator::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NestedModel.html#aef5611560d740e7324e1a8edbbfd9a6b">NestedModel::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1Environment.html#af3b43681b3f195f17dac4f4ef64891f5">Environment::destruct()</a>, and <a class="el" href="classDakota_1_1IteratorScheduler.html#a6763b7f8acdd4b3277a51221262f8dbc">IteratorScheduler::free_iterator()</a>.</p>

</div>
</div>
<a id="acf5829c452ebf44b9231e8e91b6c37e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5829c452ebf44b9231e8e91b6c37e6">&#9670;&nbsp;</a></span>configure() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntIntPair configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt;&#160;</td>
          <td class="paramname"><em>sub_model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs sufficient initialization to define partitioning controls (min and max processors per iterator server) </p>
<p>This is a convenience function for computing the minimum and maximum partition size prior to concurrent iterator partitioning. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ProblemDescDB.html#aa31a389d3119b97459700aa0ad2dabdd">ProblemDescDB::get_iterator()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ae91b3bbd5b7b622ffac8c496c9334f72">IteratorScheduler::schedPCIter</a>, and <a class="el" href="classDakota_1_1ParallelLevel.html#a4a79edcfae8b1b2e09f40a1062dd71fd">ParallelLevel::server_communicator_rank()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1IteratorScheduler.html#acaeb91c628ae3ca224432415ca687943">IteratorScheduler::configure()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a67e0dc5174c06067b66bb394e991ebc4">ConcurrentMetaIterator::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NestedModel.html#ac3c996ef7944f6e09c454784247170bd">NestedModel::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1MetaIterator.html#a749b9c3fd628a571ef19cdf912fc87c5">MetaIterator::estimate_by_name()</a>, and <a class="el" href="classDakota_1_1MetaIterator.html#a81678f20a5a3e13dcea3e29f321a5ab5">MetaIterator::estimate_by_pointer()</a>.</p>

</div>
</div>
<a id="acaeb91c628ae3ca224432415ca687943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeb91c628ae3ca224432415ca687943">&#9670;&nbsp;</a></span>configure() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntIntPair configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>method_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Model.html">Model</a> &gt;&#160;</td>
          <td class="paramname"><em>sub_model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs sufficient initialization to define partitioning controls (min and max processors per iterator server) </p>
<p>This is a convenience function for computing the minimum and maximum partition size prior to concurrent iterator partitioning. </p>

<p class="reference">References <a class="el" href="classDakota_1_1IteratorScheduler.html#acf5829c452ebf44b9231e8e91b6c37e6">IteratorScheduler::configure()</a>, <a class="el" href="classDakota_1_1ProblemDescDB.html#aa31a389d3119b97459700aa0ad2dabdd">ProblemDescDB::get_iterator()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ae91b3bbd5b7b622ffac8c496c9334f72">IteratorScheduler::schedPCIter</a>, and <a class="el" href="classDakota_1_1ParallelLevel.html#a4a79edcfae8b1b2e09f40a1062dd71fd">ParallelLevel::server_communicator_rank()</a>.</p>

</div>
</div>
<a id="a06cc1bd28f90e68687c571e92ff9cda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cc1bd28f90e68687c571e92ff9cda5">&#9670;&nbsp;</a></span>configure() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntIntPair configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs sufficient initialization to define partitioning controls (min and max processors per iterator server) </p>
<p>This is a convenience function for computing the minimum and maximum partition size prior to concurrent iterator partitioning. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ParallelLibrary.html#aaeb1cd92c0129ea2ef0f80bae0b63fb6">ParallelLibrary::bcast()</a>, <a class="el" href="classDakota_1_1ProblemDescDB.html#abf669d74ae75b48a4fdcb12dd1302298">ProblemDescDB::get_db_method_node()</a>, <a class="el" href="classDakota_1_1ProblemDescDB.html#ad13f745ea3547a1c9eef4e50885629a7">ProblemDescDB::get_db_model_node()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a702abf9be22e51f1e67167d5db1b08d3">IteratorScheduler::parallelLib</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ae91b3bbd5b7b622ffac8c496c9334f72">IteratorScheduler::schedPCIter</a>, <a class="el" href="classDakota_1_1ParallelLevel.html#a4a79edcfae8b1b2e09f40a1062dd71fd">ParallelLevel::server_communicator_rank()</a>, <a class="el" href="classDakota_1_1ParallelLevel.html#a01e6aef97521e93b398ae7e97bfa7dc3">ParallelLevel::server_communicator_size()</a>, <a class="el" href="classDakota_1_1ProblemDescDB.html#a4c32cbd50ad2de5dce2daa56c8856e20">ProblemDescDB::set_db_method_node()</a>, <a class="el" href="classDakota_1_1ProblemDescDB.html#af9676f88ff2191bfc4a86371f3640b8b">ProblemDescDB::set_db_model_nodes()</a>, and <a class="el" href="classDakota_1_1MPIPackBuffer.html#af4b57d21919c42d55af03391f91a1c08">MPIPackBuffer::size()</a>.</p>

</div>
</div>
<a id="ab03445df3298900088e70328ffbd4e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03445df3298900088e70328ffbd4e6a">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void partition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iterator_concurrency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntIntPair &amp;&#160;</td>
          <td class="paramname"><em>ppi_pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience function for initializing iterator communicators, setting parallel configuration attributes, and managing outputs and restart. </p>
<p>Called from derived class constructors once maxIteratorConcurrency is defined but prior to instantiating Iterators and Models. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ParallelLibrary.html#a09f0a78268e894c696872fd580a8b2b9">ParallelLibrary::init_iterator_communicators()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ae793b078d1ed1301588506725ad1738e">IteratorScheduler::iteratorScheduling</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a2db56f9d2e4ef9258da7fb3252b9d4ae">IteratorScheduler::numIteratorServers</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ab518b3a2ea4d970f279fac0cdd0d9779">ParallelLibrary::parallel_configuration_iterator()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a702abf9be22e51f1e67167d5db1b08d3">IteratorScheduler::parallelLib</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a432ffa52174dc1fc45eef54a0e46c873">IteratorScheduler::procsPerIterator</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ac20739a883d672bc8ff5cd99b5a3505b">ParallelLibrary::push_output_tag()</a>, and <a class="el" href="classDakota_1_1IteratorScheduler.html#ae7a72bc79a35c5a3f92c148d8ad35ab6">IteratorScheduler::update()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1CollabHybridMetaIterator.html#a67e0dc5174c06067b66bb394e991ebc4">CollabHybridMetaIterator::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a67e0dc5174c06067b66bb394e991ebc4">ConcurrentMetaIterator::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1EmbedHybridMetaIterator.html#a67e0dc5174c06067b66bb394e991ebc4">EmbedHybridMetaIterator::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a67e0dc5174c06067b66bb394e991ebc4">SeqHybridMetaIterator::derived_init_communicators()</a>, and <a class="el" href="classDakota_1_1NestedModel.html#ac3c996ef7944f6e09c454784247170bd">NestedModel::derived_init_communicators()</a>.</p>

</div>
</div>
<a id="a3b4fc096237fec333bb036b44dee6e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4fc096237fec333bb036b44dee6e02">&#9670;&nbsp;</a></span>schedule_iterators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule_iterators </td>
          <td>(</td>
          <td class="paramtype">MetaType &amp;&#160;</td>
          <td class="paramname"><em>meta_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>short convenience function for distributing control among <a class="el" href="classDakota_1_1IteratorScheduler.html#a51455680837e78349909b2ecc353be14" title="executed by the dedicated scheduler to manage a dynamic schedule of iterator jobs among iterator serv...">dedicated_dynamic_scheduler_iterators()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ad5424d037c6b68eb0068ade39540701f" title="executed on the iterator servers to perform iterator jobs assigned by the dedicated scheduler">serve_iterators()</a>, and <a class="el" href="classDakota_1_1IteratorScheduler.html#a3923cc1379f3fbc5a15234e4357daafd" title="executed on iterator peers to manage a static schedule of iterator jobs">peer_static_schedule_iterators()</a> </p>
<p>This implementation supports the scheduling of multiple jobs using a single iterator/model pair. Additional future (overloaded) implementations could involve independent iterator instances. </p>

<p class="reference">References <a class="el" href="classDakota_1_1IteratorScheduler.html#a51455680837e78349909b2ecc353be14">IteratorScheduler::dedicated_dynamic_scheduler_iterators()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ae793b078d1ed1301588506725ad1738e">IteratorScheduler::iteratorScheduling</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a37f8abf2751c7fecc652b9520cc8af1e">IteratorScheduler::iteratorServerId</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#af3200e7ac334bd52eb4e406c5a6687ef">IteratorScheduler::lead_rank()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a2db56f9d2e4ef9258da7fb3252b9d4ae">IteratorScheduler::numIteratorServers</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ab518b3a2ea4d970f279fac0cdd0d9779">ParallelLibrary::parallel_configuration_iterator()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a702abf9be22e51f1e67167d5db1b08d3">IteratorScheduler::parallelLib</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a3923cc1379f3fbc5a15234e4357daafd">IteratorScheduler::peer_static_schedule_iterators()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ad5424d037c6b68eb0068ade39540701f">IteratorScheduler::serve_iterators()</a>, and <a class="el" href="classDakota_1_1IteratorScheduler.html#a014b4ab207bdeb86b98455ec3e2c4cde">IteratorScheduler::stop_iterator_servers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1CollabHybridMetaIterator.html#a68e0645a050a35afa58d1b91932cbb64">CollabHybridMetaIterator::core_run()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a68e0645a050a35afa58d1b91932cbb64">ConcurrentMetaIterator::core_run()</a>, <a class="el" href="classDakota_1_1EmbedHybridMetaIterator.html#a68e0645a050a35afa58d1b91932cbb64">EmbedHybridMetaIterator::core_run()</a>, <a class="el" href="classDakota_1_1NestedModel.html#a150b7ed8569a218cc3ff71b2e78f1968">NestedModel::derived_synchronize()</a>, <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a760202f6de331ca27a3fda79f17f5fd5">SeqHybridMetaIterator::run_sequential()</a>, and <a class="el" href="classDakota_1_1NestedModel.html#aa64150cf85836d52c91bddea58c30918">NestedModel::serve_run()</a>.</p>

</div>
</div>
<a id="a51455680837e78349909b2ecc353be14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51455680837e78349909b2ecc353be14">&#9670;&nbsp;</a></span>dedicated_dynamic_scheduler_iterators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dedicated_dynamic_scheduler_iterators </td>
          <td>(</td>
          <td class="paramtype">MetaType &amp;&#160;</td>
          <td class="paramname"><em>meta_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>executed by the dedicated scheduler to manage a dynamic schedule of iterator jobs among iterator servers </p>
<p>This function is adapted from <a class="el" href="classDakota_1_1ApplicationInterface.html#a90c27b85316d022999f8f31d6c382455" title="blocking dynamic schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a de...">ApplicationInterface::dedicated_dynamic_scheduler_evaluations()</a>. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ParallelLibrary.html#ad26295e7238e207366e6afd512cdd042">ParallelLibrary::free()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a4a1de535eca82aa50b96667e96f0ed51">ParallelLibrary::irecv_mi()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a21ed4023b15796c9e7eed3dec516c1d3">ParallelLibrary::isend_mi()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a3e795130df5da70292b937b0f52bb6e0">IteratorScheduler::miPLIndex</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#aa21940665c2cebd322266e006534b8c3">IteratorScheduler::numIteratorJobs</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a2db56f9d2e4ef9258da7fb3252b9d4ae">IteratorScheduler::numIteratorServers</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a702abf9be22e51f1e67167d5db1b08d3">IteratorScheduler::parallelLib</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#add773579b6173c0ccb74370c5c3343a2">IteratorScheduler::resultsMsgLen</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ab36465c19fd5a82a17b7cdb9822f4b36">ParallelLibrary::waitall()</a>, and <a class="el" href="classDakota_1_1ParallelLibrary.html#ac9d2b88383921e1ff529bc57378353fe">ParallelLibrary::waitsome()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1IteratorScheduler.html#a3b4fc096237fec333bb036b44dee6e02">IteratorScheduler::schedule_iterators()</a>.</p>

</div>
</div>
<a id="ad5424d037c6b68eb0068ade39540701f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5424d037c6b68eb0068ade39540701f">&#9670;&nbsp;</a></span>serve_iterators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serve_iterators </td>
          <td>(</td>
          <td class="paramtype">MetaType &amp;&#160;</td>
          <td class="paramname"><em>meta_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>executed on the iterator servers to perform iterator jobs assigned by the dedicated scheduler </p>
<p>This function is similar in structure to <a class="el" href="classDakota_1_1ApplicationInterface.html#a706547d76f07b61b158ff8231b43e3ea" title="serve the evaluation message passing schedulers and perform one synchronous evaluation at a time">ApplicationInterface::serve_evaluations_synch()</a>. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ParallelLibrary.html#ae5d18d289016e91b96db56267cb0301c">ParallelLibrary::bcast_i()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ab4f0a3a3df16046123e8a234bfa39736">IteratorScheduler::iteratorCommRank</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#aaa7bd63ee74d6bea2b43bfa23a6fff26">IteratorScheduler::iteratorCommSize</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a3e795130df5da70292b937b0f52bb6e0">IteratorScheduler::miPLIndex</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a45539f44d1215727e558b62fc2a6073c">ParallelLibrary::parallel_time()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a702abf9be22e51f1e67167d5db1b08d3">IteratorScheduler::parallelLib</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#a61ddc429d6d40524a902d6aaa3265071">IteratorScheduler::paramsMsgLen</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a825d7cf5e44ad912099a281e4f97b2b2">ParallelLibrary::recv_mi()</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#add773579b6173c0ccb74370c5c3343a2">IteratorScheduler::resultsMsgLen</a>, <a class="el" href="classDakota_1_1IteratorScheduler.html#ad0ac7e8166717a58785e0d47d16cb16b">IteratorScheduler::run_iterator()</a>, and <a class="el" href="classDakota_1_1ParallelLibrary.html#a2de9bcf32bdcca7626a9a1c8d4824d1e">ParallelLibrary::send_mi()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1IteratorScheduler.html#a3b4fc096237fec333bb036b44dee6e02">IteratorScheduler::schedule_iterators()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>IteratorScheduler.hpp</li>
<li>IteratorScheduler.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
