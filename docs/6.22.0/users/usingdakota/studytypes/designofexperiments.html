<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Design of Experiments &mdash; dakota  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/dakota_theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/sandiaheaderlite.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Uncertainty Quantification" href="uq.html" />
    <link rel="prev" title="Parameter Studies" href="parameterstudies.html" /> 
  
  <meta name="sandia.approval_type" content="formal"/>
  <meta property="sandia.approved" content="SAND2025-05563O"/>
  <meta name="description" content="The Dakota project delivers both state-of-the-art research and robust, usable software for optimization and UQ."/>
  <meta name="keywords" content="Dakota, optimization, UQ, uncertainty quantification, parametric analysis, design exploration, model calibration, risk analysis"/>
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> dakota
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../setupdakota.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../usingdakota.html">Using Dakota</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../introduction/aboutdakota.html">About Dakota</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/helloworld.html">Dakota Beginner’s Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/couplingtosimulations.html">Coupling Dakota to a Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../inputfile.html">Dakota Input File</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running.html">Running Dakota</a></li>
<li class="toctree-l2"><a class="reference internal" href="../output.html">Dakota Output</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../studytypes.html">Study Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="parameterstudies.html">Parameter Studies</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Design of Experiments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#design-of-computer-experiments">Design of Computer Experiments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ddace">DDACE</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#central-composite-design">Central Composite Design</a></li>
<li class="toctree-l5"><a class="reference internal" href="#box-behnken-design">Box-Behnken Design</a></li>
<li class="toctree-l5"><a class="reference internal" href="#orthogonal-array-designs">Orthogonal Array Designs</a></li>
<li class="toctree-l5"><a class="reference internal" href="#grid-design">Grid Design</a></li>
<li class="toctree-l5"><a class="reference internal" href="#monte-carlo-design">Monte Carlo Design</a></li>
<li class="toctree-l5"><a class="reference internal" href="#lhs-design">LHS Design</a></li>
<li class="toctree-l5"><a class="reference internal" href="#oa-lhs-design">OA-LHS Design</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#fsudace">FSUDace</a></li>
<li class="toctree-l4"><a class="reference internal" href="#psuade-moat">PSUADE MOAT</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sensitivity-analysis">Sensitivity Analysis</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#sensitivity-analysis-overview">Sensitivity Analysis Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="#assessing-sensitivity-with-dace">Assessing Sensitivity with DACE</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#doe-usage-guidelines">DOE Usage Guidelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#video-resources">Video Resources</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="uq.html">Uncertainty Quantification</a></li>
<li class="toctree-l3"><a class="reference internal" href="optimization.html">Optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="nonlinearleastsquares.html">Nonlinear Least Squares</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../topics.html">Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../advanced.html">Advanced Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../theory.html">Dakota Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference.html">Keyword Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../usingdakotagui/usingdakotagui.html">Using Dakota GUI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../externaltools/externaltools.html">Using External Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../compiling/compiling.html">Compiling Dakota</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developingdakota/developingdakota.html">Developing Dakota</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/misc.html">Miscellaneous</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dakota</a>
      </nav>

	  <!-- SNL Lite header -->
	  <div class="snlheader-subsite--wrapper-default">
		<snlheader class="snlheader-subsite" role="snlbanner">
		  <div class="wrapper">
			<a href="https://www.sandia.gov/index.html">
			  <div class="logo-transparent"><p class="logo">Sandia National Laboratories</p></div>
			</a>
			<div class="nav-top">
			  <a class="visuallyhidden" name="mainnav"></a>
			  <div aria-label="main navigation" class="core-nav-transparent core-nav-transparent--visible" role="navigation">
				<ul role="navigation" class="secondary-links">
				  <li id="search-text-link">
					<a aria-label="Search" href="https://www.sandia.gov/search/">Search Sandia.gov</a>
				  </li>
				  <li id="directory-text-link">
					<a href="https://www.sandia.gov/directory.html" aria-expanded="false" aria-label="Site Directory">All Sandia Websites</a>
				  </li>
				</ul>
			  </div>
			</div>
		  </div> 
		</snlheader>
	  </div>	  

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../usingdakota.html">Using Dakota</a></li>
          <li class="breadcrumb-item"><a href="../studytypes.html">Study Types</a></li>
      <li class="breadcrumb-item active">Design of Experiments</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/usingdakota/studytypes/designofexperiments.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="design-of-experiments">
<span id="dace"></span><h1>Design of Experiments<a class="headerlink" href="#design-of-experiments" title="Link to this heading"></a></h1>
<section id="overview">
<span id="dace-overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>Classical design of experiments (DoE) methods and the more modern design
and analysis of computer experiments (DACE) methods are both techniques
which seek to extract as much trend data from a parameter space as
possible using a limited number of sample points. Classical DoE
techniques arose from technical disciplines that assumed some randomness
and nonrepeatability in field experiments (e.g., agricultural yield,
experimental chemistry). DoE approaches such as central composite
design, Box-Behnken design, and full and fractional factorial design
generally put sample points at the extremes of the parameter space,
since these designs offer more reliable trend extraction in the presence
of nonrepeatability. DACE methods are distinguished from DoE methods in
that the nonrepeatability component can be omitted since computer
simulations are involved. In these cases, space filling designs such as
orthogonal array sampling and Latin hypercube sampling are more commonly
employed in order to accurately extract trend information. Quasi-Monte
Carlo sampling techniques which are constructed to fill the unit
hypercube with good uniformity of coverage can also be used for DACE.</p>
<p>Dakota supports both DoE and DACE techniques. In common usage, only
parameter bounds are used in selecting the samples within the parameter
space. Thus, DoE and DACE can be viewed as special cases of the more
general probabilistic sampling for uncertainty quantification (see
following section), in which the DoE/DACE parameters are treated as
having uniform probability distributions. The DoE/DACE techniques are
commonly used for investigation of global response trends,
identification of significant parameters (e.g., main effects), and as
data generation methods for building response surface approximations.</p>
<p>Dakota includes several approaches sampling and design of experiments,
all implemented in included third-party software libraries. LHS (Latin
hypercube sampling) <span id="id1">[<a class="reference internal" href="../../misc/bibliography.html#id275" title="L. P. Swiler and G. D. Wyss. A user's guide to Sandia's latin hypercube sampling software: LHS UNIX library and standalone version. Technical Report SAND04-2439, Sandia National Laboratories, Albuquerque, NM, July 2004.">SW04</a>]</span> is a general-purpose
sampling package developed at Sandia that has been used by the DOE
national labs for several decades. DDACE (distributed design and
analysis for computer experiments) is a more recent package for computer
experiments developed at Sandia Labs <span id="id2">[<a class="reference internal" href="../../misc/bibliography.html#id284" title="C. H. Tong and J. C. Meza. DDACE: a distributed object-oriented software with multiple samplings for the design and analysis of computer experiments. Draft as yet unpublished, see also http://www.sandia.gov/csit/research/computation/ddace.php.">TM</a>]</span>. DDACE
provides the capability for generating orthogonal arrays, Box-Behnken
designs, Central Composite designs, and random designs. The FSUDace
(Florida State University’s Design and Analysis of Computer Experiments)
package provides the following sampling techniques: quasi-Monte Carlo
sampling based on Halton or Hammersley sequences, and Centroidal Voronoi
Tessellation. Lawrence Livermore National Lab’s PSUADE (Problem Solving
Environment for Uncertainty Analysis and Design
Exploration) <span id="id3">[<a class="reference internal" href="../../misc/bibliography.html#id285" title="C. H. Tong. The PSUADE software library. Web site, 2005. http://www.llnl.gov/CASC/uncertainty_quantification/#psuade.">Ton05</a>]</span> includes several methods for
model exploration, but only the Morris screening method is exposed in
Dakota.</p>
<p>This chapter describes DDACE, FSUDace, and PSUADE, with a focus on
designing computer experiments. Latin Hypercube Sampling, also used in
uncertainty quantification, is discussed in <a class="reference internal" href="uq.html#uq-sampling"><span class="std std-ref">the section on sampling methods</span></a>.</p>
</section>
<section id="design-of-computer-experiments">
<span id="dace-background"></span><h2>Design of Computer Experiments<a class="headerlink" href="#design-of-computer-experiments" title="Link to this heading"></a></h2>
<p>What distinguishes design of <em>computer</em> experiments? Computer
experiments are often different from physical experiments, such as those
performed in agriculture, manufacturing, or biology. In physical
experiments, one often applies the same <em>treatment</em> or <em>factor level</em> in
an experiment several times to get an understanding of the variability
of the output when that treatment is applied. For example, in an
agricultural experiment, several fields (e.g., 8) may be subject to a
low level of fertilizer and the same number of fields may be subject to
a high level of fertilizer to see if the amount of fertilizer has a
significant effect on crop output. In addition, one is often interested
in the variability of the output within a treatment group: is the
variability of the crop yields in the low fertilizer group much higher
than that in the high fertilizer group, or not?</p>
<p>In physical experiments, the process we are trying to examine is
stochastic: that is, the same treatment may result in different
outcomes. By contrast, in computer experiments, often we have a
deterministic code. If we run the code with a particular set of input
parameters, the code will always produce the same output. There
certainly are stochastic codes, but the main focus of computer
experimentation has been on deterministic codes. Thus, in computer
experiments we often do not have the need to do replicates (running the
code with the exact same input parameters several times to see
differences in outputs). Instead, a major concern in computer
experiments is to create an experimental design which can sample a
high-dimensional space in a representative way with a minimum number of
samples. The number of factors or parameters that we wish to explore in
computer experiments is usually much higher than physical experiments.
In physical experiments, one may be interested in varying a few
parameters, usually five or less, while in computer experiments we often
have dozens of parameters of interest. Choosing the levels of these
parameters so that the samples adequately explore the input space is a
challenging problem. There are many experimental designs and sampling
methods which address the issue of adequate and representative sample
selection.</p>
<p>There are many goals of running a computer experiment: one may want to
explore the input domain or the design space and get a better
understanding of the range in the outputs for a particular domain.
Another objective is to determine which inputs have the most influence
on the output, or how changes in the inputs change the output. This is
usually called <em>sensitivity analysis</em>.</p>
<p>Another goal is to use the
sampled input points and their corresponding output to create a
<em>response surface approximation</em> for the computer code. The response
surface approximation (e.g., a polynomial regression model, a
Gaussian-process/Kriging model, a neural net) can then be used to
emulate the computer code. Constructing a response surface approximation
is particularly important for applications where running a computational
model is extremely expensive: the computer model may take 10 or 20 hours
to run on a high performance machine, whereas the response surface model
may only take a few seconds. Thus, one often optimizes the response
surface model or uses it within a framework such as surrogate-based
optimization. Response surface models are also valuable in cases where
the gradient (first derivative) and/or Hessian (second derivative)
information required by optimization techniques are either not
available, expensive to compute, or inaccurate because the derivatives
are poorly approximated or the function evaluation is itself noisy due
to roundoff errors. Furthermore, many optimization methods require a
good initial point to ensure fast convergence or to converge to good
solutions (e.g. for problems with multiple local minima). Under these
circumstances, a good design of computer experiment framework coupled
with response surface approximations can offer great advantages.</p>
<p>In addition to the sensitivity analysis and response surface modeling
mentioned above, we also may want to do <em>uncertainty quantification</em> on
a computer model. Uncertainty quantification (UQ) refers to taking a
particular set of distributions on the inputs, and propagating them
through the model to obtain a distribution on the outputs. For example,
if input parameter A follows a normal distribution with mean 5 and variance 1, the
computer produces a random draw from that distribution. If input
parameter B follows a weibull distribution with alpha = 0.5 and beta =
1, the computer produces a random draw from that distribution. When all
of the uncertain variables have samples drawn from their input
distributions, we run the model with the sampled values as inputs. We do
this repeatedly to build up a distribution of outputs. We can then use
the cumulative distribution function of the output to ask questions such
as: what is the probability that the output is greater than 10? What is
the 99th percentile of the output?</p>
<p>Note that sampling-based uncertainty quantification and design of
computer experiments are very similar. <em>There is significant overlap</em> in
the purpose and methods used for UQ and for DACE. We have attempted to
delineate the differences within Dakota as follows: we use the methods
DDACE, FSUDACE, and PSUADE primarily for design of experiments, where we
are interested in understanding the main effects of parameters and where
we want to sample over an input domain to obtain values for constructing
a response surface. We use the nondeterministic sampling methods
(<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-sampling.html"><span class="pre">sampling</span></a></code>) for uncertainty quantification, where we are propagating
specific input distributions and interested in obtaining (for example) a
cumulative distribution function on the output. If one has a problem
with no distributional information, we recommend starting with a design
of experiments approach. Note that DDACE, FSUDACE, and PSUADE currently
do <em>not</em> support distributional information: they take an upper and
lower bound for each uncertain input variable and sample within that.
The uncertainty quantification methods in <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-sampling.html"><span class="pre">sampling</span></a></code> (primarily Latin
Hypercube sampling) offer the capability to sample from many
distributional types. The distinction between UQ and DACE is somewhat
arbitrary: both approaches often can yield insight about important
parameters and both can determine sample points for response surface
approximations.</p>
<p>Three software packages are available in Dakota for design of computer
experiments, DDACE (developed at Sandia Labs), FSUDACE (developed at
Florida State University), and PSUADE (LLNL).</p>
</section>
<section id="ddace">
<span id="dace-ddace"></span><h2>DDACE<a class="headerlink" href="#ddace" title="Link to this heading"></a></h2>
<p>The Distributed Design and Analysis of Computer Experiments (DDACE)
package includes both classical design of experiments
methods <span id="id4">[<a class="reference internal" href="../../misc/bibliography.html#id284" title="C. H. Tong and J. C. Meza. DDACE: a distributed object-oriented software with multiple samplings for the design and analysis of computer experiments. Draft as yet unpublished, see also http://www.sandia.gov/csit/research/computation/ddace.php.">TM</a>]</span> and stochastic sampling methods. The
classical design of experiments methods in DDACE are central composite
design (CCD) and Box-Behnken (BB) sampling. A grid-based sampling
(full-factorial) method is also available. The stochastic methods are
orthogonal array sampling <span id="id5">[<a class="reference internal" href="../../misc/bibliography.html#id173" title="J. R. Koehler and A. B. Owen. Computer experiments. In S. Ghosh and C. R. Rao, editors, Handbook of Statistics, volume 13. Elsevier Science, New York, 1996.">KO96</a>]</span> (which permits main
effects calculations), Monte Carlo (random) sampling, Latin hypercube
sampling, and orthogonal array-Latin hypercube sampling. While DDACE LHS
supports variables with normal or uniform distributions, only uniform
are supported through Dakota. Also DDACE does not allow enforcement of
user-specified correlation structure among the variables.</p>
<p>The sampling methods in DDACE can be used alone or in conjunction with
other methods. For example, DDACE sampling can be used with both
surrogate-based optimization and optimization under uncertainty advanced
methods. See <a class="reference internal" href="../advanced/advancedmodelrecursions.html#adv-models-figure09"><span class="std std-numref">Listing 69</span></a> for
an example of how the DDACE settings are used in Dakota.</p>
<p>The following sections provide more detail about the sampling methods
available for design of experiments in DDACE.</p>
<section id="central-composite-design">
<span id="dace-ccd"></span><h3>Central Composite Design<a class="headerlink" href="#central-composite-design" title="Link to this heading"></a></h3>
<p>A Box-Wilson Central Composite Design, commonly called a central
composite design (CCD), contains an embedded factorial or fractional
factorial design with center points that is augmented with a group of
’star points’ that allow estimation of curvature. If the distance from
the center of the design space to a factorial point is <span class="math notranslate nohighlight">\(\pm\)</span>1
unit for each factor, the distance from the center of the design space
to a star point is <span class="math notranslate nohighlight">\(\pm\alpha\)</span> with <span class="math notranslate nohighlight">\(\mid\alpha\mid &gt; 1\)</span>.
The precise value of <span class="math notranslate nohighlight">\(\alpha\)</span> depends on certain properties
desired for the design and on the number of factors involved. The CCD
design is specified in Dakota with the method command
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace.html"><span class="pre">dace</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-central_composite.html"><span class="pre">central_composite</span></a></code>.</p>
<p>As an example, with two input variables or factors, each having two
levels, the factorial design is shown in <a class="reference internal" href="#dace-table1"><span class="std std-numref">Table 3</span></a>:</p>
<table class="docutils align-center" id="dace-table1">
<caption><span class="caption-number">Table 3 </span><span class="caption-text"><em>Simple Factorial Design</em></span><a class="headerlink" href="#dace-table1" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Input 1</p></th>
<th class="head"><p>Input 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-1</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>-1</p></td>
<td><p>+1</p></td>
</tr>
<tr class="row-even"><td><p>+1</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>+1</p></td>
<td><p>+1</p></td>
</tr>
</tbody>
</table>
<p>With a CCD, the design in <a class="reference internal" href="#dace-table1"><span class="std std-numref">Table 3</span></a> would be
augmented with the points shown in <a class="reference internal" href="#dace-table2"><span class="std std-numref">Table 4</span></a>,
if <span class="math notranslate nohighlight">\(\alpha\)</span> = 1.3.</p>
<table class="docutils align-center" id="dace-table2">
<caption><span class="caption-number">Table 4 </span><span class="caption-text"><em>Additional Points to make the factorial design a CCD</em></span><a class="headerlink" href="#dace-table2" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Input 1</p></th>
<th class="head"><p>Input 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>+1.3</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>-1.3</p></td>
</tr>
<tr class="row-even"><td><p>1.3</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>-1.3</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>These points define a circle around the original factorial design.
Note that the number of sample points specified in a CCD, <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-samples.html"><span class="pre">samples</span></a></code>,
is a function of the number of variables in the problem:</p>
<div class="math notranslate nohighlight">
\[samples = 1 + 2*NumVar + 2^{NumVar}\]</div>
</section>
<section id="box-behnken-design">
<span id="dace-bb"></span><h3>Box-Behnken Design<a class="headerlink" href="#box-behnken-design" title="Link to this heading"></a></h3>
<p>The Box-Behnken design is similar to a Central Composite design, with
some differences. The Box-Behnken design is a quadratic design in that
it does not contain an embedded factorial or fractional factorial
design. In this design the treatment combinations are at the midpoints
of edges of the process space and at the center, as compared with CCD
designs where the extra points are placed at ’star points’ on a circle
outside of the process space. Box-Behken designs are rotatable (or near
rotatable) and require 3 levels of each factor. The designs have limited
capability for orthogonal blocking compared to the central composite
designs. Box-Behnken requires fewer runs than CCD for 3 factors, but
this advantage goes away as the number of factors increases. The
Box-Behnken design is specified in Dakota with the method command
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace.html"><span class="pre">dace</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-box_behnken.html"><span class="pre">box_behnken</span></a></code>.</p>
<p>Note that the number of sample points specified in a Box-Behnken design,
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-samples.html"><span class="pre">samples</span></a></code>, is a function of the number of variables in the problem:</p>
<div class="math notranslate nohighlight">
\[samples = 1 + 4*NumVar + (NumVar-1)/2\]</div>
</section>
<section id="orthogonal-array-designs">
<span id="dace-oas"></span><h3>Orthogonal Array Designs<a class="headerlink" href="#orthogonal-array-designs" title="Link to this heading"></a></h3>
<p>Orthogonal array (OA) sampling is a widely used technique for running
experiments and systematically testing factor
effects <span id="id6">[<a class="reference internal" href="../../misc/bibliography.html#id147" title="A. S. Hedayat, N. J. A. Sloane, and J. Stufken. Orthogonal Arrays: Theory and Applications. Springer-Verlag, New York, 1999.">HSS99</a>]</span>. An orthogonal array sample can be
described as a 4-tuple <span class="math notranslate nohighlight">\((m,n,s,r)\)</span>, where <span class="math notranslate nohighlight">\(m\)</span> is the number
of sample points, <span class="math notranslate nohighlight">\(n\)</span> is the number of input variables, <span class="math notranslate nohighlight">\(s\)</span>
is the number of symbols, and <span class="math notranslate nohighlight">\(r\)</span> is the strength of the
orthogonal array. The number of sample points, <span class="math notranslate nohighlight">\(m\)</span>, must be a
multiple of the number of symbols, <span class="math notranslate nohighlight">\(s\)</span>. The number of symbols
refers to the number of levels per input variable. The strength refers
to the number of columns where we are guaranteed to see all the
possibilities an equal number of times.</p>
<p>For example, <a class="reference internal" href="#dace-table3"><span class="std std-numref">Table 5</span></a> shows an orthogonal array of
strength 2 for <span class="math notranslate nohighlight">\(m\)</span> = 8, with 7 variables:</p>
<table class="docutils align-center" id="dace-table3">
<caption><span class="caption-number">Table 5 </span><span class="caption-text"><em>Orthogonal Array for Seven Variables</em></span><a class="headerlink" href="#dace-table3" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Input 1</p></th>
<th class="head"><p>Input 2</p></th>
<th class="head"><p>Input 3</p></th>
<th class="head"><p>Input 4</p></th>
<th class="head"><p>Input 5</p></th>
<th class="head"><p>Input 6</p></th>
<th class="head"><p>Input 7</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<p>If one picks any two columns, say the first and the third, note that
each of the four possible rows we might see there, 0 0, 0 1, 1 0, 1 1,
appears exactly the same number of times, twice in this case.</p>
<p>DDACE creates orthogonal arrays of strength 2. Further, the OAs
generated by DDACE do not treat the factor levels as one fixed value (0
or 1 in the above example). Instead, once a level for a variable is
determined in the array, DDACE samples a random variable from within
that level. The orthogonal array design is specified in Dakota with the
method command <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace.html"><span class="pre">dace</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-oas.html"><span class="pre">oas</span></a></code>.</p>
<p>The orthogonal array method in DDACE is the only method that allows for
the calculation of main effects, specified with the command
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-main_effects.html"><span class="pre">main_effects</span></a></code>. Main effects is a sensitivity analysis method which
identifies the input variables that have the most influence on the
output. In main effects, the idea is to look at the mean of the response
function when variable A (for example) is at level 1 vs. when variable A
is at level 2 or level 3. If these mean responses of the output are
statistically significantly different at different levels of variable A,
this is an indication that variable A has a significant effect on the
response. The orthogonality of the columns is critical in performing
main effects analysis, since the column orthogonality means that the
effects of the other variables ’cancel out’ when looking at the overall
effect from one variable at its different levels. There are ways of
developing orthogonal arrays to calculate higher order interactions,
such as two-way interactions (what is the influence of Variable A *
Variable B on the output?), but this is not available in DDACE
currently. At present, one way interactions are supported in the
calculation of orthogonal array main effects within DDACE. The main
effects are presented as a series of ANOVA tables. For each objective
function and constraint, the decomposition of variance of that objective
or constraint is presented as a function of the input variables. The
p-value in the ANOVA table is used to indicate if the input factor is
significant. The p-value is the probability that you would have obtained
samples more extreme than you did if the input factor has no effect on
the response. For example, if you set a level of significance at 0.05
for your p-value, and the actual p-value is 0.03, then the input factor
has a significant effect on the response.</p>
</section>
<section id="grid-design">
<span id="dace-grid"></span><h3>Grid Design<a class="headerlink" href="#grid-design" title="Link to this heading"></a></h3>
<p>In a grid design, a grid is placed over the input variable space. This
is very similar to a multi-dimensional parameter study where the samples
are taken over a set of partitions on each variable. The main
difference is that in grid sampling, a small random perturbation is
added to each sample value so that the grid points are not on a perfect
grid. This is done to help capture certain features in the output such
as periodic functions. A purely structured grid, with the samples
exactly on the grid points, has the disadvantage of not being able to
capture important features such as periodic functions with relatively
high frequency (due to aliasing). Adding a random perturbation to the
grid samples helps remedy this problem.</p>
<p>Another disadvantage with grid sampling is that the number of sample
points required depends exponentially on the input dimensions. In grid
sampling, the number of samples is the number of symbols (grid
partitions) raised to the number of variables. For example, if there are
2 variables, each with 5 partitions, the number of samples would be
<span class="math notranslate nohighlight">\(5^2\)</span>. In this case, doubling the number of variables squares the
sample size. The grid design is specified in Dakota with the method
command <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace.html"><span class="pre">dace</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-grid.html"><span class="pre">grid</span></a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Refer to the section on <a class="reference internal" href="parameterstudies.html#ps-multidimensional"><span class="std std-ref">multi-dimensional parameter studies</span></a> for more information.</p>
</div>
</section>
<section id="monte-carlo-design">
<span id="dace-mc"></span><h3>Monte Carlo Design<a class="headerlink" href="#monte-carlo-design" title="Link to this heading"></a></h3>
<p>Monte Carlo designs simply involve pure Monte-Carlo random sampling from
uniform distributions between the lower and upper bounds on each of the
input variables. Monte Carlo designs, specified by <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace.html"><span class="pre">dace</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-random.html"><span class="pre">random</span></a></code>, are
a way to generate a set of random samples over an input domain.</p>
</section>
<section id="lhs-design">
<span id="dace-lhs"></span><h3>LHS Design<a class="headerlink" href="#lhs-design" title="Link to this heading"></a></h3>
<p>DDACE offers the capability to generate Latin Hypercube designs. Note that the version of LHS
in DDACE generates uniform samples (uniform between the variable
bounds). The version of LHS offered with nondeterministic sampling can
generate LHS samples according to a number of distribution types,
including normal, lognormal, weibull, beta, etc. To specify the DDACE
version of LHS, use the method command <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace.html"><span class="pre">dace</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-lhs.html"><span class="pre">lhs</span></a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Refer to the section on <a class="reference internal" href="uq.html#uq-sampling"><span class="std std-ref">Latin Hypercube sampling</span></a> for more information.</p>
</div>
</section>
<section id="oa-lhs-design">
<span id="dace-oalhs"></span><h3>OA-LHS Design<a class="headerlink" href="#oa-lhs-design" title="Link to this heading"></a></h3>
<p>DDACE offers a hybrid design which is combination of an orthogonal array
and a Latin Hypercube sample. This design is specified with the method
command <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace.html"><span class="pre">dace</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-oa_lhs.html"><span class="pre">oa_lhs</span></a></code>. This design has the advantages of both
orthogonality of the inputs as well as stratification of the samples
(see <span id="id7">[<a class="reference internal" href="../../misc/bibliography.html#id226" title="A. B. Owen. Orthogonal arrays for computer experiments, integration, and visualization. Statistica Sinica, 2(2):439-452, 1992.">Owe92</a>]</span>).</p>
</section>
</section>
<section id="fsudace">
<span id="dace-fsudace"></span><h2>FSUDace<a class="headerlink" href="#fsudace" title="Link to this heading"></a></h2>
<p>The Florida State University Design and Analysis of Computer Experiments
(FSUDace) package provides quasi-Monte Carlo sampling (Halton and
Hammersley) and Centroidal Voronoi Tessellation (CVT) methods. All three
methods natively generate sets of uniform random variables on the
interval <span class="math notranslate nohighlight">\([0,1]\)</span> (or in Dakota, on user-specified uniform
intervals).</p>
<p>The quasi-Monte Carlo and CVT methods are designed with the goal of low
discrepancy. Discrepancy refers to the nonuniformity of the sample
points within the unit hypercube. Low discrepancy sequences tend to
cover the unit hypercube reasonably uniformly. Quasi-Monte Carlo methods
produce low discrepancy sequences, especially if one is interested in
the uniformity of projections of the point sets onto lower dimensional
faces of the hypercube (usually 1-D: how well do the marginal
distributions approximate a uniform?) CVT does very well volumetrically:
it spaces the points fairly equally throughout the space, so that the
points cover the region and are isotropically distributed with no
directional bias in the point placement. There are various measures of
volumetric uniformity which take into account the distances between
pairs of points, regularity measures, etc. Note that CVT does not
produce low-discrepancy sequences in lower dimensions, however: the
lower-dimension (such as 1-D) projections of CVT can have high
discrepancy.</p>
<p>The quasi-Monte Carlo sequences of Halton and Hammersley are
deterministic sequences determined by a set of prime bases. A Halton
design is specified in Dakota with the method command
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-fsu_quasi_mc.html"><span class="pre">fsu_quasi_mc</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-fsu_quasi_mc-halton.html"><span class="pre">halton</span></a></code>, and the Hammersley design is specified with the
command <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-fsu_quasi_mc.html"><span class="pre">fsu_quasi_mc</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-fsu_quasi_mc-hammersley.html"><span class="pre">hammersley</span></a></code>. For more details about the input
specification, see <a class="reference internal" href="../reference/method-fsu_quasi_mc.html#method-fsu-quasi-mc"><span class="std std-ref">the Reference Manual</span></a>. CVT points tend to arrange
themselves in a pattern of cells that are roughly the same shape. To
produce CVT points, an almost arbitrary set of initial points is chosen,
and then an internal set of iterations is carried out. These iterations
repeatedly replace the current set of sample points by an estimate of
the centroids of the corresponding Voronoi
subregions <span id="id8">[<a class="reference internal" href="../../misc/bibliography.html#id60" title="Q. Du, V. Faber, and M. Gunzburger. Centroidal voronoi tessellations: applications and algorithms. SIAM Review, 41:637–676, 1999.">DFG99</a>]</span>. A CVT design is specified in Dakota
with the method command <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-fsu_cvt.html"><span class="pre">fsu_cvt</span></a></code>.</p>
<p>The methods in FSUDace are useful for design of experiments because they
provide good coverage of the input space, thus allowing global
sensitivity analysis.</p>
</section>
<section id="psuade-moat">
<span id="dace-psuade"></span><h2>PSUADE MOAT<a class="headerlink" href="#psuade-moat" title="Link to this heading"></a></h2>
<p>PSUADE (Problem Solving Environment for Uncertainty Analysis and Design
Exploration) is a Lawrence Livermore National Laboratory tool for
metamodeling, sensitivity analysis, uncertainty quantification, and
optimization. Its features include non-intrusive and parallel function
evaluations, sampling and analysis methods, an integrated design and
analysis framework, global optimization, numerical integration, response
surfaces (MARS and higher order regressions), graphical output with
Pgplot or Matlab, and fault tolerance <span id="id9">[<a class="reference internal" href="../../misc/bibliography.html#id285" title="C. H. Tong. The PSUADE software library. Web site, 2005. http://www.llnl.gov/CASC/uncertainty_quantification/#psuade.">Ton05</a>]</span>. Dakota
includes a prototype interface to its Morris One-At-A-Time (MOAT)
screening method, a valuable tool for global sensitivity (including
interaction) analysis.</p>
<p>The Morris One-At-A-Time method, originally proposed by M. D.
Morris <span id="id10">[<a class="reference internal" href="../../misc/bibliography.html#id204" title="M. D. Morris. Factorial sampling plans for preliminary computational experiments. Technometrics, 33(2):161–174, 1991.">Mor91</a>]</span>, is a screening method, designed to
explore a computational model to distinguish between input variables
that have negligible, linear and additive, or nonlinear or interaction
effects on the output. The computer experiments performed consist of
individually randomized designs which vary one input factor at a time to
create a sample of its elementary effects.</p>
<p>With MOAT, each dimension of a <span class="math notranslate nohighlight">\(k-\)</span>dimensional input space is
uniformly partitioned into <span class="math notranslate nohighlight">\(p\)</span> levels, creating a grid of
<span class="math notranslate nohighlight">\(p^k\)</span> points <span class="math notranslate nohighlight">\({\bf x} \in \mathbb{R}^k\)</span> at which evaluations
of the model <span class="math notranslate nohighlight">\(y({\bf
x})\)</span> might take place. An elementary effect corresponding to input
<span class="math notranslate nohighlight">\(i\)</span> is computed by a forward difference</p>
<div class="math notranslate nohighlight">
\[d_i({\bf x}) = \frac{y({\bf x} + \Delta {\bf e}_i) - y({\bf x})}{\Delta},\]</div>
<p>where <span class="math notranslate nohighlight">\(e_i\)</span> is the <span class="math notranslate nohighlight">\(i^{\mbox{th}}\)</span> coordinate
vector, and the step <span class="math notranslate nohighlight">\(\Delta\)</span> is typically taken to be large (this
is not intended to be a local derivative approximation). In the present
implementation of MOAT, for an input variable scaled to <span class="math notranslate nohighlight">\([0,1]\)</span>,
<span class="math notranslate nohighlight">\(\Delta = \frac{p}{2(p-1)}\)</span>, so the step used to find elementary
effects is slightly larger than half the input range.</p>
<p>The distribution of elementary effects <span class="math notranslate nohighlight">\(d_i\)</span> over the input space
characterizes the effect of input <span class="math notranslate nohighlight">\(i\)</span> on the output of interest.
After generating <span class="math notranslate nohighlight">\(r\)</span> samples from this distribution, their mean,</p>
<div class="math notranslate nohighlight">
\[\mu_i = \frac{1}{r}\sum_{j=1}^{r}{d_i^{(j)}},\]</div>
<p>modified mean</p>
<div class="math notranslate nohighlight">
\[\mu_i^* = \frac{1}{r}\sum_{j=1}^{r}{|d_i^{(j)}|},\]</div>
<p>(using absolute value) and standard deviation</p>
<div class="math notranslate nohighlight">
\[\sigma_i = \sqrt{ \frac{1}{r}\sum_{j=1}^{r}{ \left(d_i^{(j)} - \mu_i
\right)^2} }\]</div>
<p>are computed for each input <span class="math notranslate nohighlight">\(i\)</span>. The mean and modified mean give
an indication of the overall effect of an input on the output. Standard
deviation indicates nonlinear effects or interactions, since it is an
indicator of elementary effects varying throughout the input space.</p>
<p>The MOAT method is selected with method keyword <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-psuade_moat.html"><span class="pre">psuade_moat</span></a></code> as shown
in the sample Dakota input file <a class="reference internal" href="#fig-moat-input"><span class="std std-numref">Listing 33</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-moat-input">
<div class="code-block-caption"><span class="caption-number">Listing 33 </span><span class="caption-text">Dakota input file showing the Morris One-at-a-Time method
– see <code class="docutils literal notranslate"><span class="pre">dakota/share/dakota/examples/users/morris_ps_moat.in</span></code></span><a class="headerlink" href="#fig-moat-input" title="Link to this code"></a></div>
<div class="highlight-dakota notranslate"><div class="highlight"><pre><span></span><span class="c"># Dakota Input File: morris_ps_moat.in</span>

<span class="k">environment</span>
  tabular_data
    tabular_data_file &#39;dakota_psuade.0.dat&#39;

<span class="k">method</span>
  psuade_moat
    samples = 84
    partitions = 3
    seed = 500

<span class="k">variables</span>
  continuous_design = 20
    lower_bounds = 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
                   0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
    upper_bounds = 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
                   1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0

<span class="k">interface</span>
  analysis_drivers = &#39;morris&#39;
    fork
  asynchronous evaluation_concurrency = 5

<span class="k">responses</span>
  objective_functions = 1
  no_gradients
  no_hessians
</pre></div>
</div>
</div>
<p>The number of <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-psuade_moat-samples.html"><span class="pre">samples</span></a></code> must be a positive integer multiple of (number of
continuous design variables <span class="math notranslate nohighlight">\(k\)</span> + 1) and will be automatically
adjusted if misspecified. The number of <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-psuade_moat-partitions.html"><span class="pre">partitions</span></a></code>
applies to each variable being studied and must be odd (the number of
MOAT levels <span class="math notranslate nohighlight">\(p\)</span> per variable is partitions + 1, similar to Dakota
multidimensional parameter studies). This will also be adjusted at
runtime as necessary. Finite user-specified lower and upper bounds are
required and will be scaled as needed by the method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For more information on the use of MOAT sampling, see <a class="reference internal" href="../examples/additionalexamples.html#additional-morris"><span class="std std-ref">this Morris example</span></a>,
or Saltelli, et al. <span id="id11">[<a class="reference internal" href="../../misc/bibliography.html#id257" title="A. Saltelli, S. Tarantola, F. Campolongo, and M. Ratto. Sensitivity Analysis in Practice: A Guide to Assessing Scientific Models. John Wiley &amp; Sons, 2004.">STCR04</a>]</span>.</p>
</div>
</section>
<section id="sensitivity-analysis">
<span id="dace-sa"></span><h2>Sensitivity Analysis<a class="headerlink" href="#sensitivity-analysis" title="Link to this heading"></a></h2>
<section id="sensitivity-analysis-overview">
<span id="dace-sa-overview"></span><h3>Sensitivity Analysis Overview<a class="headerlink" href="#sensitivity-analysis-overview" title="Link to this heading"></a></h3>
<p>In many engineering design applications, sensitivity analysis techniques
and parameter study methods are useful in identifying which of the
design parameters have the most influence on the response quantities.
This information is helpful prior to an optimization study as it can be
used to remove design parameters that do not strongly influence the
responses. In addition, these techniques can provide assessments as to
the behavior of the response functions (smooth or nonsmooth, unimodal or
multimodal) which can be invaluable in algorithm selection for
optimization, uncertainty quantification, and related methods. In a
post-optimization role, sensitivity information is useful is determining
whether or not the response functions are robust with respect to small
changes in the optimum design point.</p>
<p>In some instances, the term sensitivity analysis is used in a local
sense to denote the computation of response derivatives at a point.
These derivatives are then used in a simple analysis to make design
decisions. Dakota supports this type of study through numerical
finite-differencing or retrieval of analytic gradients computed within
the analysis code. The desired gradient data is specified in the
responses section of the Dakota input file and the collection of this
data at a single point is accomplished through a parameter study method
with no steps. This approach to sensitivity analysis should be
distinguished from the activity of augmenting analysis codes to
internally compute derivatives using techniques such as direct or
adjoint differentiation, automatic differentiation (e.g., ADIFOR), or
complex step modifications. These sensitivity augmentation activities
are completely separate from Dakota and are outside the scope of this
manual. However, once completed, Dakota can utilize these analytic
gradients to perform optimization, uncertainty quantification, and
related studies more reliably and efficiently.</p>
<p>In other instances, the term sensitivity analysis is used in a more
global sense to denote the investigation of variability in the response
functions. Dakota supports this type of study through computation of
response data sets (typically function values only, but all data sets
are supported) at a series of points in the parameter space. The series
of points is defined using either a vector, list, centered, or
multidimensional parameter study method. For example, a set of
closely-spaced points in a vector parameter study could be used to
assess the smoothness of the response functions in order to select a
finite difference step size, and a set of more widely-spaced points in a
centered or multidimensional parameter study could be used to determine
whether the response function variation is likely to be unimodal or
multimodal. See <a class="reference internal" href="parameterstudies.html#ps"><span class="std std-ref">Parameter Studies Capabilities</span></a> for additional information on
these methods. These more global approaches to sensitivity analysis can
be used to obtain trend data even in situations when gradients are
unavailable or unreliable, and they are conceptually similar to the
design of experiments methods and sampling approaches to uncertainty
quantification described in the following sections.</p>
</section>
<section id="assessing-sensitivity-with-dace">
<span id="dace-sa-assessing"></span><h3>Assessing Sensitivity with DACE<a class="headerlink" href="#assessing-sensitivity-with-dace" title="Link to this heading"></a></h3>
<p>Like <a class="reference internal" href="parameterstudies.html#ps"><span class="std std-ref">parameter studies</span></a>, the DACE techniques
are useful for characterizing the behavior of the response functions of
interest through the parameter ranges of interest. In addition to direct
interrogation and visualization of the sampling results, a number of
techniques have been developed for assessing the parameters which are
most influential in the observed variability in the response functions.
One example of this is the well-known technique of scatter plots, in
which the set of samples is projected down and plotted against one
parameter dimension, for each parameter in turn. Scatter plots with a
uniformly distributed cloud of points indicate parameters with little
influence on the results, whereas scatter plots with a defined shape to
the cloud indicate parameters which are more significant. Related
techniques include analysis of variance
(ANOVA) <span id="id12">[<a class="reference internal" href="../../misc/bibliography.html#id205" title="R. H. Myers and D. C. Montgomery. Response Surface Methodology: Process and Product Optimization Using Designed Experiments. John Wiley &amp; Sons, Inc., New York, 1995.">MM95</a>]</span> and main effects analysis, in which
the parameters which have the greatest influence on the results are
identified from sampling results. Scatter plots and ANOVA may be
accessed through <a class="reference internal" href="../output/tabulardata.html#output-tabular"><span class="std std-ref">import of Dakota tabular results</span></a> into external
statistical analysis programs such as S-plus, Minitab, etc.</p>
<p>Running any of the design of experiments or sampling methods allows the
user to save the results in a tabular data file, which then can be read
into a spreadsheet or statistical package for further analysis. In
addition, we have provided some functions to help determine the most
important variables.</p>
<p>We take the definition of uncertainty analysis
from <span id="id13">[<a class="reference internal" href="../../misc/bibliography.html#id257" title="A. Saltelli, S. Tarantola, F. Campolongo, and M. Ratto. Sensitivity Analysis in Practice: A Guide to Assessing Scientific Models. John Wiley &amp; Sons, 2004.">STCR04</a>]</span>: “The study of how uncertainty in the
output of a model can be apportioned to different sources of uncertainty
in the model input.”</p>
<p>As a default, Dakota provides correlation analyses when running LHS.
Correlation tables are printed with the simple, partial, and rank
correlations between inputs and outputs. These can be useful to get a
quick sense of how correlated the inputs are to each other, and how
correlated various outputs are to inputs. The correlation analyses are
explained further in <a class="reference internal" href="uq.html#uq-sampling"><span class="std std-ref">the sampling section</span></a>.</p>
<p>We also have the capability to calculate sensitivity indices through
Variance-based Decomposition (VBD). Variance-based decomposition is a
global sensitivity method that summarizes how the uncertainty in model
output can be apportioned to uncertainty in individual input variables.
VBD uses two primary measures, the main effect sensitivity index
<span class="math notranslate nohighlight">\(S_{i}\)</span> and the total effect index <span class="math notranslate nohighlight">\(T_{i}\)</span>. The main effect
sensitivity index corresponds to the fraction of the uncertainty in the
output, <span class="math notranslate nohighlight">\(Y\)</span>, that can be attributed to input <span class="math notranslate nohighlight">\(x_{i}\)</span> alone.
The total effects index corresponds to the fraction of the uncertainty
in the output, <span class="math notranslate nohighlight">\(Y\)</span>, that can be attributed to input <span class="math notranslate nohighlight">\(x_{i}\)</span>
and its interactions with other variables. The main effect sensitivity
index compares the variance of the conditional expectation
<span class="math notranslate nohighlight">\(Var_{x_{i}}[E(Y|x_{i})]\)</span> against the total variance
<span class="math notranslate nohighlight">\(Var(Y)\)</span>. Formulas for the indices are:</p>
<div class="math notranslate nohighlight">
\[S_{i}=\frac{Var_{x_{i}}[E(Y|x_{i})]}{Var(Y)} \label{eq:VBD_Si}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[T_{i}=\frac{E(Var(Y|x_{-i}))}{Var(Y)}=\frac{Var(Y)-Var(E[Y|x_{-i}])}{Var(Y)} \label{eq:VBD_Ti}\]</div>
<p>where <span class="math notranslate nohighlight">\(Y=f({\bf x})\)</span> and
<span class="math notranslate nohighlight">\({x_{-i}=(x_{1},...,x_{i-1},x_{i+1},...,x_{m})}\)</span>.</p>
<p>The calculation of <span class="math notranslate nohighlight">\(S_{i}\)</span> and <span class="math notranslate nohighlight">\(T_{i}\)</span> requires the
evaluation of m-dimensional integrals which are typically approximated
by Monte-Carlo sampling. More details on the calculations and
interpretation of the sensitivity indices can be found
in <span id="id14">[<a class="reference internal" href="../../misc/bibliography.html#id257" title="A. Saltelli, S. Tarantola, F. Campolongo, and M. Ratto. Sensitivity Analysis in Practice: A Guide to Assessing Scientific Models. John Wiley &amp; Sons, 2004.">STCR04</a>]</span>. In Dakota version 5.1, we have improved
calculations for the calculation of the <span class="math notranslate nohighlight">\(S_{i}\)</span> and <span class="math notranslate nohighlight">\(T_{i}\)</span>
indices when using sampling. The implementation details of these
calculatiosn are provided in <span id="id15">[<a class="reference internal" href="../../misc/bibliography.html#id300" title="V. G. Weirs, J. R. Kamm, L. P. Swiler, M. Ratto, S. Tarantola, B. M. Adams, W. J. Rider, and M. S Eldred. Sensitivity analysis techniques applied to a system of hyperbolic conservation laws. Reliability Engineering and System Safety, 107:157–170, 2012.">WKS+12</a>]</span>. VBD can be
specified for any of the sampling or DACE methods using the command
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-variance_based_decomp.html"><span class="pre">variance_based_decomp</span></a></code>. Note that VBD is extremely
computationally intensive when using sampling since replicated sets of
sample values are evaluated. If the user specified a number of samples,
<span class="math notranslate nohighlight">\(N\)</span>, and a number of nondeterministic variables, <span class="math notranslate nohighlight">\(M\)</span>,
variance-based decomposition requires the evaluation of <span class="math notranslate nohighlight">\(N(M+2)\)</span>
samples. To obtain sensitivity indices that are reasonably accurate, we
recommend that <span class="math notranslate nohighlight">\(N\)</span>, the number of samples, be at least one hundred
and preferably several hundred or thousands. Because of the
computational cost, variance-based decomposition is turned off as a
default for sampling or DACE. Another alternative, however, is to obtain
these indices using <a class="reference internal" href="uq.html#uq-expansion"><span class="std std-ref">one of the stochastic expansion methods</span></a>. The calculation of the
indices using expansion methods is much more efficient since the VBD
indices are analytic functions of the coefficients in the stochastic
expansion. The paper by Weirs et al. <span id="id16">[<a class="reference internal" href="../../misc/bibliography.html#id300" title="V. G. Weirs, J. R. Kamm, L. P. Swiler, M. Ratto, S. Tarantola, B. M. Adams, W. J. Rider, and M. S Eldred. Sensitivity analysis techniques applied to a system of hyperbolic conservation laws. Reliability Engineering and System Safety, 107:157–170, 2012.">WKS+12</a>]</span>
compares different methods for calculating the sensitivity indices for
nonlinear problems with significant interaction effects.</p>
<p>In terms of interpretation of the sensitivity indices, a larger value of
the sensitivity index, <span class="math notranslate nohighlight">\(S_{i}\)</span>, means that the uncertainty in the
input variable <span class="math notranslate nohighlight">\(i\)</span> has a larger effect on the variance of the
output. Note that the sum of the main effect indices will be less than
or equal to one. If the sum of the main effect indices is much less than
one, it indicates that there are significant two-way, three-way, or
higher order interactions that contribute significantly to the variance.
There is no requirement that the sum of the total effect indices is one:
in most cases, the sum of the total effect indices will be greater than
one. An example of the Main and Total effects indices as calculated by
Dakota using sampling is shown in the following spinnet of Dakota output:</p>
<div class="highlight-dakota notranslate"><div class="highlight"><pre><span></span>Global sensitivity indices for each response function:
response_fn_1 Sobol indices:
                                    Main             Total
                        4.7508913283e-01  5.3242162037e-01 uuv_1
                        3.8112392892e-01  4.9912486515e-01 uuv_2
</pre></div>
</div>
<p>Finally, we have the capability to calculate a set of quality metrics
for a particular input sample. These quality metrics measure various
aspects relating to the volumetric spacing of the samples: are the
points equally spaced, do they cover the region, are they isotropically
distributed, do they have directional bias, etc.? The quality metrics
are explained in more detail in the Reference Manual.</p>
</section>
</section>
<section id="doe-usage-guidelines">
<span id="dace-usage"></span><h2>DOE Usage Guidelines<a class="headerlink" href="#doe-usage-guidelines" title="Link to this heading"></a></h2>
<p>Parameter studies, classical design of experiments (DOE),
design/analysis of computer experiments (DACE), and sampling methods
share the purpose of exploring the parameter space. When a global
space-filling set of samples is desired, then the DOE, DACE, and
sampling methods are recommended. These techniques are useful for
scatter plot and variance analysis as well as surrogate model
construction.</p>
<p>The distinction between DOE and DACE methods is that the former are
intended for physical experiments containing an element of
nonrepeatability (and therefore tend to place samples at the extreme
parameter vertices), whereas the latter are intended for repeatable
computer experiments and are more space-filling in nature.</p>
<p>The distinction between DOE/DACE and sampling is drawn based on the
distributions of the parameters. DOE/DACE methods typically assume
uniform distributions, whereas the sampling approaches in Dakota support
a broad range of probability distributions.</p>
<p>To use <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-sampling.html"><span class="pre">sampling</span></a></code> in design of experiments mode (as opposed to
uncertainty quantification mode), an active view override (e.g.,
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/variables-active.html"><span class="pre">active</span></a></code> <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/variables-active-all.html"><span class="pre">all</span></a></code>) can be included in the variables specification (see
<a class="reference internal" href="../inputfile/variables.html#variables-mixedview"><span class="std std-ref">“Management of Mixed Variables by Iterator”</span></a>) of the Dakota
input file.</p>
<p>Design of experiments method selection recommendations are summarized in <a class="reference internal" href="#dace-usage-table"><span class="std std-numref">Table 6</span></a>:</p>
<table class="docutils align-center" id="dace-usage-table">
<caption><span class="caption-number">Table 6 </span><span class="caption-text"><em>Guidelines for selection of parameter study, DOE, DACE, and sampling methods.</em></span><a class="headerlink" href="#dace-usage-table" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Method Classification</p></th>
<th class="head"><p>Applications</p></th>
<th class="head"><p>Applicable Methods</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>parameter study</p></td>
<td><p>sensitivity analysis,
directed parameter
space investigations</p></td>
<td><p><code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-centered_parameter_study.html"><span class="pre">centered_parameter_study</span></a></code>,
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-list_parameter_study.html"><span class="pre">list_parameter_study</span></a></code>,
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-multidim_parameter_study.html"><span class="pre">multidim_parameter_study</span></a></code>,
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-vector_parameter_study.html"><span class="pre">vector_parameter_study</span></a></code></p></td>
</tr>
<tr class="row-odd"><td><p>classical design
of experiments</p></td>
<td><p>physical experiments
(parameters are
uniformly
distributed)</p></td>
<td><p><code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace.html"><span class="pre">dace</span></a></code> (<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-box_behnken.html"><span class="pre">box_behnken</span></a></code>,
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-central_composite.html"><span class="pre">central_composite</span></a></code>)</p></td>
</tr>
<tr class="row-even"><td><p>design of computer
experiments</p></td>
<td><p>variance analysis,
space filling design
(parameters are
uniformly distributed)</p></td>
<td><p><code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace.html"><span class="pre">dace</span></a></code> (<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-grid.html"><span class="pre">grid</span></a></code>,
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-random.html"><span class="pre">random</span></a></code>, <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-oas.html"><span class="pre">oas</span></a></code>
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-lhs.html"><span class="pre">lhs</span></a></code>, <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-dace-oa_lhs.html"><span class="pre">oa_lhs</span></a></code>),
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-fsu_quasi_mc.html"><span class="pre">fsu_quasi_mc</span></a></code>
(<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-fsu_quasi_mc-halton.html"><span class="pre">halton</span></a></code>,
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-fsu_quasi_mc-hammersley.html"><span class="pre">hammersley</span></a></code>),
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-fsu_cvt.html"><span class="pre">fsu_cvt</span></a></code>, <code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-psuade_moat.html"><span class="pre">psuade_moat</span></a></code></p></td>
</tr>
<tr class="row-odd"><td><p>sampling</p></td>
<td><p>space filling designs
(parameters have
general probability
distributions)</p></td>
<td><p><code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-sampling.html"><span class="pre">sampling</span></a></code>
(<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-sampling-sample_type-random.html"><span class="pre">random</span></a></code> or
<code class="docutils literal notranslate"><a class="reference external" href="../../usingdakota/reference/method-sampling-sample_type-lhs.html"><span class="pre">lhs</span></a></code>) with optional active view
override</p></td>
</tr>
</tbody>
</table>
</section>
<section id="video-resources">
<h2>Video Resources<a class="headerlink" href="#video-resources" title="Link to this heading"></a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Title</p></th>
<th class="head"><p>Link</p></th>
<th class="head"><p>Resources</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Sensitivity Analysis</p></td>
<td><p><a class="reference external" href="https://digitalops.sandia.gov/Mediasite/Play/e273e948e94a4f4a9fbdd385c1ef4c8a1d"><img alt="Sensitivity Analysis" src="../../_images/SensitivityAnalysisTrainingTeaser.png" /></a></p></td>
<td><p><a class="reference external" href="https://dakota.sandia.gov/sites/default/files/training/DakotaTraining_SensitivityAnalysis.pdf">Slides</a> /
<a class="reference external" href="https://dakota.sandia.gov/sites/default/files/training/sens_analysis-220216.zip">Exercises</a></p></td>
</tr>
<tr class="row-odd"><td><p>Introduction to Sensitivity Analysis</p></td>
<td><p><a class="reference external" href="https://www.youtube.com/watch?v=YshRCgm_f1Y"><img alt="Introduction to Sensitivity Analysis" src="../../_images/SensitivityAnalysisScreencastTeaser.png" /></a></p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="parameterstudies.html" class="btn btn-neutral float-left" title="Parameter Studies" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="uq.html" class="btn btn-neutral float-right" title="Uncertainty Quantification" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <!--
  <div role="contentinfo">
    <p>&#169; Copyright 2024, Sandia National Laboratories.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
  --> 

</footer>
        </div>
      </div>
	  
	  <div style="background-color: #0f0f0f;color:#fafafa;padding:20px">
	    <div>
		  <h2><em>Exceptional service in the national interest</em></h2>
		</div>
		<p>© 2023 National Technology and Engineering Solutions of Sandia, LLC. | <a href="https://www.sandia.gov/contact_us/index.html">Questions &amp; Comments</a> | <a href="https://www.sandia.gov/general/privacy-security/index.html">Privacy &amp; Security</a></p>
		<p><a href="http://energy.gov" rel="noopener noreferrer" target="_blank"><img alt="U.S. Department of Energy" longdesc="https://energy.gov" src="https://www.sandia.gov/_common/images/doe_logo_white.png" style="height:37px; width:140px"></a> <a href="http://nnsa.energy.gov/" rel="noopener noreferrer" target="_blank"> <img alt="National Nuclear Security Administration" longdesc="http://nnsa.gov" src="https://www.sandia.gov/_common/images/nnsa_logo_white.png" style="height:37px; width:116px"></a></p>
		<p><a href="https://www.sandia.gov">Sandia National Laboratories</a> is a multimission laboratory managed and operated by National Technology and Engineering Solutions of Sandia, LLC., a wholly owned subsidiary of Honeywell International, Inc., for the U.S. Department of Energy’s National Nuclear Security Administration under contract DE-NA-0003525.</p>
	  </div>	  	  
	  
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>