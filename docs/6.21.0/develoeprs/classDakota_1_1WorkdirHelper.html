<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Dakota Developers Manual" />
<meta name="keywords" content="optimization, uncertainty quantification, model calibration, parameter estimation, sensitivity analysis, parallel computing, developers manual" />
<meta name="sandia.approval_type" content="formal" />
<meta name="sandia.approved" content="2010-2185" />
<link rev="owns" title="Brian M. Adams" href="mailto:briadam@sandia.gov" />
<meta name="Author" content="Brian M. Adams" />
<title>Dakota: WorkdirHelper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DAKOTA_Arrow_Name_77x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dakota
   &#160;<span id="projectnumber">Version 6.21</span>
   </div>
   <div id="projectbrief">Explore and Predict with Confidence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDakota.html">Dakota</a></li><li class="navelem"><a class="el" href="classDakota_1_1WorkdirHelper.html">WorkdirHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classDakota_1_1WorkdirHelper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WorkdirHelper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a25a40b6614565f755233080a384c35f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a25a40b6614565f755233080a384c35f1">initialize</a> ()</td></tr>
<tr class="memdesc:a25a40b6614565f755233080a384c35f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize (at runtime) cached values for paths and environment  <a href="classDakota_1_1WorkdirHelper.html#a25a40b6614565f755233080a384c35f1">More...</a><br /></td></tr>
<tr class="separator:a25a40b6614565f755233080a384c35f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f470f21ac1ac679afe018fc84f53a4"><td class="memItemLeft" align="right" valign="top"><a id="a13f470f21ac1ac679afe018fc84f53a4"></a>
static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a13f470f21ac1ac679afe018fc84f53a4">startup_pwd</a> ()</td></tr>
<tr class="memdesc:a13f470f21ac1ac679afe018fc84f53a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for dakota's startup $PWD. <br /></td></tr>
<tr class="separator:a13f470f21ac1ac679afe018fc84f53a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b87b3beeccbcd500e51f6c98f3636a2"><td class="memItemLeft" align="right" valign="top"><a id="a2b87b3beeccbcd500e51f6c98f3636a2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a2b87b3beeccbcd500e51f6c98f3636a2">change_directory</a> (const bfs::path &amp;new_dir)</td></tr>
<tr class="memdesc:a2b87b3beeccbcd500e51f6c98f3636a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">change current directory <br /></td></tr>
<tr class="separator:a2b87b3beeccbcd500e51f6c98f3636a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd9589e642f69e9e64327646c1f7aaf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a7dd9589e642f69e9e64327646c1f7aaf">prepend_preferred_env_path</a> (const std::string &amp;extra_path)</td></tr>
<tr class="memdesc:a7dd9589e642f69e9e64327646c1f7aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend cached preferredEnvPath with extra_path and update $PATH environment variable.  <a href="classDakota_1_1WorkdirHelper.html#a7dd9589e642f69e9e64327646c1f7aaf">More...</a><br /></td></tr>
<tr class="separator:a7dd9589e642f69e9e64327646c1f7aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf010510f9412178910bacde7e6c3bc"><td class="memItemLeft" align="right" valign="top"><a id="a4cf010510f9412178910bacde7e6c3bc"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a4cf010510f9412178910bacde7e6c3bc">set_environment</a> (const std::string &amp;env_name, const std::string &amp;env_val, bool overwrite_flag=true)</td></tr>
<tr class="memdesc:a4cf010510f9412178910bacde7e6c3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an environment variable. <br /></td></tr>
<tr class="separator:a4cf010510f9412178910bacde7e6c3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269e5ea44cc5a95290d6e67374b55a7f"><td class="memItemLeft" align="right" valign="top">static bfs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a269e5ea44cc5a95290d6e67374b55a7f">which</a> (const std::string &amp;driver_name)</td></tr>
<tr class="memdesc:a269e5ea44cc5a95290d6e67374b55a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bfs::path for the analysis driver, supporting typical windows filename extensions, or empty if not found.  <a href="classDakota_1_1WorkdirHelper.html#a269e5ea44cc5a95290d6e67374b55a7f">More...</a><br /></td></tr>
<tr class="separator:a269e5ea44cc5a95290d6e67374b55a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78adf5d7a16fbd88f70dd9f0757cf69c"><td class="memItemLeft" align="right" valign="top"><a id="a78adf5d7a16fbd88f70dd9f0757cf69c"></a>
static bfs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a78adf5d7a16fbd88f70dd9f0757cf69c">rel_to_abs</a> (const bfs::path &amp;subdir_path)</td></tr>
<tr class="memdesc:a78adf5d7a16fbd88f70dd9f0757cf69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a valid absolute bfs::path to a subdirectory relative to rundir <br /></td></tr>
<tr class="separator:a78adf5d7a16fbd88f70dd9f0757cf69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1234a920d638ce898187ef60a57575"><td class="memItemLeft" align="right" valign="top"><a id="a9f1234a920d638ce898187ef60a57575"></a>
static StringArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a9f1234a920d638ce898187ef60a57575">tokenize_driver</a> (const String &amp;user_an_driver)</td></tr>
<tr class="memdesc:a9f1234a920d638ce898187ef60a57575"><td class="mdescLeft">&#160;</td><td class="mdescRight">tokenize a white-space separated analysis driver, respecting escapes and nested quotes <br /></td></tr>
<tr class="separator:a9f1234a920d638ce898187ef60a57575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8263383607f93e7a192e97cf24d1dd"><td class="memItemLeft" align="right" valign="top"><a id="a6c8263383607f93e7a192e97cf24d1dd"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a6c8263383607f93e7a192e97cf24d1dd">resolve_driver_path</a> (String &amp;an_driver)</td></tr>
<tr class="memdesc:a6c8263383607f93e7a192e97cf24d1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse off the first whitespace-separated entry in the user's analysis_driver, and convert it to an absolute path if it begins with ./ or ../, replacing the passed string if needed. Returns true if the first token was modified. <br /></td></tr>
<tr class="separator:a6c8263383607f93e7a192e97cf24d1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540f289e775a1111ac785200ce89f08c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a540f289e775a1111ac785200ce89f08c">split_wildcard</a> (const std::string &amp;path_with_wc, bfs::path &amp;search_dir, bfs::path &amp;wild_card)</td></tr>
<tr class="memdesc:a540f289e775a1111ac785200ce89f08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a string with an optional path and a wildcard, e.g., /tmp/D*.?pp, parse it into the search path /tmp (default .) and the wildcard D*.?pp. Return wild_card as path to reduce wstring conversions  <a href="classDakota_1_1WorkdirHelper.html#a540f289e775a1111ac785200ce89f08c">More...</a><br /></td></tr>
<tr class="separator:a540f289e775a1111ac785200ce89f08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d6553d1e0f3fa14eee369f96afee1a"><td class="memItemLeft" align="right" valign="top">static bfs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a70d6553d1e0f3fa14eee369f96afee1a">concat_path</a> (const bfs::path &amp;p_in, const String &amp;tag)</td></tr>
<tr class="memdesc:a70d6553d1e0f3fa14eee369f96afee1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate a string onto the end of a path  <a href="classDakota_1_1WorkdirHelper.html#a70d6553d1e0f3fa14eee369f96afee1a">More...</a><br /></td></tr>
<tr class="separator:a70d6553d1e0f3fa14eee369f96afee1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cea93c2884f90c5153a34d7f195e62"><td class="memItemLeft" align="right" valign="top"><a id="ad7cea93c2884f90c5153a34d7f195e62"></a>
static bfs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#ad7cea93c2884f90c5153a34d7f195e62">system_tmp_file</a> (const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ad7cea93c2884f90c5153a34d7f195e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a valid temporary file name prefix_%%%%%%%% <br /></td></tr>
<tr class="separator:ad7cea93c2884f90c5153a34d7f195e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73623a58748a90e330b3ceed7d74dd6"><td class="memItemLeft" align="right" valign="top"><a id="ad73623a58748a90e330b3ceed7d74dd6"></a>
static bfs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#ad73623a58748a90e330b3ceed7d74dd6">system_tmp_path</a> ()</td></tr>
<tr class="memdesc:ad73623a58748a90e330b3ceed7d74dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the system tmp path, e.g., /tmp or C:\temp <br /></td></tr>
<tr class="separator:ad73623a58748a90e330b3ceed7d74dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3947928c1020edd7da1a0551850b6618"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a3947928c1020edd7da1a0551850b6618">create_directory</a> (const bfs::path &amp;dir_path, short mkdir_option)</td></tr>
<tr class="memdesc:a3947928c1020edd7da1a0551850b6618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory, with options for remove or error.  <a href="classDakota_1_1WorkdirHelper.html#a3947928c1020edd7da1a0551850b6618">More...</a><br /></td></tr>
<tr class="separator:a3947928c1020edd7da1a0551850b6618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3703a85a4a91bd12b2980f6b3be54f39"><td class="memItemLeft" align="right" valign="top"><a id="a3703a85a4a91bd12b2980f6b3be54f39"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a3703a85a4a91bd12b2980f6b3be54f39">recursive_remove</a> (const bfs::path &amp;rm_path, short fileop_option)</td></tr>
<tr class="memdesc:a3703a85a4a91bd12b2980f6b3be54f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a path (file, directory, or symlink) without regard to its type. Only error if existed and there's an error in the remove. <br /></td></tr>
<tr class="separator:a3703a85a4a91bd12b2980f6b3be54f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df5943ac37c09af9be8fa8ca20fa4f8"><td class="memItemLeft" align="right" valign="top"><a id="a0df5943ac37c09af9be8fa8ca20fa4f8"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a0df5943ac37c09af9be8fa8ca20fa4f8">rename</a> (const bfs::path &amp;old_path, const bfs::path &amp;new_path, short fileop_option)</td></tr>
<tr class="memdesc:a0df5943ac37c09af9be8fa8ca20fa4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a file, catching any errors and optionally warning/erroring. <br /></td></tr>
<tr class="separator:a0df5943ac37c09af9be8fa8ca20fa4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94db58ea89faabd637bed61a4f51b01"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#ad94db58ea89faabd637bed61a4f51b01">link_items</a> (const StringArray &amp;source_itemss, const bfs::path &amp;dest_dir, bool overwrite)</td></tr>
<tr class="memdesc:ad94db58ea89faabd637bed61a4f51b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">top-level link a list of source_paths (files, directories, symlinks), potentially including wildcards, from destination_dir, which must exist  <a href="classDakota_1_1WorkdirHelper.html#ad94db58ea89faabd637bed61a4f51b01">More...</a><br /></td></tr>
<tr class="separator:ad94db58ea89faabd637bed61a4f51b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613139dbef2aeaae4ef8caceca6aad62"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a613139dbef2aeaae4ef8caceca6aad62">copy_items</a> (const StringArray &amp;source_items, const bfs::path &amp;dest_dir, bool overwrite)</td></tr>
<tr class="memdesc:a613139dbef2aeaae4ef8caceca6aad62"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy a list of source_paths (files, directories, symlinks), potentially including wildcards into destination_dir, which must exist  <a href="classDakota_1_1WorkdirHelper.html#a613139dbef2aeaae4ef8caceca6aad62">More...</a><br /></td></tr>
<tr class="separator:a613139dbef2aeaae4ef8caceca6aad62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50f15224f6934edb9eca54b67ac3e39"><td class="memItemLeft" align="right" valign="top"><a id="ab50f15224f6934edb9eca54b67ac3e39"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#ab50f15224f6934edb9eca54b67ac3e39">prepend_path_items</a> (const StringArray &amp;source_items)</td></tr>
<tr class="memdesc:ab50f15224f6934edb9eca54b67ac3e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepend any directories (including wildcards) found in source_items to the preferred environment path; this will update cached preferred path and PATH <br /></td></tr>
<tr class="separator:ab50f15224f6934edb9eca54b67ac3e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc0e542153367dbb712c2826dc6f753"><td class="memItemLeft" align="right" valign="top"><a id="a2bc0e542153367dbb712c2826dc6f753"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a2bc0e542153367dbb712c2826dc6f753">check_equivalent_dest</a> (const StringArray &amp;source_items, const bfs::path &amp;dest_dir)</td></tr>
<tr class="memdesc:a2bc0e542153367dbb712c2826dc6f753"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether any of the passed source items are filesystem equivalent to the destination path, return true if any one is equivalent to dest <br /></td></tr>
<tr class="separator:a2bc0e542153367dbb712c2826dc6f753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4d53f89dd1f5b1827aad3168669390"><td class="memItemLeft" align="right" valign="top"><a id="a9b4d53f89dd1f5b1827aad3168669390"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a9b4d53f89dd1f5b1827aad3168669390">find_driver</a> (const StringArray &amp;source_items, const bfs::path &amp;search_driver)</td></tr>
<tr class="memdesc:a9b4d53f89dd1f5b1827aad3168669390"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the any of the passed source items (possibly including wildcards to be expanded) matches the passed search driver <br /></td></tr>
<tr class="separator:a9b4d53f89dd1f5b1827aad3168669390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5754e8b32715956c15b31fd010ca57d5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a5754e8b32715956c15b31fd010ca57d5">link</a> (const bfs::path &amp;src_path, const bfs::path &amp;dest_dir, bool overwrite)</td></tr>
<tr class="memdesc:a5754e8b32715956c15b31fd010ca57d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create link from dest_dir/src_path.filename() to a single path (file, dir, link) in source directory  <a href="classDakota_1_1WorkdirHelper.html#a5754e8b32715956c15b31fd010ca57d5">More...</a><br /></td></tr>
<tr class="separator:a5754e8b32715956c15b31fd010ca57d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5225a89b04b3665af4597d10dc81892"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#af5225a89b04b3665af4597d10dc81892">recursive_copy</a> (const bfs::path &amp;src_path, const bfs::path &amp;dest_dir, bool overwrite)</td></tr>
<tr class="memdesc:af5225a89b04b3665af4597d10dc81892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recrusive copy of src_path into dest_dir, with optional top-level overwrite (remove/recreate) of dest_dir/src_path.filename()  <a href="classDakota_1_1WorkdirHelper.html#af5225a89b04b3665af4597d10dc81892">More...</a><br /></td></tr>
<tr class="separator:af5225a89b04b3665af4597d10dc81892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e10d8f4ec11cc4138a24996fd16f100"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a6e10d8f4ec11cc4138a24996fd16f100">prepend_path_item</a> (const bfs::path &amp;src_path, const bfs::path &amp;dest_dir, bool overwrite)</td></tr>
<tr class="memdesc:a6e10d8f4ec11cc4138a24996fd16f100"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepend the preferred env path with source path if it's a directory; this will update cached preferred path and manipulate PATH  <a href="classDakota_1_1WorkdirHelper.html#a6e10d8f4ec11cc4138a24996fd16f100">More...</a><br /></td></tr>
<tr class="separator:a6e10d8f4ec11cc4138a24996fd16f100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d01b6c6df9e55231dc4d750327f2862"><td class="memItemLeft" align="right" valign="top"><a id="a6d01b6c6df9e55231dc4d750327f2862"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a6d01b6c6df9e55231dc4d750327f2862">check_equivalent</a> (const bfs::path &amp;src_path, const bfs::path &amp;dest_dir, bool overwrite)</td></tr>
<tr class="memdesc:a6d01b6c6df9e55231dc4d750327f2862"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the src and dest are filesystem equivalent <br /></td></tr>
<tr class="separator:a6d01b6c6df9e55231dc4d750327f2862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9bf96e4492d8314768d1002bd9da64"><td class="memItemLeft" align="right" valign="top"><a id="a2a9bf96e4492d8314768d1002bd9da64"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a2a9bf96e4492d8314768d1002bd9da64">find_file</a> (const bfs::path &amp;src_path, const bfs::path &amp;search_file, bool overwrite)</td></tr>
<tr class="memdesc:a2a9bf96e4492d8314768d1002bd9da64"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the src_path is a regular file and has same filename as search_file <br /></td></tr>
<tr class="separator:a2a9bf96e4492d8314768d1002bd9da64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549e82d1d5f244e638ba5cd08226c5a7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a549e82d1d5f244e638ba5cd08226c5a7">file_op_items</a> (const <a class="el" href="namespaceDakota.html#a290b897fd6b50e6386330c2ed30090ca">file_op_function</a> &amp;file_op, const StringArray &amp;source_paths, const bfs::path &amp;dest_dir, bool overwrite)</td></tr>
<tr class="memdesc:a549e82d1d5f244e638ba5cd08226c5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively perform file_op (copy, path adjust, etc.) on a list of source_paths (files, directories, symlinks), which potentially include wildcards, w.r.t. destination_dir  <a href="classDakota_1_1WorkdirHelper.html#a549e82d1d5f244e638ba5cd08226c5a7">More...</a><br /></td></tr>
<tr class="separator:a549e82d1d5f244e638ba5cd08226c5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9364f8540902a8838cf4de27b49a191b"><td class="memItemLeft" align="right" valign="top"><a id="a9364f8540902a8838cf4de27b49a191b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a9364f8540902a8838cf4de27b49a191b">set_preferred_path</a> ()</td></tr>
<tr class="memdesc:a9364f8540902a8838cf4de27b49a191b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set/reset PATH to dakPreferredEnvPath <br /></td></tr>
<tr class="separator:a9364f8540902a8838cf4de27b49a191b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1957ac7a2b779a9e040cb1a20f9020"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a6e1957ac7a2b779a9e040cb1a20f9020">set_preferred_path</a> (const boost::filesystem::path &amp;extra_path)</td></tr>
<tr class="memdesc:a6e1957ac7a2b779a9e040cb1a20f9020"><td class="mdescLeft">&#160;</td><td class="mdescRight">set PATH to absolute(extra_path):dakPreferredEnvPath, without changing cached preferred PATH  <a href="classDakota_1_1WorkdirHelper.html#a6e1957ac7a2b779a9e040cb1a20f9020">More...</a><br /></td></tr>
<tr class="separator:a6e1957ac7a2b779a9e040cb1a20f9020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20897c5c8bd47f5d4005989bead0e55"><td class="memItemLeft" align="right" valign="top"><a id="ad20897c5c8bd47f5d4005989bead0e55"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#ad20897c5c8bd47f5d4005989bead0e55">reset</a> ()</td></tr>
<tr class="memdesc:ad20897c5c8bd47f5d4005989bead0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the working directory "state" to its initial state when DAKOTA was launched. <br /></td></tr>
<tr class="separator:ad20897c5c8bd47f5d4005989bead0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8ca1912efd7e30d7a5cbf1888e141fa7"><td class="memItemLeft" align="right" valign="top"><a id="a8ca1912efd7e30d7a5cbf1888e141fa7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a8ca1912efd7e30d7a5cbf1888e141fa7">WorkdirHelper</a> ()</td></tr>
<tr class="memdesc:a8ca1912efd7e30d7a5cbf1888e141fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:a8ca1912efd7e30d7a5cbf1888e141fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9a42d11203c056ac85bd83a1e50beb"><td class="memItemLeft" align="right" valign="top"><a id="a3f9a42d11203c056ac85bd83a1e50beb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a3f9a42d11203c056ac85bd83a1e50beb">WorkdirHelper</a> (const <a class="el" href="classDakota_1_1WorkdirHelper.html">WorkdirHelper</a> &amp;)</td></tr>
<tr class="memdesc:a3f9a42d11203c056ac85bd83a1e50beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor <br /></td></tr>
<tr class="separator:a3f9a42d11203c056ac85bd83a1e50beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeff89af1fade82fb52d308badbf61db"><td class="memItemLeft" align="right" valign="top"><a id="afeff89af1fade82fb52d308badbf61db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#afeff89af1fade82fb52d308badbf61db">~WorkdirHelper</a> ()</td></tr>
<tr class="memdesc:afeff89af1fade82fb52d308badbf61db"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:afeff89af1fade82fb52d308badbf61db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa749d8094434845d074ab07f124be8"><td class="memItemLeft" align="right" valign="top"><a id="a3fa749d8094434845d074ab07f124be8"></a>
<a class="el" href="classDakota_1_1WorkdirHelper.html">WorkdirHelper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a3fa749d8094434845d074ab07f124be8">operator=</a> (const <a class="el" href="classDakota_1_1WorkdirHelper.html">WorkdirHelper</a> &amp;)</td></tr>
<tr class="memdesc:a3fa749d8094434845d074ab07f124be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator <br /></td></tr>
<tr class="separator:a3fa749d8094434845d074ab07f124be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a0d78de00aee42161d9992e1f8618e60f"><td class="memItemLeft" align="right" valign="top">static bfs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a0d78de00aee42161d9992e1f8618e60f">po_which</a> (const std::string &amp;driver_name)</td></tr>
<tr class="memdesc:a0d78de00aee42161d9992e1f8618e60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bfs::path for the analysis driver - POSIX-style implementation, returns empty if not found.  <a href="classDakota_1_1WorkdirHelper.html#a0d78de00aee42161d9992e1f8618e60f">More...</a><br /></td></tr>
<tr class="separator:a0d78de00aee42161d9992e1f8618e60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7503881300b175e6b151dde29abb2d4d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a7503881300b175e6b151dde29abb2d4d">init_startup_path</a> ()</td></tr>
<tr class="memdesc:a7503881300b175e6b151dde29abb2d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes class member, startupPATH.  <a href="classDakota_1_1WorkdirHelper.html#a7503881300b175e6b151dde29abb2d4d">More...</a><br /></td></tr>
<tr class="separator:a7503881300b175e6b151dde29abb2d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7a2daae7ef166756478c0ff27d1917"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a7c7a2daae7ef166756478c0ff27d1917">init_preferred_env_path</a> ()</td></tr>
<tr class="memdesc:a7c7a2daae7ef166756478c0ff27d1917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes class member, dakPreferredEnvPath.  <a href="classDakota_1_1WorkdirHelper.html#a7c7a2daae7ef166756478c0ff27d1917">More...</a><br /></td></tr>
<tr class="separator:a7c7a2daae7ef166756478c0ff27d1917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cad84cef51c8a71f8870355c9867ab"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a04cad84cef51c8a71f8870355c9867ab">tokenize_env_path</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a04cad84cef51c8a71f8870355c9867ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenizes $PATH environment variable into a "list" of directories.  <a href="classDakota_1_1WorkdirHelper.html#a04cad84cef51c8a71f8870355c9867ab">More...</a><br /></td></tr>
<tr class="separator:a04cad84cef51c8a71f8870355c9867ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a1a8ca71ca2e3f2a1a69b9df6097483ba"><td class="memItemLeft" align="right" valign="top"><a id="a1a8ca71ca2e3f2a1a69b9df6097483ba"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a1a8ca71ca2e3f2a1a69b9df6097483ba">startupPWD</a> = &quot;.&quot;</td></tr>
<tr class="memdesc:a1a8ca71ca2e3f2a1a69b9df6097483ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of $PWD var upon entry to dakota <a class="el" href="dll__tester_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="The main program for exercising the DLL API with a simple command-line.">main()</a> <br /></td></tr>
<tr class="separator:a1a8ca71ca2e3f2a1a69b9df6097483ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1544a00ec235988fcd834d0948cd80b6"><td class="memItemLeft" align="right" valign="top"><a id="a1544a00ec235988fcd834d0948cd80b6"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#a1544a00ec235988fcd834d0948cd80b6">startupPATH</a> = &quot;.&quot;</td></tr>
<tr class="memdesc:a1544a00ec235988fcd834d0948cd80b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of $PATH (PATH% on windows) var upon entry to dakota <a class="el" href="dll__tester_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="The main program for exercising the DLL API with a simple command-line.">main()</a>, omitting any leading PATH= or Path=. <br /></td></tr>
<tr class="separator:a1544a00ec235988fcd834d0948cd80b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f26251cb5b92d2dcdf43473d0f3820"><td class="memItemLeft" align="right" valign="top"><a id="ab9f26251cb5b92d2dcdf43473d0f3820"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1WorkdirHelper.html#ab9f26251cb5b92d2dcdf43473d0f3820">dakPreferredEnvPath</a> = &quot;.&quot;</td></tr>
<tr class="memdesc:ab9f26251cb5b92d2dcdf43473d0f3820"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> preferred search PATH/Path = ".:startupPWD:startupPATH", omitting any leading PATH= or Path=. <br /></td></tr>
<tr class="separator:ab9f26251cb5b92d2dcdf43473d0f3820"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility class for cross-platform management of environment and paths. Including directory and file operations. On initialization, this class does not manipulate the present working directory, nor the PATH environment variable, but stores context to manipulate them later. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a25a40b6614565f755233080a384c35f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a40b6614565f755233080a384c35f1">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize (at runtime) cached values for paths and environment </p>
<p>Initialize defers calls to Boost filesystem utilities until runtime (required on some operating systems. </p>

<p class="reference">References <a class="el" href="classDakota_1_1WorkdirHelper.html#ab9f26251cb5b92d2dcdf43473d0f3820">WorkdirHelper::dakPreferredEnvPath</a>, <a class="el" href="classDakota_1_1WorkdirHelper.html#a7c7a2daae7ef166756478c0ff27d1917">WorkdirHelper::init_preferred_env_path()</a>, <a class="el" href="classDakota_1_1WorkdirHelper.html#a7503881300b175e6b151dde29abb2d4d">WorkdirHelper::init_startup_path()</a>, <a class="el" href="classDakota_1_1WorkdirHelper.html#a1544a00ec235988fcd834d0948cd80b6">WorkdirHelper::startupPATH</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#a1a8ca71ca2e3f2a1a69b9df6097483ba">WorkdirHelper::startupPWD</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Environment.html#a7b41277a6fd54c218c89d040b4469508">Environment::Environment()</a>.</p>

</div>
</div>
<a id="a7dd9589e642f69e9e64327646c1f7aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd9589e642f69e9e64327646c1f7aaf">&#9670;&nbsp;</a></span>prepend_preferred_env_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prepend_preferred_env_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extra_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend cached preferredEnvPath with extra_path and update $PATH environment variable. </p>
<p>Overwrites $PATH with an additional directory prepended, typically for the purpose of ensuring templatedir is in the $PATH; updates cached preferred PATH and environment PATH, so exercise caution with repeated calls. </p>

<p class="reference">References <a class="el" href="classDakota_1_1WorkdirHelper.html#ab9f26251cb5b92d2dcdf43473d0f3820">WorkdirHelper::dakPreferredEnvPath</a>, <a class="el" href="classDakota_1_1WorkdirHelper.html#a4cf010510f9412178910bacde7e6c3bc">WorkdirHelper::set_environment()</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#a1a8ca71ca2e3f2a1a69b9df6097483ba">WorkdirHelper::startupPWD</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#a6e10d8f4ec11cc4138a24996fd16f100">WorkdirHelper::prepend_path_item()</a>.</p>

</div>
</div>
<a id="a269e5ea44cc5a95290d6e67374b55a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269e5ea44cc5a95290d6e67374b55a7f">&#9670;&nbsp;</a></span>which()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bfs::path which </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>driver_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bfs::path for the analysis driver, supporting typical windows filename extensions, or empty if not found. </p>
<p>Uses string representing $PATH to locate an analysis driver on the host computer. Returns the path to the driver (as a string)</p>
<p>This version is a wrapper over the "plain ol' which" implementation, allowing an array of windows, 3-letter extensions to be checked. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#af43dccd401e55817596fbf59545ed2c7">Dakota::get_pathext()</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#a0d78de00aee42161d9992e1f8618e60f">WorkdirHelper::po_which()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1NIDRProblemDescDB.html#a4933e42ff046e049452e0ae3ffe99897">NIDRProblemDescDB::check_driver()</a>.</p>

</div>
</div>
<a id="a540f289e775a1111ac785200ce89f08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540f289e775a1111ac785200ce89f08c">&#9670;&nbsp;</a></span>split_wildcard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void split_wildcard </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_with_wc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bfs::path &amp;&#160;</td>
          <td class="paramname"><em>search_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bfs::path &amp;&#160;</td>
          <td class="paramname"><em>wild_card</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>given a string with an optional path and a wildcard, e.g., /tmp/D*.?pp, parse it into the search path /tmp (default .) and the wildcard D*.?pp. Return wild_card as path to reduce wstring conversions </p>
<p>Input: path_with_wc; Output: search_dir, wild_card </p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#a549e82d1d5f244e638ba5cd08226c5a7">WorkdirHelper::file_op_items()</a>.</p>

</div>
</div>
<a id="a70d6553d1e0f3fa14eee369f96afee1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d6553d1e0f3fa14eee369f96afee1a">&#9670;&nbsp;</a></span>concat_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bfs::path concat_path </td>
          <td>(</td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>p_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>concatenate a string onto the end of a path </p>
<p>NOTE: Could remove this function and use += at call sites, but seems convenient to keep (since path doesn't have operator+) </p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ProcessApplicInterface.html#a87e556c87acdf65e70f1827689a66f01">ProcessApplicInterface::autotag_files()</a>, <a class="el" href="classDakota_1_1ProcessApplicInterface.html#aa0fee9137e99b233ed6121f60d3bdb9b">ProcessApplicInterface::define_filenames()</a>, <a class="el" href="classDakota_1_1ProcessApplicInterface.html#af53194559d85e9071703335d3d173fcf">ProcessApplicInterface::file_cleanup()</a>, <a class="el" href="classDakota_1_1ProcessApplicInterface.html#a4cf94527f49d9dce8be59a63124a0634">ProcessApplicInterface::get_workdir_name()</a>, <a class="el" href="classDakota_1_1ProcessApplicInterface.html#a2862c994fe11e66095ed3eb8e84485c2">ProcessApplicInterface::read_results_files()</a>, <a class="el" href="classDakota_1_1ProcessApplicInterface.html#a43395f1b8ea88c44d1e8b56b0dc1f2d4">ProcessApplicInterface::remove_params_results_files()</a>, and <a class="el" href="classDakota_1_1SysCallApplicInterface.html#a7d898d1015b6b450f8e77cd9f2382f21">SysCallApplicInterface::system_call_file_test()</a>.</p>

</div>
</div>
<a id="a3947928c1020edd7da1a0551850b6618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3947928c1020edd7da1a0551850b6618">&#9670;&nbsp;</a></span>create_directory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool create_directory </td>
          <td>(</td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>mkdir_option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a directory, with options for remove or error. </p>
<p>mkdir_option is DIR_CLEAN (remove and recreate), DIR_PERSIST (leave existing), or DIR_ERROR (don't allow existing) returns whether a new directory was created. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#a3703a85a4a91bd12b2980f6b3be54f39">WorkdirHelper::recursive_remove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1NonDMUQBayesCalibration.html#ad4a7316a51b17d0f691bb3e33b95a5ad">NonDMUQBayesCalibration::calibrate()</a>, and <a class="el" href="classDakota_1_1ProcessApplicInterface.html#aa0fee9137e99b233ed6121f60d3bdb9b">ProcessApplicInterface::define_filenames()</a>.</p>

</div>
</div>
<a id="ad94db58ea89faabd637bed61a4f51b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94db58ea89faabd637bed61a4f51b01">&#9670;&nbsp;</a></span>link_items()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void link_items </td>
          <td>(</td>
          <td class="paramtype">const StringArray &amp;&#160;</td>
          <td class="paramname"><em>source_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>dest_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>top-level link a list of source_paths (files, directories, symlinks), potentially including wildcards, from destination_dir, which must exist </p>
<p>Iterate source items (paths or wildcards), linking each of them from the destination. If overwrite, remove and replace any existing destination target, otherwise, allow to persist </p>

<p class="reference">References <a class="el" href="classDakota_1_1WorkdirHelper.html#a549e82d1d5f244e638ba5cd08226c5a7">WorkdirHelper::file_op_items()</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#a5754e8b32715956c15b31fd010ca57d5">WorkdirHelper::link()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ProcessApplicInterface.html#aa0fee9137e99b233ed6121f60d3bdb9b">ProcessApplicInterface::define_filenames()</a>.</p>

</div>
</div>
<a id="a613139dbef2aeaae4ef8caceca6aad62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613139dbef2aeaae4ef8caceca6aad62">&#9670;&nbsp;</a></span>copy_items()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void copy_items </td>
          <td>(</td>
          <td class="paramtype">const StringArray &amp;&#160;</td>
          <td class="paramname"><em>source_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>dest_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy a list of source_paths (files, directories, symlinks), potentially including wildcards into destination_dir, which must exist </p>
<p>Iterate source items (paths or wildcards), copying each of them into the destination. If overwrite, remove and replace any existing destination target, otherwise, allow to persist </p>

<p class="reference">References <a class="el" href="classDakota_1_1WorkdirHelper.html#a549e82d1d5f244e638ba5cd08226c5a7">WorkdirHelper::file_op_items()</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#af5225a89b04b3665af4597d10dc81892">WorkdirHelper::recursive_copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ProcessApplicInterface.html#aa0fee9137e99b233ed6121f60d3bdb9b">ProcessApplicInterface::define_filenames()</a>.</p>

</div>
</div>
<a id="a5754e8b32715956c15b31fd010ca57d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5754e8b32715956c15b31fd010ca57d5">&#9670;&nbsp;</a></span>link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool link </td>
          <td>(</td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>dest_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create link from dest_dir/src_path.filename() to a single path (file, dir, link) in source directory </p>
<p>Assumes source file exists since it was iterated in the calling context. If overwrite, any existing file in dest_dir will be removed prior to creating the new link. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#ad94db58ea89faabd637bed61a4f51b01">WorkdirHelper::link_items()</a>.</p>

</div>
</div>
<a id="af5225a89b04b3665af4597d10dc81892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5225a89b04b3665af4597d10dc81892">&#9670;&nbsp;</a></span>recursive_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool recursive_copy </td>
          <td>(</td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>dest_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recrusive copy of src_path into dest_dir, with optional top-level overwrite (remove/recreate) of dest_dir/src_path.filename() </p>
<p>note dest_dir is the containing folder for the src_path contents to be placed in for consistency with other convenience functions (may need to reconsider) </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#a613139dbef2aeaae4ef8caceca6aad62">WorkdirHelper::copy_items()</a>.</p>

</div>
</div>
<a id="a6e10d8f4ec11cc4138a24996fd16f100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e10d8f4ec11cc4138a24996fd16f100">&#9670;&nbsp;</a></span>prepend_path_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool prepend_path_item </td>
          <td>(</td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>dest_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prepend the preferred env path with source path if it's a directory; this will update cached preferred path and manipulate PATH </p>
<p>prepend the env path with source path if it's a directory or directory symlink </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#a7dd9589e642f69e9e64327646c1f7aaf">WorkdirHelper::prepend_preferred_env_path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#ab50f15224f6934edb9eca54b67ac3e39">WorkdirHelper::prepend_path_items()</a>.</p>

</div>
</div>
<a id="a549e82d1d5f244e638ba5cd08226c5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549e82d1d5f244e638ba5cd08226c5a7">&#9670;&nbsp;</a></span>file_op_items()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool file_op_items </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDakota.html#a290b897fd6b50e6386330c2ed30090ca">file_op_function</a> &amp;&#160;</td>
          <td class="paramname"><em>file_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringArray &amp;&#160;</td>
          <td class="paramname"><em>source_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bfs::path &amp;&#160;</td>
          <td class="paramname"><em>dest_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>recursively perform file_op (copy, path adjust, etc.) on a list of source_paths (files, directories, symlinks), which potentially include wildcards, w.r.t. destination_dir </p>
<p><a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> implementation for copy, link, etc file operation. Iterate source items (paths or wildcards), performing file_op on each w.r.t. destination. If overwrite, remove and replace any existing destination target (at top-level), otherwise, allow to persist. Return code true indicates abnormal behavior. </p>

<p class="reference">References <a class="el" href="classDakota_1_1WorkdirHelper.html#a540f289e775a1111ac785200ce89f08c">WorkdirHelper::split_wildcard()</a>, and <a class="el" href="namespaceDakota.html#a2707182789042201eaeacaa9f450f21e">Dakota::strcontains()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#a2bc0e542153367dbb712c2826dc6f753">WorkdirHelper::check_equivalent_dest()</a>, <a class="el" href="classDakota_1_1WorkdirHelper.html#a613139dbef2aeaae4ef8caceca6aad62">WorkdirHelper::copy_items()</a>, <a class="el" href="classDakota_1_1WorkdirHelper.html#a9b4d53f89dd1f5b1827aad3168669390">WorkdirHelper::find_driver()</a>, <a class="el" href="classDakota_1_1WorkdirHelper.html#ad94db58ea89faabd637bed61a4f51b01">WorkdirHelper::link_items()</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#ab50f15224f6934edb9eca54b67ac3e39">WorkdirHelper::prepend_path_items()</a>.</p>

</div>
</div>
<a id="a6e1957ac7a2b779a9e040cb1a20f9020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1957ac7a2b779a9e040cb1a20f9020">&#9670;&nbsp;</a></span>set_preferred_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_preferred_path </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>extra_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set PATH to absolute(extra_path):dakPreferredEnvPath, without changing cached preferred PATH </p>
<p>If needed, convert the passed item to an absolute path (while could make sense to prepend a relative path, no current use cases) and prepend when setting environment. Does not update cached preferred path. <br  />
 </p>

<p class="reference">References <a class="el" href="classDakota_1_1WorkdirHelper.html#ab9f26251cb5b92d2dcdf43473d0f3820">WorkdirHelper::dakPreferredEnvPath</a>, <a class="el" href="classDakota_1_1WorkdirHelper.html#a78adf5d7a16fbd88f70dd9f0757cf69c">WorkdirHelper::rel_to_abs()</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#a4cf010510f9412178910bacde7e6c3bc">WorkdirHelper::set_environment()</a>.</p>

</div>
</div>
<a id="a0d78de00aee42161d9992e1f8618e60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d78de00aee42161d9992e1f8618e60f">&#9670;&nbsp;</a></span>po_which()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bfs::path po_which </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>driver_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bfs::path for the analysis driver - POSIX-style implementation, returns empty if not found. </p>
<p>For absolute driver_name, validates that is regular file. For relative, uses string representing $PATH (preferred path) to locate an analysis driver on the host computer. Returns the path to the driver, or empty if not found.</p>
<p>This is the "plain ol' which" impl that worked well, historically, on POSIX. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#a1e917b38a856f8df119908963cb5057d">Dakota::contains()</a>, <a class="el" href="classDakota_1_1WorkdirHelper.html#ab9f26251cb5b92d2dcdf43473d0f3820">WorkdirHelper::dakPreferredEnvPath</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#a04cad84cef51c8a71f8870355c9867ab">WorkdirHelper::tokenize_env_path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#a269e5ea44cc5a95290d6e67374b55a7f">WorkdirHelper::which()</a>.</p>

</div>
</div>
<a id="a7503881300b175e6b151dde29abb2d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7503881300b175e6b151dde29abb2d4d">&#9670;&nbsp;</a></span>init_startup_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string init_startup_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes class member, startupPATH. </p>
<p>Gets the $PATH (PATH% on windows) and returns the std::string value </p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#a25a40b6614565f755233080a384c35f1">WorkdirHelper::initialize()</a>.</p>

</div>
</div>
<a id="a7c7a2daae7ef166756478c0ff27d1917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7a2daae7ef166756478c0ff27d1917">&#9670;&nbsp;</a></span>init_preferred_env_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string init_preferred_env_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes class member, dakPreferredEnvPath. </p>
<p>Prepends '.' and the startupPWD to the initial startup $PATH string so that analysis driver detection is more robust </p>

<p class="reference">References <a class="el" href="classDakota_1_1WorkdirHelper.html#a1544a00ec235988fcd834d0948cd80b6">WorkdirHelper::startupPATH</a>, and <a class="el" href="classDakota_1_1WorkdirHelper.html#a1a8ca71ca2e3f2a1a69b9df6097483ba">WorkdirHelper::startupPWD</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#a25a40b6614565f755233080a384c35f1">WorkdirHelper::initialize()</a>.</p>

</div>
</div>
<a id="a04cad84cef51c8a71f8870355c9867ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cad84cef51c8a71f8870355c9867ab">&#9670;&nbsp;</a></span>tokenize_env_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; tokenize_env_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>env_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tokenizes $PATH environment variable into a "list" of directories. </p>
<p>Creates a a vector of directories (as an aid to search) by breaking up the $PATH environment variable (passed in as a string argument) </p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1WorkdirHelper.html#a0d78de00aee42161d9992e1f8618e60f">WorkdirHelper::po_which()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>WorkdirHelper.hpp</li>
<li>WorkdirHelper.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
