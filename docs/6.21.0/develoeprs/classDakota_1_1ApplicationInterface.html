<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Dakota Developers Manual" />
<meta name="keywords" content="optimization, uncertainty quantification, model calibration, parameter estimation, sensitivity analysis, parallel computing, developers manual" />
<meta name="sandia.approval_type" content="formal" />
<meta name="sandia.approved" content="2010-2185" />
<link rev="owns" title="Brian M. Adams" href="mailto:briadam@sandia.gov" />
<meta name="Author" content="Brian M. Adams" />
<title>Dakota: ApplicationInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DAKOTA_Arrow_Name_77x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dakota
   &#160;<span id="projectnumber">Version 6.21</span>
   </div>
   <div id="projectbrief">Explore and Predict with Confidence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDakota.html">Dakota</a></li><li class="navelem"><a class="el" href="classDakota_1_1ApplicationInterface.html">ApplicationInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDakota_1_1ApplicationInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ApplicationInterface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Derived class within the interface class hierarchy for supporting interfaces to simulation codes.  
 <a href="classDakota_1_1ApplicationInterface.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ApplicationInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classDakota_1_1ApplicationInterface.png" usemap="#ApplicationInterface_map" alt=""/>
  <map id="ApplicationInterface_map" name="ApplicationInterface_map">
<area href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy." alt="Interface" shape="rect" coords="194,0,378,24"/>
<area href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ..." alt="DirectApplicInterface" shape="rect" coords="0,112,184,136"/>
<area href="classDakota_1_1ProcessApplicInterface.html" title="Derived application interface class that spawns a simulation code using a separate process and commun..." alt="ProcessApplicInterface" shape="rect" coords="388,112,572,136"/>
<area href="classDakota_1_1MatlabInterface.html" alt="MatlabInterface" shape="rect" coords="194,168,378,192"/>
<area href="classDakota_1_1Pybind11Interface.html" alt="Pybind11Interface" shape="rect" coords="194,224,378,248"/>
<area href="classDakota_1_1PythonInterface.html" alt="PythonInterface" shape="rect" coords="194,280,378,304"/>
<area href="classDakota_1_1ScilabInterface.html" alt="ScilabInterface" shape="rect" coords="194,336,378,360"/>
<area href="classDakota_1_1TestDriverInterface.html" alt="TestDriverInterface" shape="rect" coords="194,392,378,416"/>
<area href="classSIM_1_1ParallelDirectApplicInterface.html" title="Sample derived interface class for testing parallel simulator plug-ins using assign_rep()." alt="ParallelDirectApplicInterface" shape="rect" coords="194,448,378,472"/>
<area href="classSIM_1_1SerialDirectApplicInterface.html" title="Sample derived interface class for testing serial simulator plug-ins using assign_rep()." alt="SerialDirectApplicInterface" shape="rect" coords="194,504,378,528"/>
<area href="classStanfordPSAAP_1_1SoleilDirectApplicInterface.html" title="Sample derived interface class for testing serial simulator plug-ins using assign_rep()." alt="SoleilDirectApplicInterface" shape="rect" coords="194,560,378,584"/>
<area href="classDakota_1_1ProcessHandleApplicInterface.html" title="Derived application interface class that spawns a simulation code using a separate process,..." alt="ProcessHandleApplicInterface" shape="rect" coords="582,168,766,192"/>
<area href="classDakota_1_1SysCallApplicInterface.html" title="Derived application interface class which spawns simulation codes using system calls." alt="SysCallApplicInterface" shape="rect" coords="582,224,766,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a49d701bf2da7704bc06d8dad828d3098"><td class="memItemLeft" align="right" valign="top"><a id="a49d701bf2da7704bc06d8dad828d3098"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a49d701bf2da7704bc06d8dad828d3098">ApplicationInterface</a> (const <a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db)</td></tr>
<tr class="memdesc:a49d701bf2da7704bc06d8dad828d3098"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor <br /></td></tr>
<tr class="separator:a49d701bf2da7704bc06d8dad828d3098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7aa73e9fe693da240b5c5c2582645d"><td class="memItemLeft" align="right" valign="top"><a id="a4f7aa73e9fe693da240b5c5c2582645d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a4f7aa73e9fe693da240b5c5c2582645d">~ApplicationInterface</a> ()</td></tr>
<tr class="memdesc:a4f7aa73e9fe693da240b5c5c2582645d"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a4f7aa73e9fe693da240b5c5c2582645d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDakota_1_1Interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDakota_1_1Interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDakota_1_1Interface.html">Interface</a></td></tr>
<tr class="memitem:a0c0d92c929dee32da43107a289943506 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a0c0d92c929dee32da43107a289943506">Interface</a> ()</td></tr>
<tr class="memdesc:a0c0d92c929dee32da43107a289943506 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classDakota_1_1Interface.html#a0c0d92c929dee32da43107a289943506">More...</a><br /></td></tr>
<tr class="separator:a0c0d92c929dee32da43107a289943506 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458d77eb38605e1bfdc3195af0282d71 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a458d77eb38605e1bfdc3195af0282d71">Interface</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db)</td></tr>
<tr class="memdesc:a458d77eb38605e1bfdc3195af0282d71 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard constructor for envelope  <a href="classDakota_1_1Interface.html#a458d77eb38605e1bfdc3195af0282d71">More...</a><br /></td></tr>
<tr class="separator:a458d77eb38605e1bfdc3195af0282d71 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352d4f243e11221e212bb3baf3e32634 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a352d4f243e11221e212bb3baf3e32634">Interface</a> (const <a class="el" href="classDakota_1_1Interface.html">Interface</a> &amp;interface_in)</td></tr>
<tr class="memdesc:a352d4f243e11221e212bb3baf3e32634 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classDakota_1_1Interface.html#a352d4f243e11221e212bb3baf3e32634">More...</a><br /></td></tr>
<tr class="separator:a352d4f243e11221e212bb3baf3e32634 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04527cc831ce2ec266241dc6b0d7ab9f inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a04527cc831ce2ec266241dc6b0d7ab9f"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a04527cc831ce2ec266241dc6b0d7ab9f">~Interface</a> ()</td></tr>
<tr class="memdesc:a04527cc831ce2ec266241dc6b0d7ab9f inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a04527cc831ce2ec266241dc6b0d7ab9f inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac166fa3b82b50566c5e33e4bcb926e73 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ac166fa3b82b50566c5e33e4bcb926e73"></a>
<a class="el" href="classDakota_1_1Interface.html">Interface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ac166fa3b82b50566c5e33e4bcb926e73">operator=</a> (const <a class="el" href="classDakota_1_1Interface.html">Interface</a> &amp;interface_in)</td></tr>
<tr class="memdesc:ac166fa3b82b50566c5e33e4bcb926e73 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator <br /></td></tr>
<tr class="separator:ac166fa3b82b50566c5e33e4bcb926e73 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e42609b0e68bc14db0972309b3f4114 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a8e42609b0e68bc14db0972309b3f4114"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a8e42609b0e68bc14db0972309b3f4114">minimum_points</a> (bool constraint_flag) const</td></tr>
<tr class="memdesc:a8e42609b0e68bc14db0972309b3f4114 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the minimum number of points required to build a particular <a class="el" href="classDakota_1_1ApproximationInterface.html" title="Derived class within the interface class hierarchy for supporting approximations to simulation-based ...">ApproximationInterface</a> (used by DataFitSurrModels). <br /></td></tr>
<tr class="separator:a8e42609b0e68bc14db0972309b3f4114 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0068e23c67395b62dd239be8f8a889a inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="af0068e23c67395b62dd239be8f8a889a"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#af0068e23c67395b62dd239be8f8a889a">recommended_points</a> (bool constraint_flag) const</td></tr>
<tr class="memdesc:af0068e23c67395b62dd239be8f8a889a inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the recommended number of points required to build a particular <a class="el" href="classDakota_1_1ApproximationInterface.html" title="Derived class within the interface class hierarchy for supporting approximations to simulation-based ...">ApproximationInterface</a> (used by DataFitSurrModels). <br /></td></tr>
<tr class="separator:af0068e23c67395b62dd239be8f8a889a inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805dc025ea701d90fb0ab6295c973023 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a805dc025ea701d90fb0ab6295c973023"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a805dc025ea701d90fb0ab6295c973023">active_model_key</a> (const Pecos::ActiveKey &amp;key)</td></tr>
<tr class="memdesc:a805dc025ea701d90fb0ab6295c973023 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">activate an approximation state based on its key <br /></td></tr>
<tr class="separator:a805dc025ea701d90fb0ab6295c973023 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6badda9382ead6bd54a9fcf2e74395ff inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a6badda9382ead6bd54a9fcf2e74395ff"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a6badda9382ead6bd54a9fcf2e74395ff">clear_model_keys</a> ()</td></tr>
<tr class="memdesc:a6badda9382ead6bd54a9fcf2e74395ff inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset initial state by removing all model keys for an approximation <br /></td></tr>
<tr class="separator:a6badda9382ead6bd54a9fcf2e74395ff inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b02ce0c88157b16ac8ae21a3846e668 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a1b02ce0c88157b16ac8ae21a3846e668"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a1b02ce0c88157b16ac8ae21a3846e668">approximation_function_indices</a> (const SizetSet &amp;approx_fn_indices)</td></tr>
<tr class="memdesc:a1b02ce0c88157b16ac8ae21a3846e668 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the (currently active) approximation function index set <br /></td></tr>
<tr class="separator:a1b02ce0c88157b16ac8ae21a3846e668 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4204e20f0fa582811e27040213e1db4 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="af4204e20f0fa582811e27040213e1db4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#af4204e20f0fa582811e27040213e1db4">update_approximation</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars, const IntResponsePair &amp;response_pr)</td></tr>
<tr class="memdesc:af4204e20f0fa582811e27040213e1db4 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the anchor point for an approximation <br /></td></tr>
<tr class="separator:af4204e20f0fa582811e27040213e1db4 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73e24f1c3528a7b425e8e23e6af257f inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ae73e24f1c3528a7b425e8e23e6af257f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ae73e24f1c3528a7b425e8e23e6af257f">update_approximation</a> (const RealMatrix &amp;samples, const IntResponseMap &amp;resp_map)</td></tr>
<tr class="memdesc:ae73e24f1c3528a7b425e8e23e6af257f inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the current data points for an approximation <br /></td></tr>
<tr class="separator:ae73e24f1c3528a7b425e8e23e6af257f inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426dba6171b2d4e9693cc6bebd9be1fe inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a426dba6171b2d4e9693cc6bebd9be1fe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a426dba6171b2d4e9693cc6bebd9be1fe">update_approximation</a> (const VariablesArray &amp;vars_array, const IntResponseMap &amp;resp_map)</td></tr>
<tr class="memdesc:a426dba6171b2d4e9693cc6bebd9be1fe inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the current data points for an approximation <br /></td></tr>
<tr class="separator:a426dba6171b2d4e9693cc6bebd9be1fe inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d89d9094056cb7342d7d74d795b22b inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ad8d89d9094056cb7342d7d74d795b22b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ad8d89d9094056cb7342d7d74d795b22b">append_approximation</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars, const IntResponsePair &amp;response_pr)</td></tr>
<tr class="memdesc:ad8d89d9094056cb7342d7d74d795b22b inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends a single point to an existing approximation <br /></td></tr>
<tr class="separator:ad8d89d9094056cb7342d7d74d795b22b inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8737bdc7bd84a999e8c1b3cd2b04cc39 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a8737bdc7bd84a999e8c1b3cd2b04cc39"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a8737bdc7bd84a999e8c1b3cd2b04cc39">append_approximation</a> (const RealMatrix &amp;samples, const IntResponseMap &amp;resp_map)</td></tr>
<tr class="memdesc:a8737bdc7bd84a999e8c1b3cd2b04cc39 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends multiple points to an existing approximation <br /></td></tr>
<tr class="separator:a8737bdc7bd84a999e8c1b3cd2b04cc39 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3720ce26e3eb7183721fe6b2e15416b9 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a3720ce26e3eb7183721fe6b2e15416b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a3720ce26e3eb7183721fe6b2e15416b9">append_approximation</a> (const VariablesArray &amp;vars_array, const IntResponseMap &amp;resp_map)</td></tr>
<tr class="memdesc:a3720ce26e3eb7183721fe6b2e15416b9 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends multiple points to an existing approximation <br /></td></tr>
<tr class="separator:a3720ce26e3eb7183721fe6b2e15416b9 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a68fb7df6c99b0e7c16008d729c98e8 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a3a68fb7df6c99b0e7c16008d729c98e8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a3a68fb7df6c99b0e7c16008d729c98e8">append_approximation</a> (const IntVariablesMap &amp;vars_map, const IntResponseMap &amp;resp_map)</td></tr>
<tr class="memdesc:a3a68fb7df6c99b0e7c16008d729c98e8 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends multiple points to an existing approximation <br /></td></tr>
<tr class="separator:a3a68fb7df6c99b0e7c16008d729c98e8 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d3769109a50ed602a4fb75bfb09ec6 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ac5d3769109a50ed602a4fb75bfb09ec6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ac5d3769109a50ed602a4fb75bfb09ec6">replace_approximation</a> (const IntResponsePair &amp;response_pr)</td></tr>
<tr class="memdesc:ac5d3769109a50ed602a4fb75bfb09ec6 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace the response for a single point within an existing approximation <br /></td></tr>
<tr class="separator:ac5d3769109a50ed602a4fb75bfb09ec6 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d0158bab97a92c75a8b49c0c5e635c inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a45d0158bab97a92c75a8b49c0c5e635c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a45d0158bab97a92c75a8b49c0c5e635c">replace_approximation</a> (const IntResponseMap &amp;resp_map)</td></tr>
<tr class="memdesc:a45d0158bab97a92c75a8b49c0c5e635c inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace responses for multiple points within an existing approximation <br /></td></tr>
<tr class="separator:a45d0158bab97a92c75a8b49c0c5e635c inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2c0e90d96847a889fefbf75e29d6cb inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aed2c0e90d96847a889fefbf75e29d6cb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aed2c0e90d96847a889fefbf75e29d6cb">track_evaluation_ids</a> (bool track)</td></tr>
<tr class="memdesc:aed2c0e90d96847a889fefbf75e29d6cb inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">assigns trackEvalIds to activate tracking of evaluation ids within surrogate data, enabling id-based lookups for data replacement <br /></td></tr>
<tr class="separator:aed2c0e90d96847a889fefbf75e29d6cb inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4b327d8ba0b54c25a93ba3bf7b649d inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a7e4b327d8ba0b54c25a93ba3bf7b649d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a7e4b327d8ba0b54c25a93ba3bf7b649d">build_approximation</a> (const RealVector &amp;c_l_bnds, const RealVector &amp;c_u_bnds, const IntVector &amp;di_l_bnds, const IntVector &amp;di_u_bnds, const RealVector &amp;dr_l_bnds, const RealVector &amp;dr_u_bnds)</td></tr>
<tr class="memdesc:a7e4b327d8ba0b54c25a93ba3bf7b649d inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">builds the approximation <br /></td></tr>
<tr class="separator:a7e4b327d8ba0b54c25a93ba3bf7b649d inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0a5ab0fd0b34d45f2531615748317d inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aeb0a5ab0fd0b34d45f2531615748317d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aeb0a5ab0fd0b34d45f2531615748317d">export_approximation</a> ()</td></tr>
<tr class="memdesc:aeb0a5ab0fd0b34d45f2531615748317d inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the approximation to disk <br /></td></tr>
<tr class="separator:aeb0a5ab0fd0b34d45f2531615748317d inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259da32565369c87184cdccac43cb760 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a259da32565369c87184cdccac43cb760"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a259da32565369c87184cdccac43cb760">rebuild_approximation</a> (const BitArray &amp;rebuild_fns)</td></tr>
<tr class="memdesc:a259da32565369c87184cdccac43cb760 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">rebuilds the approximation after a data update <br /></td></tr>
<tr class="separator:a259da32565369c87184cdccac43cb760 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8deeea4f87132cfdbed9998712930574 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a8deeea4f87132cfdbed9998712930574"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a8deeea4f87132cfdbed9998712930574">pop_approximation</a> (bool save_data)</td></tr>
<tr class="memdesc:a8deeea4f87132cfdbed9998712930574 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes data from last append from the approximation <br /></td></tr>
<tr class="separator:a8deeea4f87132cfdbed9998712930574 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df48fc35cc05edd5d1bdc2dc16e1adc inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a5df48fc35cc05edd5d1bdc2dc16e1adc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a5df48fc35cc05edd5d1bdc2dc16e1adc">push_approximation</a> ()</td></tr>
<tr class="memdesc:a5df48fc35cc05edd5d1bdc2dc16e1adc inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieves approximation data from a previous state (negates pop) <br /></td></tr>
<tr class="separator:a5df48fc35cc05edd5d1bdc2dc16e1adc inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610286fcad89a0c993368c96fb9e86dc inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a610286fcad89a0c993368c96fb9e86dc"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a610286fcad89a0c993368c96fb9e86dc">push_available</a> ()</td></tr>
<tr class="memdesc:a610286fcad89a0c993368c96fb9e86dc inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the approximation for the ability to retrieve a previous increment <br /></td></tr>
<tr class="separator:a610286fcad89a0c993368c96fb9e86dc inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50ff610c7e05d48517e51b53e4c1792 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ac50ff610c7e05d48517e51b53e4c1792"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ac50ff610c7e05d48517e51b53e4c1792">finalize_approximation</a> ()</td></tr>
<tr class="memdesc:ac50ff610c7e05d48517e51b53e4c1792 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">finalizes the approximation by applying all trial increments <br /></td></tr>
<tr class="separator:ac50ff610c7e05d48517e51b53e4c1792 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac4ce2eb0e689d72e7f1c9096e2aff3 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="afac4ce2eb0e689d72e7f1c9096e2aff3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#afac4ce2eb0e689d72e7f1c9096e2aff3">combine_approximation</a> ()</td></tr>
<tr class="memdesc:afac4ce2eb0e689d72e7f1c9096e2aff3 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">combine the current approximation with previously stored data sets <br /></td></tr>
<tr class="separator:afac4ce2eb0e689d72e7f1c9096e2aff3 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e95f1847d771665163f54bfecac248 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="af2e95f1847d771665163f54bfecac248"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#af2e95f1847d771665163f54bfecac248">combined_to_active</a> (bool clear_combined=true)</td></tr>
<tr class="memdesc:af2e95f1847d771665163f54bfecac248 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">promote the combined approximation to the currently active one <br /></td></tr>
<tr class="separator:af2e95f1847d771665163f54bfecac248 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc560a443991770b6343271630a651e inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a6bc560a443991770b6343271630a651e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a6bc560a443991770b6343271630a651e">clear_inactive</a> ()</td></tr>
<tr class="memdesc:a6bc560a443991770b6343271630a651e inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear inactive approximation data <br /></td></tr>
<tr class="separator:a6bc560a443991770b6343271630a651e inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3680297a866c811763fc6ccf61f34b89 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a3680297a866c811763fc6ccf61f34b89"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a3680297a866c811763fc6ccf61f34b89">advancement_available</a> ()</td></tr>
<tr class="memdesc:a3680297a866c811763fc6ccf61f34b89 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">query for available advancements in approximation resolution controls <br /></td></tr>
<tr class="separator:a3680297a866c811763fc6ccf61f34b89 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e07daa133df6a88344e72d832eff3a9 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a3e07daa133df6a88344e72d832eff3a9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a3e07daa133df6a88344e72d832eff3a9">formulation_updated</a> () const</td></tr>
<tr class="memdesc:a3e07daa133df6a88344e72d832eff3a9 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">query for change in approximation formulation <br /></td></tr>
<tr class="separator:a3e07daa133df6a88344e72d832eff3a9 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d2dc07d2600c4e9c48e0a0a740415f inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a18d2dc07d2600c4e9c48e0a0a740415f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a18d2dc07d2600c4e9c48e0a0a740415f">formulation_updated</a> (bool update)</td></tr>
<tr class="memdesc:a18d2dc07d2600c4e9c48e0a0a740415f inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign an updated status for approximation formulation to force rebuild <br /></td></tr>
<tr class="separator:a18d2dc07d2600c4e9c48e0a0a740415f inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419600f8a0cbfb7da21858c2782e058b inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a419600f8a0cbfb7da21858c2782e058b"></a>
virtual Real2DArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a419600f8a0cbfb7da21858c2782e058b">cv_diagnostics</a> (const StringArray &amp;metric_types, unsigned num_folds)</td></tr>
<tr class="memdesc:a419600f8a0cbfb7da21858c2782e058b inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">approximation cross-validation quality metrics per response function <br /></td></tr>
<tr class="separator:a419600f8a0cbfb7da21858c2782e058b inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18a810b101e85bade242b23a90937de inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ac18a810b101e85bade242b23a90937de"></a>
virtual RealArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ac18a810b101e85bade242b23a90937de">challenge_diagnostics</a> (const String &amp;metric_type, const RealMatrix &amp;challenge_pts)</td></tr>
<tr class="memdesc:ac18a810b101e85bade242b23a90937de inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">approximation challenge data metrics per response function <br /></td></tr>
<tr class="separator:ac18a810b101e85bade242b23a90937de inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a23a20c3342db19d73bbed0cf1c3177 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a1a23a20c3342db19d73bbed0cf1c3177"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a1a23a20c3342db19d73bbed0cf1c3177">clear_current_active_data</a> ()</td></tr>
<tr class="memdesc:a1a23a20c3342db19d73bbed0cf1c3177 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears current data from an approximation interface <br /></td></tr>
<tr class="separator:a1a23a20c3342db19d73bbed0cf1c3177 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0005953194c55d0a59bd20b99470629 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="af0005953194c55d0a59bd20b99470629"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#af0005953194c55d0a59bd20b99470629">clear_active_data</a> ()</td></tr>
<tr class="memdesc:af0005953194c55d0a59bd20b99470629 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears all data from an approximation interface <br /></td></tr>
<tr class="separator:af0005953194c55d0a59bd20b99470629 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdebe544f4206fbefdcc6f33ee3c3b97 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="acdebe544f4206fbefdcc6f33ee3c3b97"></a>
virtual <a class="el" href="classDakota_1_1SharedApproxData.html">SharedApproxData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#acdebe544f4206fbefdcc6f33ee3c3b97">shared_approximation</a> ()</td></tr>
<tr class="memdesc:acdebe544f4206fbefdcc6f33ee3c3b97 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the <a class="el" href="classDakota_1_1SharedApproxData.html" title="Base class for the shared approximation data class hierarchy.">SharedApproxData</a> within an <a class="el" href="classDakota_1_1ApproximationInterface.html" title="Derived class within the interface class hierarchy for supporting approximations to simulation-based ...">ApproximationInterface</a> <br /></td></tr>
<tr class="separator:acdebe544f4206fbefdcc6f33ee3c3b97 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300a59ae653667a9fd7cd962ffd2654a inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a300a59ae653667a9fd7cd962ffd2654a"></a>
virtual std::vector&lt; <a class="el" href="classDakota_1_1Approximation.html">Approximation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a300a59ae653667a9fd7cd962ffd2654a">approximations</a> ()</td></tr>
<tr class="memdesc:a300a59ae653667a9fd7cd962ffd2654a inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the Approximations within an <a class="el" href="classDakota_1_1ApproximationInterface.html" title="Derived class within the interface class hierarchy for supporting approximations to simulation-based ...">ApproximationInterface</a> <br /></td></tr>
<tr class="separator:a300a59ae653667a9fd7cd962ffd2654a inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c9f1a7dc15546972cc743ffa5cd65b inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aa8c9f1a7dc15546972cc743ffa5cd65b"></a>
virtual const Pecos::SurrogateData &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aa8c9f1a7dc15546972cc743ffa5cd65b">approximation_data</a> (size_t fn_index)</td></tr>
<tr class="memdesc:aa8c9f1a7dc15546972cc743ffa5cd65b inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the approximation data from a particular <a class="el" href="classDakota_1_1Approximation.html" title="Base class for the approximation class hierarchy.">Approximation</a> within an <a class="el" href="classDakota_1_1ApproximationInterface.html" title="Derived class within the interface class hierarchy for supporting approximations to simulation-based ...">ApproximationInterface</a> <br /></td></tr>
<tr class="separator:aa8c9f1a7dc15546972cc743ffa5cd65b inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693bf442714f32cce0de957375efe235 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a693bf442714f32cce0de957375efe235"></a>
virtual const RealVectorArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a693bf442714f32cce0de957375efe235">approximation_coefficients</a> (bool normalized=false)</td></tr>
<tr class="memdesc:a693bf442714f32cce0de957375efe235 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the approximation coefficients from each <a class="el" href="classDakota_1_1Approximation.html" title="Base class for the approximation class hierarchy.">Approximation</a> within an <a class="el" href="classDakota_1_1ApproximationInterface.html" title="Derived class within the interface class hierarchy for supporting approximations to simulation-based ...">ApproximationInterface</a> <br /></td></tr>
<tr class="separator:a693bf442714f32cce0de957375efe235 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d07dc6345cff3b10f352118f39247d inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ac2d07dc6345cff3b10f352118f39247d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ac2d07dc6345cff3b10f352118f39247d">approximation_coefficients</a> (const RealVectorArray &amp;approx_coeffs, bool normalized=false)</td></tr>
<tr class="memdesc:ac2d07dc6345cff3b10f352118f39247d inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the approximation coefficients within each <a class="el" href="classDakota_1_1Approximation.html" title="Base class for the approximation class hierarchy.">Approximation</a> within an <a class="el" href="classDakota_1_1ApproximationInterface.html" title="Derived class within the interface class hierarchy for supporting approximations to simulation-based ...">ApproximationInterface</a> <br /></td></tr>
<tr class="separator:ac2d07dc6345cff3b10f352118f39247d inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0a2e6e5dabc533081168018b64512d inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="abc0a2e6e5dabc533081168018b64512d"></a>
virtual const RealVector &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#abc0a2e6e5dabc533081168018b64512d">approximation_variances</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars)</td></tr>
<tr class="memdesc:abc0a2e6e5dabc533081168018b64512d inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the approximation variances from each <a class="el" href="classDakota_1_1Approximation.html" title="Base class for the approximation class hierarchy.">Approximation</a> within an <a class="el" href="classDakota_1_1ApproximationInterface.html" title="Derived class within the interface class hierarchy for supporting approximations to simulation-based ...">ApproximationInterface</a> <br /></td></tr>
<tr class="separator:abc0a2e6e5dabc533081168018b64512d inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217e7404d426c96ebccd7215a24137f7 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a217e7404d426c96ebccd7215a24137f7"></a>
virtual const StringArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a217e7404d426c96ebccd7215a24137f7">analysis_drivers</a> () const</td></tr>
<tr class="memdesc:a217e7404d426c96ebccd7215a24137f7 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the analysis drivers specification for application interfaces <br /></td></tr>
<tr class="separator:a217e7404d426c96ebccd7215a24137f7 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd6c6d1898b2368e1ecb642b7c7e492 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aabd6c6d1898b2368e1ecb642b7c7e492"></a>
virtual const String2DArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aabd6c6d1898b2368e1ecb642b7c7e492">analysis_components</a> () const</td></tr>
<tr class="memdesc:aabd6c6d1898b2368e1ecb642b7c7e492 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the analysis components, if available <br /></td></tr>
<tr class="separator:aabd6c6d1898b2368e1ecb642b7c7e492 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afead6f298ccc7f7232dfe5ff5488d4f5 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="afead6f298ccc7f7232dfe5ff5488d4f5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#afead6f298ccc7f7232dfe5ff5488d4f5">discrepancy_emulation_mode</a> (short mode)</td></tr>
<tr class="memdesc:afead6f298ccc7f7232dfe5ff5488d4f5 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">set discrepancy emulation mode used for approximating response differences <br /></td></tr>
<tr class="separator:afead6f298ccc7f7232dfe5ff5488d4f5 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53194559d85e9071703335d3d173fcf inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="af53194559d85e9071703335d3d173fcf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#af53194559d85e9071703335d3d173fcf">file_cleanup</a> () const</td></tr>
<tr class="memdesc:af53194559d85e9071703335d3d173fcf inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">clean up any interface parameter/response files when aborting <br /></td></tr>
<tr class="separator:af53194559d85e9071703335d3d173fcf inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d99740294d813be2ac1017bca9738a inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a89d99740294d813be2ac1017bca9738a"></a>
IntResponseMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a89d99740294d813be2ac1017bca9738a">response_map</a> ()</td></tr>
<tr class="memdesc:a89d99740294d813be2ac1017bca9738a inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">return rawResponseMap <br /></td></tr>
<tr class="separator:a89d99740294d813be2ac1017bca9738a inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e2cbaad02d879e78ec16785e8c1027 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a80e2cbaad02d879e78ec16785e8c1027"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a80e2cbaad02d879e78ec16785e8c1027">cache_unmatched_response</a> (int raw_id)</td></tr>
<tr class="memdesc:a80e2cbaad02d879e78ec16785e8c1027 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">migrate an unmatched response record from rawResponseMap to cachedResponseMap <br /></td></tr>
<tr class="separator:a80e2cbaad02d879e78ec16785e8c1027 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0b7da7056bdcf94bbb72354da5aa76 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aab0b7da7056bdcf94bbb72354da5aa76"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aab0b7da7056bdcf94bbb72354da5aa76">cache_unmatched_responses</a> ()</td></tr>
<tr class="memdesc:aab0b7da7056bdcf94bbb72354da5aa76 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">migrate all remaining response records from rawResponseMap to cachedResponseMap <br /></td></tr>
<tr class="separator:aab0b7da7056bdcf94bbb72354da5aa76 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0445f1d566f8702d70ef7386047e2e inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a5b0445f1d566f8702d70ef7386047e2e">assign_rep</a> (std::shared_ptr&lt; <a class="el" href="classDakota_1_1Interface.html">Interface</a> &gt; <a class="el" href="classDakota_1_1Interface.html#aa4e63452175b0c58f4720cd6ecf8e781">interface_rep</a>)</td></tr>
<tr class="memdesc:a5b0445f1d566f8702d70ef7386047e2e inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign letter or replace existing letter with a new one  <a href="classDakota_1_1Interface.html#a5b0445f1d566f8702d70ef7386047e2e">More...</a><br /></td></tr>
<tr class="separator:a5b0445f1d566f8702d70ef7386047e2e inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7703e449bdc236034c7f769dcff53ded inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a7703e449bdc236034c7f769dcff53ded">assign_rep</a> (<a class="el" href="classDakota_1_1Interface.html">Interface</a> *<a class="el" href="classDakota_1_1Interface.html#aa4e63452175b0c58f4720cd6ecf8e781">interface_rep</a>, bool ref_count_incr=false)</td></tr>
<tr class="memdesc:a7703e449bdc236034c7f769dcff53ded inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign letter or replace existing letter with a new one DEPRECATED, but left for library mode clients to migrate: transfers memory ownership to the contained shared_ptr; ref_count_incr is ignored  <a href="classDakota_1_1Interface.html#a7703e449bdc236034c7f769dcff53ded">More...</a><br /></td></tr>
<tr class="separator:a7703e449bdc236034c7f769dcff53ded inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aae8dc51879df9ac575cf4cfdea361 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ae6aae8dc51879df9ac575cf4cfdea361"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ae6aae8dc51879df9ac575cf4cfdea361">interface_type</a> () const</td></tr>
<tr class="memdesc:ae6aae8dc51879df9ac575cf4cfdea361 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the interface type <br /></td></tr>
<tr class="separator:ae6aae8dc51879df9ac575cf4cfdea361 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f131f148278924603e101341549a83 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ad2f131f148278924603e101341549a83"></a>
const String &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ad2f131f148278924603e101341549a83">interface_id</a> () const</td></tr>
<tr class="memdesc:ad2f131f148278924603e101341549a83 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the interface identifier <br /></td></tr>
<tr class="separator:ad2f131f148278924603e101341549a83 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7038db38fa2ab4d3e49bcc0e95f913d inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ad7038db38fa2ab4d3e49bcc0e95f913d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ad7038db38fa2ab4d3e49bcc0e95f913d">evaluation_id</a> () const</td></tr>
<tr class="memdesc:ad7038db38fa2ab4d3e49bcc0e95f913d inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value of the (total) evaluation id counter for the interface <br /></td></tr>
<tr class="separator:ad7038db38fa2ab4d3e49bcc0e95f913d inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6288fd2f1cc39c13e86d5847a16dae23 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a6288fd2f1cc39c13e86d5847a16dae23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a6288fd2f1cc39c13e86d5847a16dae23">fine_grained_evaluation_counters</a> (size_t num_fns)</td></tr>
<tr class="memdesc:a6288fd2f1cc39c13e86d5847a16dae23 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">set fineGrainEvalCounters to true and initialize counters if needed <br /></td></tr>
<tr class="separator:a6288fd2f1cc39c13e86d5847a16dae23 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d96f6f7161280693d84a68caf77758 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ae7d96f6f7161280693d84a68caf77758"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ae7d96f6f7161280693d84a68caf77758">init_evaluation_counters</a> (size_t num_fns)</td></tr>
<tr class="memdesc:ae7d96f6f7161280693d84a68caf77758 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize fine grained evaluation counters, sizing if needed <br /></td></tr>
<tr class="separator:ae7d96f6f7161280693d84a68caf77758 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c34e244d96b721799b1d742c4c68f0 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a61c34e244d96b721799b1d742c4c68f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a61c34e244d96b721799b1d742c4c68f0">set_evaluation_reference</a> ()</td></tr>
<tr class="memdesc:a61c34e244d96b721799b1d742c4c68f0 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">set evaluation count reference points for the interface <br /></td></tr>
<tr class="separator:a61c34e244d96b721799b1d742c4c68f0 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec4c3557548a39013458dd6a348fece inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aeec4c3557548a39013458dd6a348fece"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aeec4c3557548a39013458dd6a348fece">print_evaluation_summary</a> (std::ostream &amp;s, bool minimal_header, bool relative_count) const</td></tr>
<tr class="memdesc:aeec4c3557548a39013458dd6a348fece inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">print an evaluation summary for the interface <br /></td></tr>
<tr class="separator:aeec4c3557548a39013458dd6a348fece inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901de130265b1af752d198a4728f81fd inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a901de130265b1af752d198a4728f81fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a901de130265b1af752d198a4728f81fd">multi_proc_eval</a> () const</td></tr>
<tr class="memdesc:a901de130265b1af752d198a4728f81fd inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a flag signaling the use of multiprocessor evaluation partitions <br /></td></tr>
<tr class="separator:a901de130265b1af752d198a4728f81fd inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f3fec7e51b787338f737888524e3c9 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a98f3fec7e51b787338f737888524e3c9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a98f3fec7e51b787338f737888524e3c9">iterator_eval_dedicated_master</a> () const</td></tr>
<tr class="memdesc:a98f3fec7e51b787338f737888524e3c9 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a flag signaling the use of a dedicated master processor at the iterator-evaluation scheduling level <br /></td></tr>
<tr class="separator:a98f3fec7e51b787338f737888524e3c9 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e61d2bb6c2a58d7b98180555af09e4 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a54e61d2bb6c2a58d7b98180555af09e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a54e61d2bb6c2a58d7b98180555af09e4">is_null</a> () const</td></tr>
<tr class="memdesc:a54e61d2bb6c2a58d7b98180555af09e4 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to check interfaceRep (does this envelope contain a letter?) <br /></td></tr>
<tr class="separator:a54e61d2bb6c2a58d7b98180555af09e4 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e63452175b0c58f4720cd6ecf8e781 inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aa4e63452175b0c58f4720cd6ecf8e781"></a>
std::shared_ptr&lt; <a class="el" href="classDakota_1_1Interface.html">Interface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aa4e63452175b0c58f4720cd6ecf8e781">interface_rep</a> ()</td></tr>
<tr class="memdesc:aa4e63452175b0c58f4720cd6ecf8e781 inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to return the letter <br /></td></tr>
<tr class="separator:aa4e63452175b0c58f4720cd6ecf8e781 inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdecd3970d6aedead8df1fafce3ad8c inherit pub_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a8fdecd3970d6aedead8df1fafce3ad8c">eval_tag_prefix</a> (const String &amp;eval_id_str, bool append_iface_id=true)</td></tr>
<tr class="memdesc:a8fdecd3970d6aedead8df1fafce3ad8c inherit pub_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the evaluation tag prefix (does not recurse)  <a href="classDakota_1_1Interface.html#a8fdecd3970d6aedead8df1fafce3ad8c">More...</a><br /></td></tr>
<tr class="separator:a8fdecd3970d6aedead8df1fafce3ad8c inherit pub_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a539b36ea1dba3c25b12530148942032b"><td class="memItemLeft" align="right" valign="top"><a id="a539b36ea1dba3c25b12530148942032b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a539b36ea1dba3c25b12530148942032b">init_communicators</a> (const IntArray &amp;message_lengths, int max_eval_concurrency)</td></tr>
<tr class="memdesc:a539b36ea1dba3c25b12530148942032b"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate communicator partitions for concurrent evaluations within an iterator and concurrent multiprocessor analyses within an evaluation. <br /></td></tr>
<tr class="separator:a539b36ea1dba3c25b12530148942032b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41339f58905edb8ca694917f463ebf19"><td class="memItemLeft" align="right" valign="top"><a id="a41339f58905edb8ca694917f463ebf19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a41339f58905edb8ca694917f463ebf19">set_communicators</a> (const IntArray &amp;message_lengths, int max_eval_concurrency)</td></tr>
<tr class="memdesc:a41339f58905edb8ca694917f463ebf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the local parallel partition data for an interface (the partitions are already allocated in <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a>). <br /></td></tr>
<tr class="separator:a41339f58905edb8ca694917f463ebf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb6f6d615183fc2f71e79dfbadfe27d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#acfb6f6d615183fc2f71e79dfbadfe27d">init_serial</a> ()</td></tr>
<tr class="separator:acfb6f6d615183fc2f71e79dfbadfe27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f90da4a576528af13b70986dc59376"><td class="memItemLeft" align="right" valign="top"><a id="ae6f90da4a576528af13b70986dc59376"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ae6f90da4a576528af13b70986dc59376">asynch_local_evaluation_concurrency</a> () const</td></tr>
<tr class="memdesc:ae6f90da4a576528af13b70986dc59376"><td class="mdescLeft">&#160;</td><td class="mdescRight">return asynchLocalEvalConcurrency <br /></td></tr>
<tr class="separator:ae6f90da4a576528af13b70986dc59376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc79ceff37c0cbe77f48a21132aaa29"><td class="memItemLeft" align="right" valign="top"><a id="a5bc79ceff37c0cbe77f48a21132aaa29"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a5bc79ceff37c0cbe77f48a21132aaa29">interface_synchronization</a> () const</td></tr>
<tr class="memdesc:a5bc79ceff37c0cbe77f48a21132aaa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">return interfaceSynchronization <br /></td></tr>
<tr class="separator:a5bc79ceff37c0cbe77f48a21132aaa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107483d375c816317fa74b47c493f38a"><td class="memItemLeft" align="right" valign="top"><a id="a107483d375c816317fa74b47c493f38a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a107483d375c816317fa74b47c493f38a">evaluation_cache</a> () const</td></tr>
<tr class="memdesc:a107483d375c816317fa74b47c493f38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return evalCacheFlag <br /></td></tr>
<tr class="separator:a107483d375c816317fa74b47c493f38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219b293eeb114c68f90d8f149590b568"><td class="memItemLeft" align="right" valign="top"><a id="a219b293eeb114c68f90d8f149590b568"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a219b293eeb114c68f90d8f149590b568">restart_file</a> () const</td></tr>
<tr class="memdesc:a219b293eeb114c68f90d8f149590b568"><td class="mdescLeft">&#160;</td><td class="mdescRight">return evalCacheFlag <br /></td></tr>
<tr class="separator:a219b293eeb114c68f90d8f149590b568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8f887507822b4d0b514a7ff5805943"><td class="memItemLeft" align="right" valign="top"><a id="a9d8f887507822b4d0b514a7ff5805943"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a9d8f887507822b4d0b514a7ff5805943">final_eval_id_tag</a> (int fn_eval_id)</td></tr>
<tr class="memdesc:a9d8f887507822b4d0b514a7ff5805943"><td class="mdescLeft">&#160;</td><td class="mdescRight">form and return the final evaluation ID tag, appending iface ID if needed <br /></td></tr>
<tr class="separator:a9d8f887507822b4d0b514a7ff5805943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999c6f807e9ea92b96d6bbc2f7873cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca">map</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars, const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;set, <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;response, bool asynch_flag=false)</td></tr>
<tr class="memdesc:a999c6f807e9ea92b96d6bbc2f7873cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a "mapping" of variables to responses using a simulation. Protected due to <a class="el" href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy.">Interface</a> letter-envelope idiom.  <a href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca">More...</a><br /></td></tr>
<tr class="separator:a999c6f807e9ea92b96d6bbc2f7873cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460bf8a4bf5698bc403ca958c1950941"><td class="memItemLeft" align="right" valign="top"><a id="a460bf8a4bf5698bc403ca958c1950941"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a460bf8a4bf5698bc403ca958c1950941">manage_failure</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars, const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;set, <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;response, int failed_eval_id)</td></tr>
<tr class="memdesc:a460bf8a4bf5698bc403ca958c1950941"><td class="mdescLeft">&#160;</td><td class="mdescRight">manages a simulation failure using abort/retry/recover/continuation <br /></td></tr>
<tr class="separator:a460bf8a4bf5698bc403ca958c1950941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab596ce6c762ef2fcfde22f3b2469b02c"><td class="memItemLeft" align="right" valign="top">const IntResponseMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c">synchronize</a> ()</td></tr>
<tr class="memdesc:ab596ce6c762ef2fcfde22f3b2469b02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">executes a blocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns all jobs  <a href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c">More...</a><br /></td></tr>
<tr class="separator:ab596ce6c762ef2fcfde22f3b2469b02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0e88fca3d4b493e3f90d98efd23ea6"><td class="memItemLeft" align="right" valign="top">const IntResponseMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6">synchronize_nowait</a> ()</td></tr>
<tr class="memdesc:a2a0e88fca3d4b493e3f90d98efd23ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns a partial set of completed jobs  <a href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6">More...</a><br /></td></tr>
<tr class="separator:a2a0e88fca3d4b493e3f90d98efd23ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582aaa84632e91b7e27efaf011c585fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe">serve_evaluations</a> ()</td></tr>
<tr class="memdesc:a582aaa84632e91b7e27efaf011c585fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">run on evaluation servers to serve the iterator master  <a href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe">More...</a><br /></td></tr>
<tr class="separator:a582aaa84632e91b7e27efaf011c585fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26356baa3f4edc1c7b134d8d74bb02b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a26356baa3f4edc1c7b134d8d74bb02b6">stop_evaluation_servers</a> ()</td></tr>
<tr class="memdesc:a26356baa3f4edc1c7b134d8d74bb02b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by the iterator master to terminate evaluation servers  <a href="classDakota_1_1ApplicationInterface.html#a26356baa3f4edc1c7b134d8d74bb02b6">More...</a><br /></td></tr>
<tr class="separator:a26356baa3f4edc1c7b134d8d74bb02b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af482eda849683e6baa73138240c8b22b"><td class="memItemLeft" align="right" valign="top"><a id="af482eda849683e6baa73138240c8b22b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#af482eda849683e6baa73138240c8b22b">check_multiprocessor_analysis</a> (bool warn)</td></tr>
<tr class="memdesc:af482eda849683e6baa73138240c8b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks on multiprocessor analysis configuration <br /></td></tr>
<tr class="separator:af482eda849683e6baa73138240c8b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632542b2eecc76e6a87f7a1c785822bd"><td class="memItemLeft" align="right" valign="top"><a id="a632542b2eecc76e6a87f7a1c785822bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a632542b2eecc76e6a87f7a1c785822bd">check_asynchronous</a> (bool warn, int max_eval_concurrency)</td></tr>
<tr class="memdesc:a632542b2eecc76e6a87f7a1c785822bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks on asynchronous configuration (for direct interfaces) <br /></td></tr>
<tr class="separator:a632542b2eecc76e6a87f7a1c785822bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bff8873dd6254b2d440300cfe76104"><td class="memItemLeft" align="right" valign="top"><a id="a52bff8873dd6254b2d440300cfe76104"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a52bff8873dd6254b2d440300cfe76104">check_multiprocessor_asynchronous</a> (bool warn, int max_eval_concurrency)</td></tr>
<tr class="memdesc:a52bff8873dd6254b2d440300cfe76104"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks on asynchronous settings for multiprocessor partitions <br /></td></tr>
<tr class="separator:a52bff8873dd6254b2d440300cfe76104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f18ded4d1ed85e2acbcb58340ed0130"><td class="memItemLeft" align="right" valign="top"><a id="a5f18ded4d1ed85e2acbcb58340ed0130"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a5f18ded4d1ed85e2acbcb58340ed0130">final_batch_id_tag</a> ()</td></tr>
<tr class="memdesc:a5f18ded4d1ed85e2acbcb58340ed0130"><td class="mdescLeft">&#160;</td><td class="mdescRight">form and return the final batch ID tag <br /></td></tr>
<tr class="separator:a5f18ded4d1ed85e2acbcb58340ed0130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70c12f41f85168080d1e68b0334258a"><td class="memItemLeft" align="right" valign="top"><a id="af70c12f41f85168080d1e68b0334258a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#af70c12f41f85168080d1e68b0334258a">derived_map</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars, const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;set, <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;response, int fn_eval_id)</td></tr>
<tr class="memdesc:af70c12f41f85168080d1e68b0334258a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca" title="Provides a &quot;mapping&quot; of variables to responses using a simulation. Protected due to Interface letter-...">map()</a> and other functions to execute the simulation in synchronous mode. The portion of performing an evaluation that is specific to a derived class. <br /></td></tr>
<tr class="separator:af70c12f41f85168080d1e68b0334258a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f199698e5566a07258c04affb6272ce"><td class="memItemLeft" align="right" valign="top"><a id="a0f199698e5566a07258c04affb6272ce"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a0f199698e5566a07258c04affb6272ce">derived_map_asynch</a> (const <a class="el" href="classDakota_1_1ParamResponsePair.html">ParamResponsePair</a> &amp;pair)</td></tr>
<tr class="memdesc:a0f199698e5566a07258c04affb6272ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca" title="Provides a &quot;mapping&quot; of variables to responses using a simulation. Protected due to Interface letter-...">map()</a> and other functions to execute the simulation in asynchronous mode. The portion of performing an asynchronous evaluation that is specific to a derived class. <br /></td></tr>
<tr class="separator:a0f199698e5566a07258c04affb6272ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae893e24d141849c533e4d1cda641a12"><td class="memItemLeft" align="right" valign="top"><a id="aae893e24d141849c533e4d1cda641a12"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aae893e24d141849c533e4d1cda641a12">wait_local_evaluations</a> (PRPQueue &amp;prp_queue)</td></tr>
<tr class="memdesc:aae893e24d141849c533e4d1cda641a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">For asynchronous function evaluations, this method is used to detect completion of jobs and process their results. It provides the processing code that is specific to derived classes. This version waits for at least one completion. <br /></td></tr>
<tr class="separator:aae893e24d141849c533e4d1cda641a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6f6329d17c2e4f8c0d03247ddbb3aa"><td class="memItemLeft" align="right" valign="top"><a id="a7e6f6329d17c2e4f8c0d03247ddbb3aa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a7e6f6329d17c2e4f8c0d03247ddbb3aa">test_local_evaluations</a> (PRPQueue &amp;prp_queue)</td></tr>
<tr class="memdesc:a7e6f6329d17c2e4f8c0d03247ddbb3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">For asynchronous function evaluations, this method is used to detect completion of jobs and process their results. It provides the processing code that is specific to derived classes. This version is nonblocking and will return without any completions if none are immediately available. <br /></td></tr>
<tr class="separator:a7e6f6329d17c2e4f8c0d03247ddbb3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ce13ff49174b08eda5e60edf0dff9b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a14ce13ff49174b08eda5e60edf0dff9b">init_communicators_checks</a> (int max_eval_concurrency)</td></tr>
<tr class="memdesc:a14ce13ff49174b08eda5e60edf0dff9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform construct-time error checks on the parallel configuration  <a href="classDakota_1_1ApplicationInterface.html#a14ce13ff49174b08eda5e60edf0dff9b">More...</a><br /></td></tr>
<tr class="separator:a14ce13ff49174b08eda5e60edf0dff9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d398ffaf3368f949a8b85f058b81cbd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a5d398ffaf3368f949a8b85f058b81cbd">set_communicators_checks</a> (int max_eval_concurrency)</td></tr>
<tr class="memdesc:a5d398ffaf3368f949a8b85f058b81cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform run-time error checks on the parallel configuration  <a href="classDakota_1_1ApplicationInterface.html#a5d398ffaf3368f949a8b85f058b81cbd">More...</a><br /></td></tr>
<tr class="separator:a5d398ffaf3368f949a8b85f058b81cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ed4408a7d7e35a26926f11c35df548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aa4ed4408a7d7e35a26926f11c35df548">master_dynamic_schedule_analyses</a> ()</td></tr>
<tr class="memdesc:aa4ed4408a7d7e35a26926f11c35df548"><td class="mdescLeft">&#160;</td><td class="mdescRight">blocking dynamic schedule of all analyses within a function evaluation using message passing  <a href="classDakota_1_1ApplicationInterface.html#aa4ed4408a7d7e35a26926f11c35df548">More...</a><br /></td></tr>
<tr class="separator:aa4ed4408a7d7e35a26926f11c35df548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f27ad37fa3d1b1cffa08074b24bd984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a1f27ad37fa3d1b1cffa08074b24bd984">serve_analyses_synch</a> ()</td></tr>
<tr class="memdesc:a1f27ad37fa3d1b1cffa08074b24bd984"><td class="mdescLeft">&#160;</td><td class="mdescRight">serve the master analysis scheduler and manage one synchronous analysis job at a time  <a href="classDakota_1_1ApplicationInterface.html#a1f27ad37fa3d1b1cffa08074b24bd984">More...</a><br /></td></tr>
<tr class="separator:a1f27ad37fa3d1b1cffa08074b24bd984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac113ddb7fbad0221941b365f4260f2d8"><td class="memItemLeft" align="right" valign="top"><a id="ac113ddb7fbad0221941b365f4260f2d8"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ac113ddb7fbad0221941b365f4260f2d8">synchronous_local_analysis</a> (int analysis_id)</td></tr>
<tr class="memdesc:ac113ddb7fbad0221941b365f4260f2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a particular analysis (identified by analysis_id) synchronously on the local processor. Used for the derived class specifics within <a class="el" href="classDakota_1_1ApplicationInterface.html#a1f27ad37fa3d1b1cffa08074b24bd984" title="serve the master analysis scheduler and manage one synchronous analysis job at a time">ApplicationInterface::serve_analyses_synch()</a>. <br /></td></tr>
<tr class="separator:ac113ddb7fbad0221941b365f4260f2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classDakota_1_1Interface"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classDakota_1_1Interface')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classDakota_1_1Interface.html">Interface</a></td></tr>
<tr class="memitem:a545a3ef4f1a3e42908fc40e7384c6a59 inherit pro_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a545a3ef4f1a3e42908fc40e7384c6a59">Interface</a> (<a class="el" href="structDakota_1_1BaseConstructor.html">BaseConstructor</a>, const <a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db)</td></tr>
<tr class="memdesc:a545a3ef4f1a3e42908fc40e7384c6a59 inherit pro_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor initializes the base class part of letter classes (<a class="el" href="structDakota_1_1BaseConstructor.html" title="Dummy struct for overloading letter-envelope constructors.">BaseConstructor</a> overloading avoids infinite recursion in the derived class constructors - Coplien, p. 139)  <a href="classDakota_1_1Interface.html#a545a3ef4f1a3e42908fc40e7384c6a59">More...</a><br /></td></tr>
<tr class="separator:a545a3ef4f1a3e42908fc40e7384c6a59 inherit pro_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298a5a47f990fa22ba956e30c0842fca inherit pro_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a298a5a47f990fa22ba956e30c0842fca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a298a5a47f990fa22ba956e30c0842fca">Interface</a> (<a class="el" href="structDakota_1_1NoDBBaseConstructor.html">NoDBBaseConstructor</a>, size_t num_fns, short output_level)</td></tr>
<tr class="memdesc:a298a5a47f990fa22ba956e30c0842fca inherit pro_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor initializes the base class part of letter classes (<a class="el" href="structDakota_1_1NoDBBaseConstructor.html" title="Dummy struct for overloading constructors used in on-the-fly instantiations without ProblemDescDB sup...">NoDBBaseConstructor</a> used for on the fly instantiations without a DB) <br /></td></tr>
<tr class="separator:a298a5a47f990fa22ba956e30c0842fca inherit pro_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff147190625e01b76c74dc9db9e00e7d inherit pro_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aff147190625e01b76c74dc9db9e00e7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aff147190625e01b76c74dc9db9e00e7d">init_algebraic_mappings</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars, const <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;response)</td></tr>
<tr class="memdesc:aff147190625e01b76c74dc9db9e00e7d inherit pro_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define algebraicACVIndices, algebraicACVIds, and algebraicFnIndices. <br /></td></tr>
<tr class="separator:aff147190625e01b76c74dc9db9e00e7d inherit pro_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02f8927aa1f36ba589f134afed81572 inherit pro_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ac02f8927aa1f36ba589f134afed81572"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ac02f8927aa1f36ba589f134afed81572">asv_mapping</a> (const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;total_set, <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;algebraic_set, <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;core_set)</td></tr>
<tr class="memdesc:ac02f8927aa1f36ba589f134afed81572 inherit pro_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">define the evaluation requirements for <a class="el" href="classDakota_1_1Interface.html#a1aa0c1950d0a220faf872eabb3d7b80f" title="evaluate the algebraic_response using the AMPL solver library and the data extracted from the algebra...">algebraic_mappings()</a> (algebraic_set) and the core Application/Approximation mapping (core_set) from the total <a class="el" href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy.">Interface</a> evaluation requirements (total_set) <br /></td></tr>
<tr class="separator:ac02f8927aa1f36ba589f134afed81572 inherit pro_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b960ea4394e243a93d426a14e370ea inherit pro_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a88b960ea4394e243a93d426a14e370ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a88b960ea4394e243a93d426a14e370ea">asv_mapping</a> (const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;algebraic_set, <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;total_set)</td></tr>
<tr class="memdesc:a88b960ea4394e243a93d426a14e370ea inherit pro_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">map an algebraic ASV back to original total ordering for asynch recovery <br /></td></tr>
<tr class="separator:a88b960ea4394e243a93d426a14e370ea inherit pro_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa0c1950d0a220faf872eabb3d7b80f inherit pro_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a1aa0c1950d0a220faf872eabb3d7b80f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a1aa0c1950d0a220faf872eabb3d7b80f">algebraic_mappings</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars, const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;algebraic_set, <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;algebraic_response)</td></tr>
<tr class="memdesc:a1aa0c1950d0a220faf872eabb3d7b80f inherit pro_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the algebraic_response using the AMPL solver library and the data extracted from the algebraic_mappings file <br /></td></tr>
<tr class="separator:a1aa0c1950d0a220faf872eabb3d7b80f inherit pro_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d30d89ba4839abe946d4fb551ee63c inherit pro_methods_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a96d30d89ba4839abe946d4fb551ee63c">response_mapping</a> (const <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;algebraic_response, const <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;core_response, <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;total_response)</td></tr>
<tr class="memdesc:a96d30d89ba4839abe946d4fb551ee63c inherit pro_methods_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">combine the response from <a class="el" href="classDakota_1_1Interface.html#a1aa0c1950d0a220faf872eabb3d7b80f" title="evaluate the algebraic_response using the AMPL solver library and the data extracted from the algebra...">algebraic_mappings()</a> with the response from derived_map() to create the total response  <a href="classDakota_1_1Interface.html#a96d30d89ba4839abe946d4fb551ee63c">More...</a><br /></td></tr>
<tr class="separator:a96d30d89ba4839abe946d4fb551ee63c inherit pro_methods_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a702abf9be22e51f1e67167d5db1b08d3"><td class="memItemLeft" align="right" valign="top"><a id="a702abf9be22e51f1e67167d5db1b08d3"></a>
<a class="el" href="classDakota_1_1ParallelLibrary.html">ParallelLibrary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">parallelLib</a></td></tr>
<tr class="memdesc:a702abf9be22e51f1e67167d5db1b08d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to the <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a> object used to manage MPI partitions for the concurrent evaluations and concurrent analyses parallelism levels <br /></td></tr>
<tr class="separator:a702abf9be22e51f1e67167d5db1b08d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f4d590328220339cfb50a746b7c232"><td class="memItemLeft" align="right" valign="top"><a id="a90f4d590328220339cfb50a746b7c232"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a90f4d590328220339cfb50a746b7c232">batchEval</a></td></tr>
<tr class="memdesc:a90f4d590328220339cfb50a746b7c232"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating usage of batch evaluation facilities, where a set of jobs is launched and scheduled as a unit rather than individually <br /></td></tr>
<tr class="separator:a90f4d590328220339cfb50a746b7c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0924909ff8aeeaa795f4cd5947ab4e2e"><td class="memItemLeft" align="right" valign="top"><a id="a0924909ff8aeeaa795f4cd5947ab4e2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a0924909ff8aeeaa795f4cd5947ab4e2e">asynchFlag</a></td></tr>
<tr class="memdesc:a0924909ff8aeeaa795f4cd5947ab4e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating usage of asynchronous evaluation <br /></td></tr>
<tr class="separator:a0924909ff8aeeaa795f4cd5947ab4e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51849bf663477c45df7f3c5416c0b6af"><td class="memItemLeft" align="right" valign="top"><a id="a51849bf663477c45df7f3c5416c0b6af"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a51849bf663477c45df7f3c5416c0b6af">batchIdCntr</a></td></tr>
<tr class="memdesc:a51849bf663477c45df7f3c5416c0b6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">maintain a count of the batches <br /></td></tr>
<tr class="separator:a51849bf663477c45df7f3c5416c0b6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbfef0e1ded466ad119085c812f3084"><td class="memItemLeft" align="right" valign="top"><a id="a3bbfef0e1ded466ad119085c812f3084"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a3bbfef0e1ded466ad119085c812f3084">suppressOutput</a></td></tr>
<tr class="memdesc:a3bbfef0e1ded466ad119085c812f3084"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for suppressing output on slave processors <br /></td></tr>
<tr class="separator:a3bbfef0e1ded466ad119085c812f3084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2829ae9b39c629e8ce474e08320b24ce"><td class="memItemLeft" align="right" valign="top"><a id="a2829ae9b39c629e8ce474e08320b24ce"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a2829ae9b39c629e8ce474e08320b24ce">evalCommSize</a></td></tr>
<tr class="memdesc:a2829ae9b39c629e8ce474e08320b24ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of evalComm <br /></td></tr>
<tr class="separator:a2829ae9b39c629e8ce474e08320b24ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544a69f893c0bb3c93c67354f9f83889"><td class="memItemLeft" align="right" valign="top"><a id="a544a69f893c0bb3c93c67354f9f83889"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a544a69f893c0bb3c93c67354f9f83889">evalCommRank</a></td></tr>
<tr class="memdesc:a544a69f893c0bb3c93c67354f9f83889"><td class="mdescLeft">&#160;</td><td class="mdescRight">processor rank within evalComm <br /></td></tr>
<tr class="separator:a544a69f893c0bb3c93c67354f9f83889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac570f6d6cb4162823292f88ad6f425b3"><td class="memItemLeft" align="right" valign="top"><a id="ac570f6d6cb4162823292f88ad6f425b3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ac570f6d6cb4162823292f88ad6f425b3">evalServerId</a></td></tr>
<tr class="memdesc:ac570f6d6cb4162823292f88ad6f425b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluation server identifier <br /></td></tr>
<tr class="separator:ac570f6d6cb4162823292f88ad6f425b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0052a3d9a1554b63464053cd8e7b42f3"><td class="memItemLeft" align="right" valign="top"><a id="a0052a3d9a1554b63464053cd8e7b42f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a0052a3d9a1554b63464053cd8e7b42f3">eaDedMasterFlag</a></td></tr>
<tr class="memdesc:a0052a3d9a1554b63464053cd8e7b42f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for dedicated master partitioning at ea level <br /></td></tr>
<tr class="separator:a0052a3d9a1554b63464053cd8e7b42f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04233bf7e2e2d88db5f4d9e941c2290c"><td class="memItemLeft" align="right" valign="top"><a id="a04233bf7e2e2d88db5f4d9e941c2290c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a04233bf7e2e2d88db5f4d9e941c2290c">analysisCommSize</a></td></tr>
<tr class="memdesc:a04233bf7e2e2d88db5f4d9e941c2290c"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of analysisComm <br /></td></tr>
<tr class="separator:a04233bf7e2e2d88db5f4d9e941c2290c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326384df4de6ef4fcb2ac847b7d95e07"><td class="memItemLeft" align="right" valign="top"><a id="a326384df4de6ef4fcb2ac847b7d95e07"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a326384df4de6ef4fcb2ac847b7d95e07">analysisCommRank</a></td></tr>
<tr class="memdesc:a326384df4de6ef4fcb2ac847b7d95e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">processor rank within analysisComm <br /></td></tr>
<tr class="separator:a326384df4de6ef4fcb2ac847b7d95e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5579c773e0c27aabb0ec50b5d7820b"><td class="memItemLeft" align="right" valign="top"><a id="abe5579c773e0c27aabb0ec50b5d7820b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#abe5579c773e0c27aabb0ec50b5d7820b">analysisServerId</a></td></tr>
<tr class="memdesc:abe5579c773e0c27aabb0ec50b5d7820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">analysis server identifier <br /></td></tr>
<tr class="separator:abe5579c773e0c27aabb0ec50b5d7820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be21657eaaafd3f78287e4f67dbd01b"><td class="memItemLeft" align="right" valign="top"><a id="a8be21657eaaafd3f78287e4f67dbd01b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a8be21657eaaafd3f78287e4f67dbd01b">numAnalysisServers</a></td></tr>
<tr class="memdesc:a8be21657eaaafd3f78287e4f67dbd01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">current number of analysis servers <br /></td></tr>
<tr class="separator:a8be21657eaaafd3f78287e4f67dbd01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa575b69a2031947dcf82ed3fe10642b8"><td class="memItemLeft" align="right" valign="top"><a id="aa575b69a2031947dcf82ed3fe10642b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aa575b69a2031947dcf82ed3fe10642b8">multiProcAnalysisFlag</a></td></tr>
<tr class="memdesc:aa575b69a2031947dcf82ed3fe10642b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for multiprocessor analysis partitions <br /></td></tr>
<tr class="separator:aa575b69a2031947dcf82ed3fe10642b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b038f5130d6a8af05206561bcda1d5e"><td class="memItemLeft" align="right" valign="top"><a id="a6b038f5130d6a8af05206561bcda1d5e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a6b038f5130d6a8af05206561bcda1d5e">asynchLocalAnalysisFlag</a></td></tr>
<tr class="memdesc:a6b038f5130d6a8af05206561bcda1d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for asynchronous local parallelism of analyses <br /></td></tr>
<tr class="separator:a6b038f5130d6a8af05206561bcda1d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2db1b1de2eae7b6d08b77b49e12a1d0"><td class="memItemLeft" align="right" valign="top"><a id="ae2db1b1de2eae7b6d08b77b49e12a1d0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ae2db1b1de2eae7b6d08b77b49e12a1d0">asynchLocalAnalysisConcurrency</a></td></tr>
<tr class="memdesc:ae2db1b1de2eae7b6d08b77b49e12a1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">limits the number of concurrent analyses in asynchronous local scheduling and specifies hybrid concurrency when message passing <br /></td></tr>
<tr class="separator:ae2db1b1de2eae7b6d08b77b49e12a1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac990e9757aa3fc8336ee796e0c49d782"><td class="memItemLeft" align="right" valign="top"><a id="ac990e9757aa3fc8336ee796e0c49d782"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ac990e9757aa3fc8336ee796e0c49d782">asynchLocalEvalConcSpec</a></td></tr>
<tr class="memdesc:ac990e9757aa3fc8336ee796e0c49d782"><td class="mdescLeft">&#160;</td><td class="mdescRight">user specification for asynchronous local evaluation concurrency <br /></td></tr>
<tr class="separator:ac990e9757aa3fc8336ee796e0c49d782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60da3f12635ce42a4943bf76dfe5aff"><td class="memItemLeft" align="right" valign="top"><a id="ad60da3f12635ce42a4943bf76dfe5aff"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ad60da3f12635ce42a4943bf76dfe5aff">asynchLocalAnalysisConcSpec</a></td></tr>
<tr class="memdesc:ad60da3f12635ce42a4943bf76dfe5aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">user specification for asynchronous local analysis concurrency <br /></td></tr>
<tr class="separator:ad60da3f12635ce42a4943bf76dfe5aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2264b09fe59e7046d035a0f828dbe25e"><td class="memItemLeft" align="right" valign="top"><a id="a2264b09fe59e7046d035a0f828dbe25e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a2264b09fe59e7046d035a0f828dbe25e">numAnalysisDrivers</a></td></tr>
<tr class="memdesc:a2264b09fe59e7046d035a0f828dbe25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of analysis drivers used for each function evaluation (from the analysis_drivers interface specification) <br /></td></tr>
<tr class="separator:a2264b09fe59e7046d035a0f828dbe25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4483d7a723e778421cf06201990cf49"><td class="memItemLeft" align="right" valign="top"><a id="ae4483d7a723e778421cf06201990cf49"></a>
IntSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ae4483d7a723e778421cf06201990cf49">completionSet</a></td></tr>
<tr class="memdesc:ae4483d7a723e778421cf06201990cf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">the set of completed fn_eval_id's populated by <a class="el" href="classDakota_1_1ApplicationInterface.html#aae893e24d141849c533e4d1cda641a12" title="For asynchronous function evaluations, this method is used to detect completion of jobs and process t...">wait_local_evaluations()</a> and <a class="el" href="classDakota_1_1ApplicationInterface.html#a7e6f6329d17c2e4f8c0d03247ddbb3aa" title="For asynchronous function evaluations, this method is used to detect completion of jobs and process t...">test_local_evaluations()</a> <br /></td></tr>
<tr class="separator:ae4483d7a723e778421cf06201990cf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fbf410322d2f04ec681a4431cd23d7"><td class="memItemLeft" align="right" valign="top"><a id="af1fbf410322d2f04ec681a4431cd23d7"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#af1fbf410322d2f04ec681a4431cd23d7">failureMessage</a></td></tr>
<tr class="memdesc:af1fbf410322d2f04ec681a4431cd23d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">base message for managing failed evals; will be followed with more details in screen output <br /></td></tr>
<tr class="separator:af1fbf410322d2f04ec681a4431cd23d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classDakota_1_1Interface"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classDakota_1_1Interface')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classDakota_1_1Interface.html">Interface</a></td></tr>
<tr class="memitem:a49a9dda05ef271e5ad2836c4616a3e14 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a49a9dda05ef271e5ad2836c4616a3e14"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a49a9dda05ef271e5ad2836c4616a3e14">interfaceType</a></td></tr>
<tr class="memdesc:a49a9dda05ef271e5ad2836c4616a3e14 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface type: enum for system, fork, direct, grid, or approximation <br /></td></tr>
<tr class="separator:a49a9dda05ef271e5ad2836c4616a3e14 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74107aa656556a11207a60b23f83de34 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a74107aa656556a11207a60b23f83de34"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a74107aa656556a11207a60b23f83de34">interfaceId</a></td></tr>
<tr class="memdesc:a74107aa656556a11207a60b23f83de34 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface specification identifier string from the DAKOTA input file <br /></td></tr>
<tr class="separator:a74107aa656556a11207a60b23f83de34 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57d2d0f9d852999681ddc6139a9bba9 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="af57d2d0f9d852999681ddc6139a9bba9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#af57d2d0f9d852999681ddc6139a9bba9">algebraicMappings</a></td></tr>
<tr class="memdesc:af57d2d0f9d852999681ddc6139a9bba9 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for the presence of algebraic_mappings that define the subset of an <a class="el" href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy.">Interface</a>'s parameter to response mapping that is explicit and algebraic. <br /></td></tr>
<tr class="separator:af57d2d0f9d852999681ddc6139a9bba9 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1f045107cac3e8b7586eeee1e681ce inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aaa1f045107cac3e8b7586eeee1e681ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aaa1f045107cac3e8b7586eeee1e681ce">coreMappings</a></td></tr>
<tr class="memdesc:aaa1f045107cac3e8b7586eeee1e681ce inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for the presence of non-algebraic mappings that define the core of an <a class="el" href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy.">Interface</a>'s parameter to response mapping (using analysis_drivers for <a class="el" href="classDakota_1_1ApplicationInterface.html" title="Derived class within the interface class hierarchy for supporting interfaces to simulation codes.">ApplicationInterface</a> or functionSurfaces for <a class="el" href="classDakota_1_1ApproximationInterface.html" title="Derived class within the interface class hierarchy for supporting approximations to simulation-based ...">ApproximationInterface</a>). <br /></td></tr>
<tr class="separator:aaa1f045107cac3e8b7586eeee1e681ce inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b080aab3a786ee1439b43c3533f1f6a inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a8b080aab3a786ee1439b43c3533f1f6a"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a8b080aab3a786ee1439b43c3533f1f6a">outputLevel</a></td></tr>
<tr class="memdesc:a8b080aab3a786ee1439b43c3533f1f6a inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">output verbosity level: {SILENT,QUIET,NORMAL,VERBOSE,DEBUG}_OUTPUT <br /></td></tr>
<tr class="separator:a8b080aab3a786ee1439b43c3533f1f6a inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7d467110a2230d5eeb40a7f673f3a1 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aba7d467110a2230d5eeb40a7f673f3a1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aba7d467110a2230d5eeb40a7f673f3a1">currEvalId</a></td></tr>
<tr class="memdesc:aba7d467110a2230d5eeb40a7f673f3a1 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">identifier for the current evaluation, which may differ from the evaluation counters in the case of evaluation scheduling; used on iterator master as well as server processors. Currently, this is set prior to all invocations of derived_map() for all processors. <br /></td></tr>
<tr class="separator:aba7d467110a2230d5eeb40a7f673f3a1 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42b3f90172d75af753f2f5a6dea6c66 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="af42b3f90172d75af753f2f5a6dea6c66"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#af42b3f90172d75af753f2f5a6dea6c66">fineGrainEvalCounters</a></td></tr>
<tr class="memdesc:af42b3f90172d75af753f2f5a6dea6c66 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls use of fn val/grad/hess counters for detailed evaluation report <br /></td></tr>
<tr class="separator:af42b3f90172d75af753f2f5a6dea6c66 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4591fe231e7a0dde20125a8f6cdf60f inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ab4591fe231e7a0dde20125a8f6cdf60f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ab4591fe231e7a0dde20125a8f6cdf60f">evalIdCntr</a></td></tr>
<tr class="memdesc:ab4591fe231e7a0dde20125a8f6cdf60f inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">total interface evaluation counter <br /></td></tr>
<tr class="separator:ab4591fe231e7a0dde20125a8f6cdf60f inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fd5f8fb59a0675573022a4913405ef inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a17fd5f8fb59a0675573022a4913405ef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a17fd5f8fb59a0675573022a4913405ef">newEvalIdCntr</a></td></tr>
<tr class="memdesc:a17fd5f8fb59a0675573022a4913405ef inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">new (non-duplicate) interface evaluation counter <br /></td></tr>
<tr class="separator:a17fd5f8fb59a0675573022a4913405ef inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a594d268e41d98c563084caf4dc2305 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a7a594d268e41d98c563084caf4dc2305"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a7a594d268e41d98c563084caf4dc2305">evalIdRefPt</a></td></tr>
<tr class="memdesc:a7a594d268e41d98c563084caf4dc2305 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration reference point for evalIdCntr <br /></td></tr>
<tr class="separator:a7a594d268e41d98c563084caf4dc2305 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312061d1731c2bb3fa288f4e74b0e942 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a312061d1731c2bb3fa288f4e74b0e942"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a312061d1731c2bb3fa288f4e74b0e942">newEvalIdRefPt</a></td></tr>
<tr class="memdesc:a312061d1731c2bb3fa288f4e74b0e942 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration reference point for newEvalIdCntr <br /></td></tr>
<tr class="separator:a312061d1731c2bb3fa288f4e74b0e942 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c372d7fdf062ccb9e274d00576e4df8 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a6c372d7fdf062ccb9e274d00576e4df8"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a6c372d7fdf062ccb9e274d00576e4df8">fnValCounter</a></td></tr>
<tr class="memdesc:a6c372d7fdf062ccb9e274d00576e4df8 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of value evaluations by resp fn <br /></td></tr>
<tr class="separator:a6c372d7fdf062ccb9e274d00576e4df8 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae233c9963bc34d3126348743744f7c6e inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ae233c9963bc34d3126348743744f7c6e"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ae233c9963bc34d3126348743744f7c6e">fnGradCounter</a></td></tr>
<tr class="memdesc:ae233c9963bc34d3126348743744f7c6e inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of gradient evaluations by resp fn <br /></td></tr>
<tr class="separator:ae233c9963bc34d3126348743744f7c6e inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81bfeadbb95bc6b8693151115a160d0 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ac81bfeadbb95bc6b8693151115a160d0"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ac81bfeadbb95bc6b8693151115a160d0">fnHessCounter</a></td></tr>
<tr class="memdesc:ac81bfeadbb95bc6b8693151115a160d0 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of Hessian evaluations by resp fn <br /></td></tr>
<tr class="separator:ac81bfeadbb95bc6b8693151115a160d0 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7125772868c4504a748528e904708b inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a3c7125772868c4504a748528e904708b"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a3c7125772868c4504a748528e904708b">newFnValCounter</a></td></tr>
<tr class="memdesc:a3c7125772868c4504a748528e904708b inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of new value evaluations by resp fn <br /></td></tr>
<tr class="separator:a3c7125772868c4504a748528e904708b inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa3b89f09cca1163c10c072dbb5f524 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a9aa3b89f09cca1163c10c072dbb5f524"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a9aa3b89f09cca1163c10c072dbb5f524">newFnGradCounter</a></td></tr>
<tr class="memdesc:a9aa3b89f09cca1163c10c072dbb5f524 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of new gradient evaluations by resp fn <br /></td></tr>
<tr class="separator:a9aa3b89f09cca1163c10c072dbb5f524 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca056ffecbf760f32d45ece5ae1e07c inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a4ca056ffecbf760f32d45ece5ae1e07c"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a4ca056ffecbf760f32d45ece5ae1e07c">newFnHessCounter</a></td></tr>
<tr class="memdesc:a4ca056ffecbf760f32d45ece5ae1e07c inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of new Hessian evaluations by resp fn <br /></td></tr>
<tr class="separator:a4ca056ffecbf760f32d45ece5ae1e07c inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43579cc815d367b4b984c9c3b73fbbd1 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a43579cc815d367b4b984c9c3b73fbbd1"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a43579cc815d367b4b984c9c3b73fbbd1">fnValRefPt</a></td></tr>
<tr class="memdesc:a43579cc815d367b4b984c9c3b73fbbd1 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration reference point for fnValCounter <br /></td></tr>
<tr class="separator:a43579cc815d367b4b984c9c3b73fbbd1 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17be1692e211b0be2b7bf10c6deddaf0 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a17be1692e211b0be2b7bf10c6deddaf0"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a17be1692e211b0be2b7bf10c6deddaf0">fnGradRefPt</a></td></tr>
<tr class="memdesc:a17be1692e211b0be2b7bf10c6deddaf0 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration reference point for fnGradCounter <br /></td></tr>
<tr class="separator:a17be1692e211b0be2b7bf10c6deddaf0 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c89553881753e455ef764e2b83e417 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a61c89553881753e455ef764e2b83e417"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a61c89553881753e455ef764e2b83e417">fnHessRefPt</a></td></tr>
<tr class="memdesc:a61c89553881753e455ef764e2b83e417 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration reference point for fnHessCounter <br /></td></tr>
<tr class="separator:a61c89553881753e455ef764e2b83e417 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3393a873a05345bc6fedbf560b9918dc inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a3393a873a05345bc6fedbf560b9918dc"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a3393a873a05345bc6fedbf560b9918dc">newFnValRefPt</a></td></tr>
<tr class="memdesc:a3393a873a05345bc6fedbf560b9918dc inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration reference point for newFnValCounter <br /></td></tr>
<tr class="separator:a3393a873a05345bc6fedbf560b9918dc inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad2dae35f5b036ea06722ea09a1daf4 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a6ad2dae35f5b036ea06722ea09a1daf4"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a6ad2dae35f5b036ea06722ea09a1daf4">newFnGradRefPt</a></td></tr>
<tr class="memdesc:a6ad2dae35f5b036ea06722ea09a1daf4 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration reference point for newFnGradCounter <br /></td></tr>
<tr class="separator:a6ad2dae35f5b036ea06722ea09a1daf4 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9b1812fe1aeb54ec691f5d1d0cacbf inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a3c9b1812fe1aeb54ec691f5d1d0cacbf"></a>
IntArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a3c9b1812fe1aeb54ec691f5d1d0cacbf">newFnHessRefPt</a></td></tr>
<tr class="memdesc:a3c9b1812fe1aeb54ec691f5d1d0cacbf inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration reference point for newFnHessCounter <br /></td></tr>
<tr class="separator:a3c9b1812fe1aeb54ec691f5d1d0cacbf inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad326a6acce0df29ad63ca5d0b15e90bb inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top">IntResponseMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ad326a6acce0df29ad63ca5d0b15e90bb">rawResponseMap</a></td></tr>
<tr class="memdesc:ad326a6acce0df29ad63ca5d0b15e90bb inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of responses returned by either a blocking or nonblocking schedule.  <a href="classDakota_1_1Interface.html#ad326a6acce0df29ad63ca5d0b15e90bb">More...</a><br /></td></tr>
<tr class="separator:ad326a6acce0df29ad63ca5d0b15e90bb inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add30d7adf4fe103543f4b103a14b9a34 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="add30d7adf4fe103543f4b103a14b9a34"></a>
IntResponseMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#add30d7adf4fe103543f4b103a14b9a34">cachedResponseMap</a></td></tr>
<tr class="memdesc:add30d7adf4fe103543f4b103a14b9a34 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of available asynchronous responses completed within a blocking or nonblocking scheduler that cannot be processed in a higher level context and need to be stored for later. <br /></td></tr>
<tr class="separator:add30d7adf4fe103543f4b103a14b9a34 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c760dcaaa649f4ab521700fbb436a42 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a4c760dcaaa649f4ab521700fbb436a42"></a>
StringArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a4c760dcaaa649f4ab521700fbb436a42">fnLabels</a></td></tr>
<tr class="memdesc:a4c760dcaaa649f4ab521700fbb436a42 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">response function descriptors (used in <a class="el" href="classDakota_1_1Interface.html#aeec4c3557548a39013458dd6a348fece" title="print an evaluation summary for the interface">print_evaluation_summary()</a> and derived direct interface classes); initialized in <a class="el" href="classDakota_1_1Interface.html#a999c6f807e9ea92b96d6bbc2f7873cca" title="the function evaluator: provides a &quot;mapping&quot; from the variables to the responses.">map()</a> functions due to potential updates after construction <br /></td></tr>
<tr class="separator:a4c760dcaaa649f4ab521700fbb436a42 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a33a6b07c4c6f5d757d214de0f47ca inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="af5a33a6b07c4c6f5d757d214de0f47ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#af5a33a6b07c4c6f5d757d214de0f47ca">multiProcEvalFlag</a></td></tr>
<tr class="memdesc:af5a33a6b07c4c6f5d757d214de0f47ca inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for multiprocessor evaluation partitions (evalComm) <br /></td></tr>
<tr class="separator:af5a33a6b07c4c6f5d757d214de0f47ca inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161f6c7c983b691604ad7e07b52b886e inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="a161f6c7c983b691604ad7e07b52b886e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#a161f6c7c983b691604ad7e07b52b886e">ieDedMasterFlag</a></td></tr>
<tr class="memdesc:a161f6c7c983b691604ad7e07b52b886e inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for dedicated master partitioning at the iterator level <br /></td></tr>
<tr class="separator:a161f6c7c983b691604ad7e07b52b886e inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25bb42702517fd27302ddfd99249cf7 inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="aa25bb42702517fd27302ddfd99249cf7"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#aa25bb42702517fd27302ddfd99249cf7">evalTagPrefix</a></td></tr>
<tr class="memdesc:aa25bb42702517fd27302ddfd99249cf7 inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">set of period-delimited evaluation ID tags to use in evaluation tagging <br /></td></tr>
<tr class="separator:aa25bb42702517fd27302ddfd99249cf7 inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1420b3829ceeec66bc0a1daac806f7d inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="ad1420b3829ceeec66bc0a1daac806f7d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#ad1420b3829ceeec66bc0a1daac806f7d">appendIfaceId</a></td></tr>
<tr class="memdesc:ad1420b3829ceeec66bc0a1daac806f7d inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to append the interface ID to the prefix during map (default true) <br /></td></tr>
<tr class="separator:ad1420b3829ceeec66bc0a1daac806f7d inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affca708fb244c540cf2b34d00aae31ad inherit pro_attribs_classDakota_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a id="affca708fb244c540cf2b34d00aae31ad"></a>
String2DArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Interface.html#affca708fb244c540cf2b34d00aae31ad">analysisComponents</a></td></tr>
<tr class="memdesc:affca708fb244c540cf2b34d00aae31ad inherit pro_attribs_classDakota_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis components for interface types that support them. <br /></td></tr>
<tr class="separator:affca708fb244c540cf2b34d00aae31ad inherit pro_attribs_classDakota_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9a8aa9d923ded9d5bec27388a535a483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a9a8aa9d923ded9d5bec27388a535a483">duplication_detect</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars, <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;response, bool asynch_flag)</td></tr>
<tr class="memdesc:a9a8aa9d923ded9d5bec27388a535a483"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks data_pairs and beforeSynchCorePRPQueue to see if the current evaluation request has already been performed or queued  <a href="classDakota_1_1ApplicationInterface.html#a9a8aa9d923ded9d5bec27388a535a483">More...</a><br /></td></tr>
<tr class="separator:a9a8aa9d923ded9d5bec27388a535a483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81807c1636a9dae3d146c997db1d980d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a81807c1636a9dae3d146c997db1d980d">init_default_asv</a> (size_t num_fns)</td></tr>
<tr class="memdesc:a81807c1636a9dae3d146c997db1d980d"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize default ASV if needed; this is done at run time due to post-construct time <a class="el" href="classDakota_1_1Response.html" title="Container class for response functions and their derivatives.   Response provides the enveloper base ...">Response</a> size changes.  <a href="classDakota_1_1ApplicationInterface.html#a81807c1636a9dae3d146c997db1d980d">More...</a><br /></td></tr>
<tr class="separator:a81807c1636a9dae3d146c997db1d980d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c9b27b4fd7483615896e0b26553e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a81c9b27b4fd7483615896e0b26553e12">master_dynamic_schedule_evaluations</a> ()</td></tr>
<tr class="memdesc:a81c9b27b4fd7483615896e0b26553e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">blocking dynamic schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a dedicated master partition; executes on iteratorComm master  <a href="classDakota_1_1ApplicationInterface.html#a81c9b27b4fd7483615896e0b26553e12">More...</a><br /></td></tr>
<tr class="separator:a81c9b27b4fd7483615896e0b26553e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94c7702163e6591d63bac4a08c48201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ae94c7702163e6591d63bac4a08c48201">peer_static_schedule_evaluations</a> ()</td></tr>
<tr class="memdesc:ae94c7702163e6591d63bac4a08c48201"><td class="mdescLeft">&#160;</td><td class="mdescRight">blocking static schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a peer partition; executes on iteratorComm master  <a href="classDakota_1_1ApplicationInterface.html#ae94c7702163e6591d63bac4a08c48201">More...</a><br /></td></tr>
<tr class="separator:ae94c7702163e6591d63bac4a08c48201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0c1bebc31beef5e63c586ee5ab2102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aee0c1bebc31beef5e63c586ee5ab2102">peer_dynamic_schedule_evaluations</a> ()</td></tr>
<tr class="memdesc:aee0c1bebc31beef5e63c586ee5ab2102"><td class="mdescLeft">&#160;</td><td class="mdescRight">blocking dynamic schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a peer partition; executes on iteratorComm master  <a href="classDakota_1_1ApplicationInterface.html#aee0c1bebc31beef5e63c586ee5ab2102">More...</a><br /></td></tr>
<tr class="separator:aee0c1bebc31beef5e63c586ee5ab2102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656ccb76e0320bc17c37d30142e77fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a656ccb76e0320bc17c37d30142e77fa9">asynchronous_local_evaluations</a> (PRPQueue &amp;prp_queue)</td></tr>
<tr class="memdesc:a656ccb76e0320bc17c37d30142e77fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform all jobs in prp_queue using asynchronous approaches on the local processor  <a href="classDakota_1_1ApplicationInterface.html#a656ccb76e0320bc17c37d30142e77fa9">More...</a><br /></td></tr>
<tr class="separator:a656ccb76e0320bc17c37d30142e77fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8bb538639ac5ed543d5098b8ab9ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a7e8bb538639ac5ed543d5098b8ab9ee3">synchronous_local_evaluations</a> (PRPQueue &amp;prp_queue)</td></tr>
<tr class="memdesc:a7e8bb538639ac5ed543d5098b8ab9ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform all jobs in prp_queue using synchronous approaches on the local processor  <a href="classDakota_1_1ApplicationInterface.html#a7e8bb538639ac5ed543d5098b8ab9ee3">More...</a><br /></td></tr>
<tr class="separator:a7e8bb538639ac5ed543d5098b8ab9ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec8ac43798133cf0bd94cbf6fff50a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a5ec8ac43798133cf0bd94cbf6fff50a4">master_dynamic_schedule_evaluations_nowait</a> ()</td></tr>
<tr class="memdesc:a5ec8ac43798133cf0bd94cbf6fff50a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">execute a nonblocking dynamic schedule in a master-slave partition  <a href="classDakota_1_1ApplicationInterface.html#a5ec8ac43798133cf0bd94cbf6fff50a4">More...</a><br /></td></tr>
<tr class="separator:a5ec8ac43798133cf0bd94cbf6fff50a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4f9eafe638564737e1b96934a09bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#abb4f9eafe638564737e1b96934a09bea">peer_static_schedule_evaluations_nowait</a> ()</td></tr>
<tr class="memdesc:abb4f9eafe638564737e1b96934a09bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">execute a nonblocking static schedule in a peer partition  <a href="classDakota_1_1ApplicationInterface.html#abb4f9eafe638564737e1b96934a09bea">More...</a><br /></td></tr>
<tr class="separator:abb4f9eafe638564737e1b96934a09bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5531a6d9294fd47a6cb6153df68403dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a5531a6d9294fd47a6cb6153df68403dc">peer_dynamic_schedule_evaluations_nowait</a> ()</td></tr>
<tr class="memdesc:a5531a6d9294fd47a6cb6153df68403dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">execute a nonblocking dynamic schedule in a peer partition  <a href="classDakota_1_1ApplicationInterface.html#a5531a6d9294fd47a6cb6153df68403dc">More...</a><br /></td></tr>
<tr class="separator:a5531a6d9294fd47a6cb6153df68403dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1185f9bf9f8c28564cc17e321c270c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#af1185f9bf9f8c28564cc17e321c270c1">asynchronous_local_evaluations_nowait</a> (PRPQueue &amp;prp_queue)</td></tr>
<tr class="memdesc:af1185f9bf9f8c28564cc17e321c270c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">launch new jobs in prp_queue asynchronously (if capacity is available), perform nonblocking query of all running jobs, and process any completed jobs (handles both local master- and local peer-scheduling cases)  <a href="classDakota_1_1ApplicationInterface.html#af1185f9bf9f8c28564cc17e321c270c1">More...</a><br /></td></tr>
<tr class="separator:af1185f9bf9f8c28564cc17e321c270c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa4a63f6d149a9ccf16709967b553d3"><td class="memItemLeft" align="right" valign="top"><a id="a4fa4a63f6d149a9ccf16709967b553d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a4fa4a63f6d149a9ccf16709967b553d3">broadcast_evaluation</a> (const <a class="el" href="classDakota_1_1ParamResponsePair.html">ParamResponsePair</a> &amp;pair)</td></tr>
<tr class="memdesc:a4fa4a63f6d149a9ccf16709967b553d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for broadcasting an evaluation over an evalComm <br /></td></tr>
<tr class="separator:a4fa4a63f6d149a9ccf16709967b553d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad968b9a522f71bd9836a491e3439af97"><td class="memItemLeft" align="right" valign="top"><a id="ad968b9a522f71bd9836a491e3439af97"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ad968b9a522f71bd9836a491e3439af97">broadcast_evaluation</a> (int fn_eval_id, const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars, const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;set)</td></tr>
<tr class="memdesc:ad968b9a522f71bd9836a491e3439af97"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for broadcasting an evaluation over an evalComm <br /></td></tr>
<tr class="separator:ad968b9a522f71bd9836a491e3439af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4733cf30510ad34288d04049a7455811"><td class="memItemLeft" align="right" valign="top"><a id="a4733cf30510ad34288d04049a7455811"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a4733cf30510ad34288d04049a7455811">send_evaluation</a> (PRPQueueIter &amp;prp_it, size_t buff_index, int server_id, bool peer_flag)</td></tr>
<tr class="memdesc:a4733cf30510ad34288d04049a7455811"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for sending sendBuffers[buff_index] to server <br /></td></tr>
<tr class="separator:a4733cf30510ad34288d04049a7455811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf4da80f8dd52b62ebdb184bc91ac1f"><td class="memItemLeft" align="right" valign="top"><a id="a5bf4da80f8dd52b62ebdb184bc91ac1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a5bf4da80f8dd52b62ebdb184bc91ac1f">receive_evaluation</a> (PRPQueueIter &amp;prp_it, size_t buff_index, int server_id, bool peer_flag)</td></tr>
<tr class="memdesc:a5bf4da80f8dd52b62ebdb184bc91ac1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for processing recvBuffers[buff_index] within scheduler <br /></td></tr>
<tr class="separator:a5bf4da80f8dd52b62ebdb184bc91ac1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad281347a0d46cea1d522b81cf672b0b3"><td class="memItemLeft" align="right" valign="top"><a id="ad281347a0d46cea1d522b81cf672b0b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ad281347a0d46cea1d522b81cf672b0b3">launch_asynch_local</a> (PRPQueueIter &amp;prp_it)</td></tr>
<tr class="memdesc:ad281347a0d46cea1d522b81cf672b0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">launch an asynchronous local evaluation from a queue iterator <br /></td></tr>
<tr class="separator:ad281347a0d46cea1d522b81cf672b0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868da21c2e9aa2858f88568ed1aa2b8e"><td class="memItemLeft" align="right" valign="top"><a id="a868da21c2e9aa2858f88568ed1aa2b8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a868da21c2e9aa2858f88568ed1aa2b8e">launch_asynch_local</a> (<a class="el" href="classDakota_1_1MPIUnpackBuffer.html">MPIUnpackBuffer</a> &amp;recv_buffer, int fn_eval_id)</td></tr>
<tr class="memdesc:a868da21c2e9aa2858f88568ed1aa2b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">launch an asynchronous local evaluation from a receive buffer <br /></td></tr>
<tr class="separator:a868da21c2e9aa2858f88568ed1aa2b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ed784d1b217d14cadd6dabc2bd0543"><td class="memItemLeft" align="right" valign="top"><a id="ae5ed784d1b217d14cadd6dabc2bd0543"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ae5ed784d1b217d14cadd6dabc2bd0543">process_asynch_local</a> (int fn_eval_id)</td></tr>
<tr class="memdesc:ae5ed784d1b217d14cadd6dabc2bd0543"><td class="mdescLeft">&#160;</td><td class="mdescRight">process a completed asynchronous local evaluation <br /></td></tr>
<tr class="separator:ae5ed784d1b217d14cadd6dabc2bd0543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cfdce1a9f84f8bf8040dde47e0e88d"><td class="memItemLeft" align="right" valign="top"><a id="a35cfdce1a9f84f8bf8040dde47e0e88d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a35cfdce1a9f84f8bf8040dde47e0e88d">process_synch_local</a> (PRPQueueIter &amp;prp_it)</td></tr>
<tr class="memdesc:a35cfdce1a9f84f8bf8040dde47e0e88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">process a completed synchronous local evaluation <br /></td></tr>
<tr class="separator:a35cfdce1a9f84f8bf8040dde47e0e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc753ace80d3219f927d6aa299f3ddd"><td class="memItemLeft" align="right" valign="top"><a id="a0dc753ace80d3219f927d6aa299f3ddd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a0dc753ace80d3219f927d6aa299f3ddd">assign_asynch_local_queue</a> (PRPQueue &amp;local_prp_queue, PRPQueueIter &amp;local_prp_iter)</td></tr>
<tr class="memdesc:a0dc753ace80d3219f927d6aa299f3ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for creating an initial active local queue by launching asynch local jobs from local_prp_queue, as limited by server capacity <br /></td></tr>
<tr class="separator:a0dc753ace80d3219f927d6aa299f3ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5924e44a3371e6ae107d5e5ccd3da8"><td class="memItemLeft" align="right" valign="top"><a id="a5c5924e44a3371e6ae107d5e5ccd3da8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a5c5924e44a3371e6ae107d5e5ccd3da8">assign_asynch_local_queue_nowait</a> (PRPQueue &amp;local_prp_queue, PRPQueueIter &amp;local_prp_iter)</td></tr>
<tr class="memdesc:a5c5924e44a3371e6ae107d5e5ccd3da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for updating an active local queue by backfilling asynch local jobs from local_prp_queue, as limited by server capacity <br /></td></tr>
<tr class="separator:a5c5924e44a3371e6ae107d5e5ccd3da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80cc97b45f1fe804ea576301523f540"><td class="memItemLeft" align="right" valign="top"><a id="ae80cc97b45f1fe804ea576301523f540"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ae80cc97b45f1fe804ea576301523f540">test_local_backfill</a> (PRPQueue &amp;assign_queue, PRPQueueIter &amp;assign_iter)</td></tr>
<tr class="memdesc:ae80cc97b45f1fe804ea576301523f540"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for testing active asynch local jobs and then backfilling <br /></td></tr>
<tr class="separator:ae80cc97b45f1fe804ea576301523f540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8831ca059383efff1d8420f3eb26ef78"><td class="memItemLeft" align="right" valign="top"><a id="a8831ca059383efff1d8420f3eb26ef78"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a8831ca059383efff1d8420f3eb26ef78">test_receives_backfill</a> (PRPQueueIter &amp;assign_iter, bool peer_flag)</td></tr>
<tr class="memdesc:a8831ca059383efff1d8420f3eb26ef78"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for testing receive requests and then backfilling jobs <br /></td></tr>
<tr class="separator:a8831ca059383efff1d8420f3eb26ef78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706547d76f07b61b158ff8231b43e3ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a706547d76f07b61b158ff8231b43e3ea">serve_evaluations_synch</a> ()</td></tr>
<tr class="memdesc:a706547d76f07b61b158ff8231b43e3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">serve the evaluation message passing schedulers and perform one synchronous evaluation at a time  <a href="classDakota_1_1ApplicationInterface.html#a706547d76f07b61b158ff8231b43e3ea">More...</a><br /></td></tr>
<tr class="separator:a706547d76f07b61b158ff8231b43e3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203db1af5f56cb9186ffca180380333f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a203db1af5f56cb9186ffca180380333f">serve_evaluations_synch_peer</a> ()</td></tr>
<tr class="memdesc:a203db1af5f56cb9186ffca180380333f"><td class="mdescLeft">&#160;</td><td class="mdescRight">serve the evaluation message passing schedulers and perform one synchronous evaluation at a time as part of the 1st peer  <a href="classDakota_1_1ApplicationInterface.html#a203db1af5f56cb9186ffca180380333f">More...</a><br /></td></tr>
<tr class="separator:a203db1af5f56cb9186ffca180380333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fff53bc102ed8138a2e58fbe08c591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aa2fff53bc102ed8138a2e58fbe08c591">serve_evaluations_asynch</a> ()</td></tr>
<tr class="memdesc:aa2fff53bc102ed8138a2e58fbe08c591"><td class="mdescLeft">&#160;</td><td class="mdescRight">serve the evaluation message passing schedulers and manage multiple asynchronous evaluations  <a href="classDakota_1_1ApplicationInterface.html#aa2fff53bc102ed8138a2e58fbe08c591">More...</a><br /></td></tr>
<tr class="separator:aa2fff53bc102ed8138a2e58fbe08c591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09809d49a953208a059e0c349db956b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a09809d49a953208a059e0c349db956b9">serve_evaluations_asynch_peer</a> ()</td></tr>
<tr class="memdesc:a09809d49a953208a059e0c349db956b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">serve the evaluation message passing schedulers and perform multiple asynchronous evaluations as part of the 1st peer  <a href="classDakota_1_1ApplicationInterface.html#a09809d49a953208a059e0c349db956b9">More...</a><br /></td></tr>
<tr class="separator:a09809d49a953208a059e0c349db956b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8443e24a98b7b910fae18a0f69de25d"><td class="memItemLeft" align="right" valign="top"><a id="af8443e24a98b7b910fae18a0f69de25d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#af8443e24a98b7b910fae18a0f69de25d">set_evaluation_communicators</a> (const IntArray &amp;message_lengths)</td></tr>
<tr class="memdesc:af8443e24a98b7b910fae18a0f69de25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for updating the local evaluation partition data following <a class="el" href="classDakota_1_1ParallelLibrary.html#a4cac3384b8e1ed264dfe378b431ccd5b" title="split an iterator communicator into evaluation communicators">ParallelLibrary::init_evaluation_communicators()</a>. <br /></td></tr>
<tr class="separator:af8443e24a98b7b910fae18a0f69de25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d01b5826a9cc3adf495349d46543dc8"><td class="memItemLeft" align="right" valign="top"><a id="a7d01b5826a9cc3adf495349d46543dc8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a7d01b5826a9cc3adf495349d46543dc8">set_analysis_communicators</a> ()</td></tr>
<tr class="memdesc:a7d01b5826a9cc3adf495349d46543dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for updating the local analysis partition data following <a class="el" href="classDakota_1_1ParallelLibrary.html#a2e16ae037307a23a6df3e29066259425" title="split an evaluation communicator into analysis communicators">ParallelLibrary::init_analysis_communicators()</a>. <br /></td></tr>
<tr class="separator:a7d01b5826a9cc3adf495349d46543dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7a5c550fdc711de12ef8d230a34309"><td class="memItemLeft" align="right" valign="top"><a id="a2d7a5c550fdc711de12ef8d230a34309"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a2d7a5c550fdc711de12ef8d230a34309">init_serial_evaluations</a> ()</td></tr>
<tr class="memdesc:a2d7a5c550fdc711de12ef8d230a34309"><td class="mdescLeft">&#160;</td><td class="mdescRight">set concurrent evaluation configuration for serial operations <br /></td></tr>
<tr class="separator:a2d7a5c550fdc711de12ef8d230a34309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbb9928f8cbc892d01d7d23333e65e9"><td class="memItemLeft" align="right" valign="top"><a id="acdbb9928f8cbc892d01d7d23333e65e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#acdbb9928f8cbc892d01d7d23333e65e9">init_serial_analyses</a> ()</td></tr>
<tr class="memdesc:acdbb9928f8cbc892d01d7d23333e65e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set concurrent analysis configuration for serial operations (e.g., for local executions on a dedicated master) <br /></td></tr>
<tr class="separator:acdbb9928f8cbc892d01d7d23333e65e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa0490849ca62cab0a16cd643fa8df5"><td class="memItemLeft" align="right" valign="top"><a id="a9fa0490849ca62cab0a16cd643fa8df5"></a>
const <a class="el" href="classDakota_1_1ParamResponsePair.html">ParamResponsePair</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a9fa0490849ca62cab0a16cd643fa8df5">get_source_pair</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;target_vars)</td></tr>
<tr class="memdesc:a9fa0490849ca62cab0a16cd643fa8df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for the continuation approach in <a class="el" href="classDakota_1_1ApplicationInterface.html#a460bf8a4bf5698bc403ca958c1950941" title="manages a simulation failure using abort/retry/recover/continuation">manage_failure()</a> for finding the nearest successful "source" evaluation to the failed "target" <br /></td></tr>
<tr class="separator:a9fa0490849ca62cab0a16cd643fa8df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5239453d233a9f1cce6e02789d57745a"><td class="memItemLeft" align="right" valign="top"><a id="a5239453d233a9f1cce6e02789d57745a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a5239453d233a9f1cce6e02789d57745a">continuation</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;target_vars, const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;set, <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;response, const <a class="el" href="classDakota_1_1ParamResponsePair.html">ParamResponsePair</a> &amp;source_pair, int failed_eval_id)</td></tr>
<tr class="memdesc:a5239453d233a9f1cce6e02789d57745a"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a 0th order continuation method to step from a successful "source" evaluation to the failed "target". Invoked by <a class="el" href="classDakota_1_1ApplicationInterface.html#a460bf8a4bf5698bc403ca958c1950941" title="manages a simulation failure using abort/retry/recover/continuation">manage_failure()</a> for failAction == "continuation". <br /></td></tr>
<tr class="separator:a5239453d233a9f1cce6e02789d57745a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab8f4cc10d0900bb7236a96103f077c"><td class="memItemLeft" align="right" valign="top"><a id="a6ab8f4cc10d0900bb7236a96103f077c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a6ab8f4cc10d0900bb7236a96103f077c">common_input_filtering</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;vars)</td></tr>
<tr class="memdesc:a6ab8f4cc10d0900bb7236a96103f077c"><td class="mdescLeft">&#160;</td><td class="mdescRight">common input filtering operations, e.g. mesh movement <br /></td></tr>
<tr class="separator:a6ab8f4cc10d0900bb7236a96103f077c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6187bbf74155ebaade53000dd1bd5a8e"><td class="memItemLeft" align="right" valign="top"><a id="a6187bbf74155ebaade53000dd1bd5a8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a6187bbf74155ebaade53000dd1bd5a8e">common_output_filtering</a> (<a class="el" href="classDakota_1_1Response.html">Response</a> &amp;response)</td></tr>
<tr class="memdesc:a6187bbf74155ebaade53000dd1bd5a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">common output filtering operations, e.g. data filtering <br /></td></tr>
<tr class="separator:a6187bbf74155ebaade53000dd1bd5a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acd895cd03a97539649139ff052fd57fb"><td class="memItemLeft" align="right" valign="top"><a id="acd895cd03a97539649139ff052fd57fb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#acd895cd03a97539649139ff052fd57fb">worldSize</a></td></tr>
<tr class="memdesc:acd895cd03a97539649139ff052fd57fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of MPI_COMM_WORLD <br /></td></tr>
<tr class="separator:acd895cd03a97539649139ff052fd57fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc8912fbd115cf81e9721390d99e671"><td class="memItemLeft" align="right" valign="top"><a id="aacc8912fbd115cf81e9721390d99e671"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aacc8912fbd115cf81e9721390d99e671">worldRank</a></td></tr>
<tr class="memdesc:aacc8912fbd115cf81e9721390d99e671"><td class="mdescLeft">&#160;</td><td class="mdescRight">processor rank within MPI_COMM_WORLD <br /></td></tr>
<tr class="separator:aacc8912fbd115cf81e9721390d99e671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7bd63ee74d6bea2b43bfa23a6fff26"><td class="memItemLeft" align="right" valign="top"><a id="aaa7bd63ee74d6bea2b43bfa23a6fff26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aaa7bd63ee74d6bea2b43bfa23a6fff26">iteratorCommSize</a></td></tr>
<tr class="memdesc:aaa7bd63ee74d6bea2b43bfa23a6fff26"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of iteratorComm <br /></td></tr>
<tr class="separator:aaa7bd63ee74d6bea2b43bfa23a6fff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f0a3a3df16046123e8a234bfa39736"><td class="memItemLeft" align="right" valign="top"><a id="ab4f0a3a3df16046123e8a234bfa39736"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ab4f0a3a3df16046123e8a234bfa39736">iteratorCommRank</a></td></tr>
<tr class="memdesc:ab4f0a3a3df16046123e8a234bfa39736"><td class="mdescLeft">&#160;</td><td class="mdescRight">processor rank within iteratorComm <br /></td></tr>
<tr class="separator:ab4f0a3a3df16046123e8a234bfa39736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd02aa81cc207642f2ff0620c0abc97f"><td class="memItemLeft" align="right" valign="top"><a id="acd02aa81cc207642f2ff0620c0abc97f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#acd02aa81cc207642f2ff0620c0abc97f">ieMessagePass</a></td></tr>
<tr class="memdesc:acd02aa81cc207642f2ff0620c0abc97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for message passing at ie scheduling level <br /></td></tr>
<tr class="separator:acd02aa81cc207642f2ff0620c0abc97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b6bf5aee3ef76501106a7dac82712d"><td class="memItemLeft" align="right" valign="top"><a id="a32b6bf5aee3ef76501106a7dac82712d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a32b6bf5aee3ef76501106a7dac82712d">numEvalServers</a></td></tr>
<tr class="memdesc:a32b6bf5aee3ef76501106a7dac82712d"><td class="mdescLeft">&#160;</td><td class="mdescRight">current number of evaluation servers <br /></td></tr>
<tr class="separator:a32b6bf5aee3ef76501106a7dac82712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98acb44e72b879ce2c45b6bfebcdc7f3"><td class="memItemLeft" align="right" valign="top"><a id="a98acb44e72b879ce2c45b6bfebcdc7f3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a98acb44e72b879ce2c45b6bfebcdc7f3">numEvalServersSpec</a></td></tr>
<tr class="memdesc:a98acb44e72b879ce2c45b6bfebcdc7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">user specification for number of evaluation servers <br /></td></tr>
<tr class="separator:a98acb44e72b879ce2c45b6bfebcdc7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7e4cb2187cf9f5e1791ac7e3046848"><td class="memItemLeft" align="right" valign="top"><a id="a2c7e4cb2187cf9f5e1791ac7e3046848"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a2c7e4cb2187cf9f5e1791ac7e3046848">procsPerEvalSpec</a></td></tr>
<tr class="memdesc:a2c7e4cb2187cf9f5e1791ac7e3046848"><td class="mdescLeft">&#160;</td><td class="mdescRight">user specification for processors per analysis servers <br /></td></tr>
<tr class="separator:a2c7e4cb2187cf9f5e1791ac7e3046848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa399037bf4158a61da0fdd42e3bc28e"><td class="memItemLeft" align="right" valign="top"><a id="aaa399037bf4158a61da0fdd42e3bc28e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aaa399037bf4158a61da0fdd42e3bc28e">eaMessagePass</a></td></tr>
<tr class="memdesc:aaa399037bf4158a61da0fdd42e3bc28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for message passing at ea scheduling level <br /></td></tr>
<tr class="separator:aaa399037bf4158a61da0fdd42e3bc28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660728523fd0173abf968733773f94cb"><td class="memItemLeft" align="right" valign="top"><a id="a660728523fd0173abf968733773f94cb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a660728523fd0173abf968733773f94cb">numAnalysisServersSpec</a></td></tr>
<tr class="memdesc:a660728523fd0173abf968733773f94cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">user spec for number of analysis servers <br /></td></tr>
<tr class="separator:a660728523fd0173abf968733773f94cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0868f449cf0e488c77124c2d01939a"><td class="memItemLeft" align="right" valign="top"><a id="ada0868f449cf0e488c77124c2d01939a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ada0868f449cf0e488c77124c2d01939a">procsPerAnalysisSpec</a></td></tr>
<tr class="memdesc:ada0868f449cf0e488c77124c2d01939a"><td class="mdescLeft">&#160;</td><td class="mdescRight">user specification for processors per analysis servers <br /></td></tr>
<tr class="separator:ada0868f449cf0e488c77124c2d01939a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4ce5b03b18230289cbbff64013e79a"><td class="memItemLeft" align="right" valign="top"><a id="a1f4ce5b03b18230289cbbff64013e79a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a1f4ce5b03b18230289cbbff64013e79a">lenVarsMessage</a></td></tr>
<tr class="memdesc:a1f4ce5b03b18230289cbbff64013e79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of a <a class="el" href="classDakota_1_1MPIPackBuffer.html" title="Class for packing MPI message buffers.">MPIPackBuffer</a> containing a <a class="el" href="classDakota_1_1Variables.html" title="Base class for the variables class hierarchy.">Variables</a> object; computed in <a class="el" href="classDakota_1_1Model.html#a1278c4690947e75993a8faa2d1722315" title="allocate communicator partitions for a model and store configuration in modelPCIterMap">Model::init_communicators()</a> <br /></td></tr>
<tr class="separator:a1f4ce5b03b18230289cbbff64013e79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd93698b70eb2916e2e9f4f8c73c5f2"><td class="memItemLeft" align="right" valign="top"><a id="aafd93698b70eb2916e2e9f4f8c73c5f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aafd93698b70eb2916e2e9f4f8c73c5f2">lenVarsActSetMessage</a></td></tr>
<tr class="memdesc:aafd93698b70eb2916e2e9f4f8c73c5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of a <a class="el" href="classDakota_1_1MPIPackBuffer.html" title="Class for packing MPI message buffers.">MPIPackBuffer</a> containing a <a class="el" href="classDakota_1_1Variables.html" title="Base class for the variables class hierarchy.">Variables</a> object and an <a class="el" href="classDakota_1_1ActiveSet.html" title="Container class for active set tracking information. Contains the active set request vector and the d...">ActiveSet</a> object; computed in <a class="el" href="classDakota_1_1Model.html#a1278c4690947e75993a8faa2d1722315" title="allocate communicator partitions for a model and store configuration in modelPCIterMap">Model::init_communicators()</a> <br /></td></tr>
<tr class="separator:aafd93698b70eb2916e2e9f4f8c73c5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b2bb80cf1124a93e1f2e5aed290b24"><td class="memItemLeft" align="right" valign="top"><a id="a25b2bb80cf1124a93e1f2e5aed290b24"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a25b2bb80cf1124a93e1f2e5aed290b24">lenResponseMessage</a></td></tr>
<tr class="memdesc:a25b2bb80cf1124a93e1f2e5aed290b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of a <a class="el" href="classDakota_1_1MPIPackBuffer.html" title="Class for packing MPI message buffers.">MPIPackBuffer</a> containing a <a class="el" href="classDakota_1_1Response.html" title="Container class for response functions and their derivatives.   Response provides the enveloper base ...">Response</a> object; computed in <a class="el" href="classDakota_1_1Model.html#a1278c4690947e75993a8faa2d1722315" title="allocate communicator partitions for a model and store configuration in modelPCIterMap">Model::init_communicators()</a> <br /></td></tr>
<tr class="separator:a25b2bb80cf1124a93e1f2e5aed290b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a794a4c9c1404793a047179c05a947a"><td class="memItemLeft" align="right" valign="top"><a id="a8a794a4c9c1404793a047179c05a947a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a8a794a4c9c1404793a047179c05a947a">lenPRPairMessage</a></td></tr>
<tr class="memdesc:a8a794a4c9c1404793a047179c05a947a"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of a <a class="el" href="classDakota_1_1MPIPackBuffer.html" title="Class for packing MPI message buffers.">MPIPackBuffer</a> containing a <a class="el" href="classDakota_1_1ParamResponsePair.html" title="Container class for a variables object, a response object, and an evaluation id.">ParamResponsePair</a> object; computed in <a class="el" href="classDakota_1_1Model.html#a1278c4690947e75993a8faa2d1722315" title="allocate communicator partitions for a model and store configuration in modelPCIterMap">Model::init_communicators()</a> <br /></td></tr>
<tr class="separator:a8a794a4c9c1404793a047179c05a947a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae467ea8b7a060dd5a9af31dc712c0ec5"><td class="memItemLeft" align="right" valign="top"><a id="ae467ea8b7a060dd5a9af31dc712c0ec5"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ae467ea8b7a060dd5a9af31dc712c0ec5">evalScheduling</a></td></tr>
<tr class="memdesc:ae467ea8b7a060dd5a9af31dc712c0ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">user specification of evaluation scheduling algorithm: {DEFAULT,MASTER,PEER_DYNAMIC,PEER_STATIC}_SCHEDULING. Used for manual overrides of auto-configure logic in <a class="el" href="classDakota_1_1ParallelLibrary.html#a4fc3318534a53f8f6410436f3c739dba" title="resolve user inputs into a sensible partitioning scheme">ParallelLibrary::resolve_inputs()</a>. <br /></td></tr>
<tr class="separator:ae467ea8b7a060dd5a9af31dc712c0ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abc4a56e2c40adb9618e5a98dccb4b3"><td class="memItemLeft" align="right" valign="top"><a id="a8abc4a56e2c40adb9618e5a98dccb4b3"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a8abc4a56e2c40adb9618e5a98dccb4b3">analysisScheduling</a></td></tr>
<tr class="memdesc:a8abc4a56e2c40adb9618e5a98dccb4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">user specification of analysis scheduling algorithm: {DEFAULT,MASTER,PEER}_SCHEDULING. Used for manual overrides of the auto-configure logic in <a class="el" href="classDakota_1_1ParallelLibrary.html#a4fc3318534a53f8f6410436f3c739dba" title="resolve user inputs into a sensible partitioning scheme">ParallelLibrary::resolve_inputs()</a>. <br /></td></tr>
<tr class="separator:a8abc4a56e2c40adb9618e5a98dccb4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0968f1e0bd0c496620975c39d01866c8"><td class="memItemLeft" align="right" valign="top"><a id="a0968f1e0bd0c496620975c39d01866c8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">asynchLocalEvalConcurrency</a></td></tr>
<tr class="memdesc:a0968f1e0bd0c496620975c39d01866c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">limits the number of concurrent evaluations in asynchronous local scheduling and specifies hybrid concurrency when message passing <br /></td></tr>
<tr class="separator:a0968f1e0bd0c496620975c39d01866c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcd55897256c6a8bdc75361ec153d8e"><td class="memItemLeft" align="right" valign="top"><a id="a2bcd55897256c6a8bdc75361ec153d8e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a2bcd55897256c6a8bdc75361ec153d8e">asynchLocalEvalStatic</a></td></tr>
<tr class="memdesc:a2bcd55897256c6a8bdc75361ec153d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the asynchronous local evaluations are to be performed with a static schedule (default false) <br /></td></tr>
<tr class="separator:a2bcd55897256c6a8bdc75361ec153d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aec1801f646ee1e65562c9cf9c52a0d"><td class="memItemLeft" align="right" valign="top"><a id="a4aec1801f646ee1e65562c9cf9c52a0d"></a>
BitArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a4aec1801f646ee1e65562c9cf9c52a0d">localServerAssigned</a></td></tr>
<tr class="memdesc:a4aec1801f646ee1e65562c9cf9c52a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">array with one bit per logical "server" indicating whether a job is currently running on the server (used for asynch local static schedules) <br /></td></tr>
<tr class="separator:a4aec1801f646ee1e65562c9cf9c52a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8645103f86efb9a7a8ca04ca10561f96"><td class="memItemLeft" align="right" valign="top"><a id="a8645103f86efb9a7a8ca04ca10561f96"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a8645103f86efb9a7a8ca04ca10561f96">interfaceSynchronization</a></td></tr>
<tr class="memdesc:a8645103f86efb9a7a8ca04ca10561f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface synchronization specification: synchronous (default) or asynchronous <br /></td></tr>
<tr class="separator:a8645103f86efb9a7a8ca04ca10561f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d84b86ed363bf09f58b7a723e2c8a03"><td class="memItemLeft" align="right" valign="top"><a id="a5d84b86ed363bf09f58b7a723e2c8a03"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a5d84b86ed363bf09f58b7a723e2c8a03">headerFlag</a></td></tr>
<tr class="memdesc:a5d84b86ed363bf09f58b7a723e2c8a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by synchronize_nowait to manage header output frequency (since this function may be called many times prior to any completions) <br /></td></tr>
<tr class="separator:a5d84b86ed363bf09f58b7a723e2c8a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e9ca6f5c179f56728957c3b4dc1add"><td class="memItemLeft" align="right" valign="top"><a id="ab1e9ca6f5c179f56728957c3b4dc1add"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ab1e9ca6f5c179f56728957c3b4dc1add">asvControlFlag</a></td></tr>
<tr class="memdesc:ab1e9ca6f5c179f56728957c3b4dc1add"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to manage a user request to deactivate the active set vector control. true = modify the ASV each evaluation as appropriate (default); false = ASV values are static so that the user need not check them on each evaluation. <br /></td></tr>
<tr class="separator:ab1e9ca6f5c179f56728957c3b4dc1add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501fddba77066e5101c56b7c7ee573a2"><td class="memItemLeft" align="right" valign="top"><a id="a501fddba77066e5101c56b7c7ee573a2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a501fddba77066e5101c56b7c7ee573a2">evalCacheFlag</a></td></tr>
<tr class="memdesc:a501fddba77066e5101c56b7c7ee573a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to manage a user request to deactivate the function evaluation cache (i.e., queries and insertions using the data_pairs cache). <br /></td></tr>
<tr class="separator:a501fddba77066e5101c56b7c7ee573a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3e67a97c3d95139b18eab61952c6fd"><td class="memItemLeft" align="right" valign="top"><a id="a7e3e67a97c3d95139b18eab61952c6fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a7e3e67a97c3d95139b18eab61952c6fd">nearbyDuplicateDetect</a></td></tr>
<tr class="memdesc:a7e3e67a97c3d95139b18eab61952c6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating optional usage of tolerance-based duplication detection (less efficient, but helpful when experiencing restart cache misses) <br /></td></tr>
<tr class="separator:a7e3e67a97c3d95139b18eab61952c6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c54e0ba71c5d76a9e73695a53e3a2b4"><td class="memItemLeft" align="right" valign="top"><a id="a7c54e0ba71c5d76a9e73695a53e3a2b4"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a7c54e0ba71c5d76a9e73695a53e3a2b4">nearbyTolerance</a></td></tr>
<tr class="memdesc:a7c54e0ba71c5d76a9e73695a53e3a2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">tolerance value for tolerance-based duplication detection <br /></td></tr>
<tr class="separator:a7c54e0ba71c5d76a9e73695a53e3a2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac752f5f55e71a48bd0905d8849cb34de"><td class="memItemLeft" align="right" valign="top"><a id="ac752f5f55e71a48bd0905d8849cb34de"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ac752f5f55e71a48bd0905d8849cb34de">restartFileFlag</a></td></tr>
<tr class="memdesc:ac752f5f55e71a48bd0905d8849cb34de"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to manage a user request to deactivate the restart file (i.e., insertions into write_restart). <br /></td></tr>
<tr class="separator:ac752f5f55e71a48bd0905d8849cb34de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf85586a030d85f483d16c41336ad115"><td class="memItemLeft" align="right" valign="top"><a id="acf85586a030d85f483d16c41336ad115"></a>
<a class="el" href="classDakota_1_1SharedResponseData.html">SharedResponseData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#acf85586a030d85f483d16c41336ad115">sharedRespData</a></td></tr>
<tr class="memdesc:acf85586a030d85f483d16c41336ad115"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDakota_1_1SharedResponseData.html" title="Container class encapsulating variables data that can be shared among a set of Response instances.">SharedResponseData</a> of associated <a class="el" href="classDakota_1_1Response.html" title="Container class for response functions and their derivatives.   Response provides the enveloper base ...">Response</a>. <br /></td></tr>
<tr class="separator:acf85586a030d85f483d16c41336ad115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd75192e1d00f59bafbadb7984734fd"><td class="memItemLeft" align="right" valign="top"><a id="aefd75192e1d00f59bafbadb7984734fd"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aefd75192e1d00f59bafbadb7984734fd">gradientType</a></td></tr>
<tr class="memdesc:aefd75192e1d00f59bafbadb7984734fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of gradients present in associated <a class="el" href="classDakota_1_1Response.html" title="Container class for response functions and their derivatives.   Response provides the enveloper base ...">Response</a> <br /></td></tr>
<tr class="separator:aefd75192e1d00f59bafbadb7984734fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ab688b052b513a9f6e82d785d2e4ea"><td class="memItemLeft" align="right" valign="top"><a id="a58ab688b052b513a9f6e82d785d2e4ea"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a58ab688b052b513a9f6e82d785d2e4ea">hessianType</a></td></tr>
<tr class="memdesc:a58ab688b052b513a9f6e82d785d2e4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of Hessians present in associated <a class="el" href="classDakota_1_1Response.html" title="Container class for response functions and their derivatives.   Response provides the enveloper base ...">Response</a> <br /></td></tr>
<tr class="separator:a58ab688b052b513a9f6e82d785d2e4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0eeba22fedf9cd0edfe1626ccd1847"><td class="memItemLeft" align="right" valign="top"><a id="a0c0eeba22fedf9cd0edfe1626ccd1847"></a>
IntSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a0c0eeba22fedf9cd0edfe1626ccd1847">gradMixedAnalyticIds</a></td></tr>
<tr class="memdesc:a0c0eeba22fedf9cd0edfe1626ccd1847"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDs of analytic gradients when mixed gradients present. <br /></td></tr>
<tr class="separator:a0c0eeba22fedf9cd0edfe1626ccd1847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0965f813800d1659b071bf3cc86ff18b"><td class="memItemLeft" align="right" valign="top"><a id="a0965f813800d1659b071bf3cc86ff18b"></a>
IntSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a0965f813800d1659b071bf3cc86ff18b">hessMixedAnalyticIds</a></td></tr>
<tr class="memdesc:a0965f813800d1659b071bf3cc86ff18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDs of analytic gradients when mixed gradients present. <br /></td></tr>
<tr class="separator:a0965f813800d1659b071bf3cc86ff18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86968f57416404f124a3df401ba2a6e8"><td class="memItemLeft" align="right" valign="top"><a id="a86968f57416404f124a3df401ba2a6e8"></a>
ShortArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a86968f57416404f124a3df401ba2a6e8">defaultASV</a></td></tr>
<tr class="memdesc:a86968f57416404f124a3df401ba2a6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">the static ASV values used when the user has selected asvControl = off <br /></td></tr>
<tr class="separator:a86968f57416404f124a3df401ba2a6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d54a681c49b50a7ce009ec4a3bd81a"><td class="memItemLeft" align="right" valign="top"><a id="a76d54a681c49b50a7ce009ec4a3bd81a"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a76d54a681c49b50a7ce009ec4a3bd81a">failAction</a></td></tr>
<tr class="memdesc:a76d54a681c49b50a7ce009ec4a3bd81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">mitigation action for captured simulation failures: abort, retry, recover, or continuation <br /></td></tr>
<tr class="separator:a76d54a681c49b50a7ce009ec4a3bd81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561ed3df5ec20ac0c0b52ce9c2e507a2"><td class="memItemLeft" align="right" valign="top"><a id="a561ed3df5ec20ac0c0b52ce9c2e507a2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a561ed3df5ec20ac0c0b52ce9c2e507a2">failRetryLimit</a></td></tr>
<tr class="memdesc:a561ed3df5ec20ac0c0b52ce9c2e507a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">limit on the number of retries for the retry failAction <br /></td></tr>
<tr class="separator:a561ed3df5ec20ac0c0b52ce9c2e507a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf98d8a875fcac52dad820208a3e2854"><td class="memItemLeft" align="right" valign="top"><a id="acf98d8a875fcac52dad820208a3e2854"></a>
RealVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#acf98d8a875fcac52dad820208a3e2854">failRecoveryFnVals</a></td></tr>
<tr class="memdesc:acf98d8a875fcac52dad820208a3e2854"><td class="mdescLeft">&#160;</td><td class="mdescRight">the dummy function values used for the recover failAction <br /></td></tr>
<tr class="separator:acf98d8a875fcac52dad820208a3e2854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6075d512ae619e50a3af54bd18a7ead9"><td class="memItemLeft" align="right" valign="top"><a id="a6075d512ae619e50a3af54bd18a7ead9"></a>
IntResponseMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a6075d512ae619e50a3af54bd18a7ead9">historyDuplicateMap</a></td></tr>
<tr class="memdesc:a6075d512ae619e50a3af54bd18a7ead9"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to bookkeep asynchronous evaluations which duplicate data_pairs evaluations. Map key is evalIdCntr, map value is corresponding response. <br /></td></tr>
<tr class="separator:a6075d512ae619e50a3af54bd18a7ead9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae839b9b58b9857ffc6df3dd0b0ad7daf"><td class="memItemLeft" align="right" valign="top"><a id="ae839b9b58b9857ffc6df3dd0b0ad7daf"></a>
std::map&lt; int, std::pair&lt; PRPQueueHIter, <a class="el" href="classDakota_1_1Response.html">Response</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#ae839b9b58b9857ffc6df3dd0b0ad7daf">beforeSynchDuplicateMap</a></td></tr>
<tr class="memdesc:ae839b9b58b9857ffc6df3dd0b0ad7daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to bookkeep evalIdCntr, beforeSynchCorePRPQueue iterator, and response of asynchronous evaluations which duplicate queued beforeSynchCorePRPQueue evaluations <br /></td></tr>
<tr class="separator:ae839b9b58b9857ffc6df3dd0b0ad7daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d589aa531ab9b0ba74cdfc21187f2e"><td class="memItemLeft" align="right" valign="top"><a id="a02d589aa531ab9b0ba74cdfc21187f2e"></a>
PRPQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">beforeSynchCorePRPQueue</a></td></tr>
<tr class="memdesc:a02d589aa531ab9b0ba74cdfc21187f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to bookkeep vars/set/response of nonduplicate asynchronous core evaluations. This is the queue of jobs populated by asynchronous <a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca" title="Provides a &quot;mapping&quot; of variables to responses using a simulation. Protected due to Interface letter-...">map()</a> that is later scheduled in <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c" title="executes a blocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns ...">synchronize()</a> or <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6" title="executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and retur...">synchronize_nowait()</a>. <br /></td></tr>
<tr class="separator:a02d589aa531ab9b0ba74cdfc21187f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886e2da92ce6e1339ba66bcb76784824"><td class="memItemLeft" align="right" valign="top"><a id="a886e2da92ce6e1339ba66bcb76784824"></a>
PRPQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a886e2da92ce6e1339ba66bcb76784824">beforeSynchAlgPRPQueue</a></td></tr>
<tr class="memdesc:a886e2da92ce6e1339ba66bcb76784824"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to bookkeep vars/set/response of asynchronous algebraic evaluations. This is the queue of algebraic jobs populated by asynchronous <a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca" title="Provides a &quot;mapping&quot; of variables to responses using a simulation. Protected due to Interface letter-...">map()</a> that is later evaluated in <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c" title="executes a blocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns ...">synchronize()</a> or <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6" title="executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and retur...">synchronize_nowait()</a>. <br /></td></tr>
<tr class="separator:a886e2da92ce6e1339ba66bcb76784824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5a374107d8655a79736242fb121deb"><td class="memItemLeft" align="right" valign="top"><a id="add5a374107d8655a79736242fb121deb"></a>
PRPQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#add5a374107d8655a79736242fb121deb">asynchLocalActivePRPQueue</a></td></tr>
<tr class="memdesc:add5a374107d8655a79736242fb121deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by nonblocking asynchronous local schedulers to bookkeep active local jobs <br /></td></tr>
<tr class="separator:add5a374107d8655a79736242fb121deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a30dfb5b4461c9f007e640d8e1ccd9"><td class="memItemLeft" align="right" valign="top"><a id="a57a30dfb5b4461c9f007e640d8e1ccd9"></a>
std::map&lt; int, IntSizetPair &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a57a30dfb5b4461c9f007e640d8e1ccd9">msgPassRunningMap</a></td></tr>
<tr class="memdesc:a57a30dfb5b4461c9f007e640d8e1ccd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by nonblocking message passing schedulers to bookkeep which jobs are running remotely <br /></td></tr>
<tr class="separator:a57a30dfb5b4461c9f007e640d8e1ccd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb2dcc5b142f601894f54fca983c631"><td class="memItemLeft" align="right" valign="top"><a id="a0cb2dcc5b142f601894f54fca983c631"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a0cb2dcc5b142f601894f54fca983c631">nowaitEvalIdRef</a></td></tr>
<tr class="memdesc:a0cb2dcc5b142f601894f54fca983c631"><td class="mdescLeft">&#160;</td><td class="mdescRight">fnEvalId reference point for preserving modulo arithmetic-based job assignment in case of peer static nonblocking schedulers <br /></td></tr>
<tr class="separator:a0cb2dcc5b142f601894f54fca983c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcb771de0d7359c4e89b13621c60e84"><td class="memItemLeft" align="right" valign="top"><a id="a0bcb771de0d7359c4e89b13621c60e84"></a>
<a class="el" href="classDakota_1_1MPIPackBuffer.html">MPIPackBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a0bcb771de0d7359c4e89b13621c60e84">sendBuffers</a></td></tr>
<tr class="memdesc:a0bcb771de0d7359c4e89b13621c60e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of pack buffers for evaluation jobs queued to a server <br /></td></tr>
<tr class="separator:a0bcb771de0d7359c4e89b13621c60e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f2d6daa991a98a6166c81c6d043599"><td class="memItemLeft" align="right" valign="top"><a id="a13f2d6daa991a98a6166c81c6d043599"></a>
<a class="el" href="classDakota_1_1MPIUnpackBuffer.html">MPIUnpackBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#a13f2d6daa991a98a6166c81c6d043599">recvBuffers</a></td></tr>
<tr class="memdesc:a13f2d6daa991a98a6166c81c6d043599"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of unpack buffers for evaluation jobs returned by a server <br /></td></tr>
<tr class="separator:a13f2d6daa991a98a6166c81c6d043599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca365a4af48900b49d9a351f94b978ad"><td class="memItemLeft" align="right" valign="top"><a id="aca365a4af48900b49d9a351f94b978ad"></a>
MPI_Request *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1ApplicationInterface.html#aca365a4af48900b49d9a351f94b978ad">recvRequests</a></td></tr>
<tr class="memdesc:aca365a4af48900b49d9a351f94b978ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of requests for nonblocking evaluation receives <br /></td></tr>
<tr class="separator:aca365a4af48900b49d9a351f94b978ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Derived class within the interface class hierarchy for supporting interfaces to simulation codes. </p>
<p><a class="el" href="classDakota_1_1ApplicationInterface.html" title="Derived class within the interface class hierarchy for supporting interfaces to simulation codes.">ApplicationInterface</a> provides an interface class for performing parameter to response mappings using simulation code(s). It provides common functionality for a number of derived classes and contains the majority of all of the scheduling algorithms in DAKOTA. The derived classes provide the specifics for managing code invocations using system calls, forks, direct procedure calls, or distributed resource facilities. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acfb6f6d615183fc2f71e79dfbadfe27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb6f6d615183fc2f71e79dfbadfe27d">&#9670;&nbsp;</a></span>init_serial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init_serial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DataInterface.cpp defaults of 0 servers are needed to distinguish an explicit user request for 1 server (serialization of a parallelism level) from no user request (use parallel auto-config). This default causes problems when <a class="el" href="classDakota_1_1ApplicationInterface.html#a539b36ea1dba3c25b12530148942032b" title="allocate communicator partitions for concurrent evaluations within an iterator and concurrent multipr...">init_communicators()</a> is not called for an interface object (e.g., static scheduling fails in <a class="el" href="classDakota_1_1DirectApplicInterface.html#af70c12f41f85168080d1e68b0334258a" title="Called by map() and other functions to execute the simulation in synchronous mode....">DirectApplicInterface::derived_map()</a> for <a class="el" href="classDakota_1_1NestedModel.html#ace7c7e12794a34d2980c23bba1028503" title="the optional interface contributes nonnested response data to the total model response">NestedModel::optionalInterface</a>). This is the reason for this function: to reset certain defaults for interface objects that are used serially. </p>

<p>Reimplemented from <a class="el" href="classDakota_1_1Interface.html#acfb6f6d615183fc2f71e79dfbadfe27d">Interface</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#acdbb9928f8cbc892d01d7d23333e65e9">ApplicationInterface::init_serial_analyses()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a2d7a5c550fdc711de12ef8d230a34309">ApplicationInterface::init_serial_evaluations()</a>.</p>

</div>
</div>
<a id="a999c6f807e9ea92b96d6bbc2f7873cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999c6f807e9ea92b96d6bbc2f7873cca">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Response.html">Response</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asynch_flag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a "mapping" of variables to responses using a simulation. Protected due to <a class="el" href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy.">Interface</a> letter-envelope idiom. </p>
<p>The function evaluator for application interfaces. Called from derived_evaluate() and derived_evaluate_nowait() in derived <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> classes. If asynch_flag is not set, perform a blocking evaluation (using <a class="el" href="classDakota_1_1ApplicationInterface.html#af70c12f41f85168080d1e68b0334258a" title="Called by map() and other functions to execute the simulation in synchronous mode....">derived_map()</a>). If asynch_flag is set, add the job to the beforeSynchCorePRPQueue queue for execution by one of the scheduler routines in <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c" title="executes a blocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns ...">synchronize()</a> or <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6" title="executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and retur...">synchronize_nowait()</a>. Duplicate function evaluations are detected with <a class="el" href="classDakota_1_1ApplicationInterface.html#a9a8aa9d923ded9d5bec27388a535a483" title="checks data_pairs and beforeSynchCorePRPQueue to see if the current evaluation request has already be...">duplication_detect()</a>. </p>

<p>Reimplemented from <a class="el" href="classDakota_1_1Interface.html#a999c6f807e9ea92b96d6bbc2f7873cca">Interface</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Response.html#adfbe39c5d0441f94ad5f96cd2cef6676">Response::active_set()</a>, <a class="el" href="classDakota_1_1Interface.html#a1aa0c1950d0a220faf872eabb3d7b80f">Interface::algebraic_mappings()</a>, <a class="el" href="classDakota_1_1Interface.html#af57d2d0f9d852999681ddc6139a9bba9">Interface::algebraicMappings</a>, <a class="el" href="classDakota_1_1Interface.html#ac02f8927aa1f36ba589f134afed81572">Interface::asv_mapping()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ab1e9ca6f5c179f56728957c3b4dc1add">ApplicationInterface::asvControlFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a90f4d590328220339cfb50a746b7c232">ApplicationInterface::batchEval</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a886e2da92ce6e1339ba66bcb76784824">ApplicationInterface::beforeSynchAlgPRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a4fa4a63f6d149a9ccf16709967b553d3">ApplicationInterface::broadcast_evaluation()</a>, <a class="el" href="classDakota_1_1Response.html#acea916481a383be16928bcb70432e790">Response::copy()</a>, <a class="el" href="classDakota_1_1Interface.html#aaa1f045107cac3e8b7586eeee1e681ce">Interface::coreMappings</a>, <a class="el" href="classDakota_1_1Interface.html#aba7d467110a2230d5eeb40a7f673f3a1">Interface::currEvalId</a>, <a class="el" href="namespaceDakota.html#a3f0f62f5ba0a2183150b2fb188bc69cb">Dakota::data_pairs</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a86968f57416404f124a3df401ba2a6e8">ApplicationInterface::defaultASV</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#af70c12f41f85168080d1e68b0334258a">ApplicationInterface::derived_map()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a9a8aa9d923ded9d5bec27388a535a483">ApplicationInterface::duplication_detect()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a501fddba77066e5101c56b7c7ee573a2">ApplicationInterface::evalCacheFlag</a>, <a class="el" href="classDakota_1_1Interface.html#ab4591fe231e7a0dde20125a8f6cdf60f">Interface::evalIdCntr</a>, <a class="el" href="classDakota_1_1Interface.html#af42b3f90172d75af753f2f5a6dea6c66">Interface::fineGrainEvalCounters</a>, <a class="el" href="classDakota_1_1Interface.html#ae233c9963bc34d3126348743744f7c6e">Interface::fnGradCounter</a>, <a class="el" href="classDakota_1_1Interface.html#ac81bfeadbb95bc6b8693151115a160d0">Interface::fnHessCounter</a>, <a class="el" href="classDakota_1_1Interface.html#a4c760dcaaa649f4ab521700fbb436a42">Interface::fnLabels</a>, <a class="el" href="classDakota_1_1Interface.html#a6c372d7fdf062ccb9e274d00576e4df8">Interface::fnValCounter</a>, <a class="el" href="classDakota_1_1Response.html#a681aa6a9f0264cdc049e5ed27b2a4a7a">Response::function_labels()</a>, <a class="el" href="classDakota_1_1Interface.html#aff147190625e01b76c74dc9db9e00e7d">Interface::init_algebraic_mappings()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a81807c1636a9dae3d146c997db1d980d">ApplicationInterface::init_default_asv()</a>, <a class="el" href="classDakota_1_1Interface.html#ae7d96f6f7161280693d84a68caf77758">Interface::init_evaluation_counters()</a>, <a class="el" href="classDakota_1_1Interface.html#a74107aa656556a11207a60b23f83de34">Interface::interfaceId</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a460bf8a4bf5698bc403ca958c1950941">ApplicationInterface::manage_failure()</a>, <a class="el" href="classDakota_1_1Interface.html#af5a33a6b07c4c6f5d757d214de0f47ca">Interface::multiProcEvalFlag</a>, <a class="el" href="classDakota_1_1Interface.html#a17fd5f8fb59a0675573022a4913405ef">Interface::newEvalIdCntr</a>, <a class="el" href="classDakota_1_1Interface.html#a9aa3b89f09cca1163c10c072dbb5f524">Interface::newFnGradCounter</a>, <a class="el" href="classDakota_1_1Interface.html#a4ca056ffecbf760f32d45ece5ae1e07c">Interface::newFnHessCounter</a>, <a class="el" href="classDakota_1_1Interface.html#a3c7125772868c4504a748528e904708b">Interface::newFnValCounter</a>, <a class="el" href="classDakota_1_1Interface.html#a8b080aab3a786ee1439b43c3533f1f6a">Interface::outputLevel</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>, <a class="el" href="classDakota_1_1ActiveSet.html#a20cc3009b8fb687f23d25d5c78f40fdd">ActiveSet::request_vector()</a>, <a class="el" href="classDakota_1_1Interface.html#a96d30d89ba4839abe946d4fb551ee63c">Interface::response_mapping()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ac752f5f55e71a48bd0905d8849cb34de">ApplicationInterface::restartFileFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#acf85586a030d85f483d16c41336ad115">ApplicationInterface::sharedRespData</a>, and <a class="el" href="classDakota_1_1ParallelLibrary.html#ab6ef08cb8e5827e0c5815657288d5ec8">ParallelLibrary::write_restart()</a>.</p>

</div>
</div>
<a id="ab596ce6c762ef2fcfde22f3b2469b02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab596ce6c762ef2fcfde22f3b2469b02c">&#9670;&nbsp;</a></span>synchronize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const IntResponseMap &amp; synchronize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>executes a blocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns all jobs </p>
<p>This function provides blocking synchronization for all cases of asynchronous evaluations, including the local asynchronous case (background system call, nonblocking fork, &amp; multithreads), the message passing case, and the hybrid case. Called from derived_synchronize() in derived <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> classes. </p>

<p>Reimplemented from <a class="el" href="classDakota_1_1Interface.html#ab596ce6c762ef2fcfde22f3b2469b02c">Interface</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Interface.html#a1aa0c1950d0a220faf872eabb3d7b80f">Interface::algebraic_mappings()</a>, <a class="el" href="classDakota_1_1Interface.html#af57d2d0f9d852999681ddc6139a9bba9">Interface::algebraicMappings</a>, <a class="el" href="classDakota_1_1Interface.html#ac02f8927aa1f36ba589f134afed81572">Interface::asv_mapping()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a2bcd55897256c6a8bdc75361ec153d8e">ApplicationInterface::asynchLocalEvalStatic</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a656ccb76e0320bc17c37d30142e77fa9">ApplicationInterface::asynchronous_local_evaluations()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a886e2da92ce6e1339ba66bcb76784824">ApplicationInterface::beforeSynchAlgPRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae839b9b58b9857ffc6df3dd0b0ad7daf">ApplicationInterface::beforeSynchDuplicateMap</a>, <a class="el" href="classDakota_1_1Interface.html#add30d7adf4fe103543f4b103a14b9a34">Interface::cachedResponseMap</a>, <a class="el" href="classDakota_1_1Interface.html#aaa1f045107cac3e8b7586eeee1e681ce">Interface::coreMappings</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae467ea8b7a060dd5a9af31dc712c0ec5">ApplicationInterface::evalScheduling</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a6075d512ae619e50a3af54bd18a7ead9">ApplicationInterface::historyDuplicateMap</a>, <a class="el" href="classDakota_1_1Interface.html#a161f6c7c983b691604ad7e07b52b886e">Interface::ieDedMasterFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#acd02aa81cc207642f2ff0620c0abc97f">ApplicationInterface::ieMessagePass</a>, <a class="el" href="classDakota_1_1Interface.html#a74107aa656556a11207a60b23f83de34">Interface::interfaceId</a>, <a class="el" href="classDakota_1_1Interface.html#a49a9dda05ef271e5ad2836c4616a3e14">Interface::interfaceType</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a81c9b27b4fd7483615896e0b26553e12">ApplicationInterface::master_dynamic_schedule_evaluations()</a>, <a class="el" href="classDakota_1_1Interface.html#af5a33a6b07c4c6f5d757d214de0f47ca">Interface::multiProcEvalFlag</a>, <a class="el" href="classDakota_1_1Interface.html#a8b080aab3a786ee1439b43c3533f1f6a">Interface::outputLevel</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aee0c1bebc31beef5e63c586ee5ab2102">ApplicationInterface::peer_dynamic_schedule_evaluations()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae94c7702163e6591d63bac4a08c48201">ApplicationInterface::peer_static_schedule_evaluations()</a>, <a class="el" href="classDakota_1_1Interface.html#ad326a6acce0df29ad63ca5d0b15e90bb">Interface::rawResponseMap</a>, <a class="el" href="classDakota_1_1Interface.html#a96d30d89ba4839abe946d4fb551ee63c">Interface::response_mapping()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#acf85586a030d85f483d16c41336ad115">ApplicationInterface::sharedRespData</a>.</p>

</div>
</div>
<a id="a2a0e88fca3d4b493e3f90d98efd23ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0e88fca3d4b493e3f90d98efd23ea6">&#9670;&nbsp;</a></span>synchronize_nowait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const IntResponseMap &amp; synchronize_nowait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns a partial set of completed jobs </p>
<p>This function provides nonblocking synchronization for the local asynchronous case and selected nonblocking message passing schedulers. Called from derived_synchronize_nowait() in derived <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> classes. </p>

<p>Reimplemented from <a class="el" href="classDakota_1_1Interface.html#a2a0e88fca3d4b493e3f90d98efd23ea6">Interface</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Interface.html#a1aa0c1950d0a220faf872eabb3d7b80f">Interface::algebraic_mappings()</a>, <a class="el" href="classDakota_1_1Interface.html#af57d2d0f9d852999681ddc6139a9bba9">Interface::algebraicMappings</a>, <a class="el" href="classDakota_1_1Interface.html#ac02f8927aa1f36ba589f134afed81572">Interface::asv_mapping()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a2bcd55897256c6a8bdc75361ec153d8e">ApplicationInterface::asynchLocalEvalStatic</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#af1185f9bf9f8c28564cc17e321c270c1">ApplicationInterface::asynchronous_local_evaluations_nowait()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a886e2da92ce6e1339ba66bcb76784824">ApplicationInterface::beforeSynchAlgPRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae839b9b58b9857ffc6df3dd0b0ad7daf">ApplicationInterface::beforeSynchDuplicateMap</a>, <a class="el" href="classDakota_1_1Interface.html#add30d7adf4fe103543f4b103a14b9a34">Interface::cachedResponseMap</a>, <a class="el" href="classDakota_1_1Interface.html#aaa1f045107cac3e8b7586eeee1e681ce">Interface::coreMappings</a>, <a class="el" href="classDakota_1_1ParamResponsePair.html#ae4e09678cfb0e2798ea4a3962e556ef1">ParamResponsePair::eval_id()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae467ea8b7a060dd5a9af31dc712c0ec5">ApplicationInterface::evalScheduling</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5d84b86ed363bf09f58b7a723e2c8a03">ApplicationInterface::headerFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a6075d512ae619e50a3af54bd18a7ead9">ApplicationInterface::historyDuplicateMap</a>, <a class="el" href="classDakota_1_1Interface.html#a161f6c7c983b691604ad7e07b52b886e">Interface::ieDedMasterFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#acd02aa81cc207642f2ff0620c0abc97f">ApplicationInterface::ieMessagePass</a>, <a class="el" href="classDakota_1_1Interface.html#a74107aa656556a11207a60b23f83de34">Interface::interfaceId</a>, <a class="el" href="classDakota_1_1Interface.html#a49a9dda05ef271e5ad2836c4616a3e14">Interface::interfaceType</a>, <a class="el" href="namespaceDakota.html#af316249372180b96b64418fad862bfb0">Dakota::lookup_by_eval_id()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5ec8ac43798133cf0bd94cbf6fff50a4">ApplicationInterface::master_dynamic_schedule_evaluations_nowait()</a>, <a class="el" href="classDakota_1_1Interface.html#af5a33a6b07c4c6f5d757d214de0f47ca">Interface::multiProcEvalFlag</a>, <a class="el" href="classDakota_1_1Interface.html#a8b080aab3a786ee1439b43c3533f1f6a">Interface::outputLevel</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5531a6d9294fd47a6cb6153df68403dc">ApplicationInterface::peer_dynamic_schedule_evaluations_nowait()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#abb4f9eafe638564737e1b96934a09bea">ApplicationInterface::peer_static_schedule_evaluations_nowait()</a>, <a class="el" href="classDakota_1_1Interface.html#ad326a6acce0df29ad63ca5d0b15e90bb">Interface::rawResponseMap</a>, <a class="el" href="classDakota_1_1ParamResponsePair.html#abd01110f80ee2876a561d8ebcdd3d01d">ParamResponsePair::response()</a>, <a class="el" href="classDakota_1_1Interface.html#a96d30d89ba4839abe946d4fb551ee63c">Interface::response_mapping()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#acf85586a030d85f483d16c41336ad115">ApplicationInterface::sharedRespData</a>, and <a class="el" href="classDakota_1_1Response.html#a64960126b55c443d1430c09ca92364c0">Response::update()</a>.</p>

</div>
</div>
<a id="a582aaa84632e91b7e27efaf011c585fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582aaa84632e91b7e27efaf011c585fe">&#9670;&nbsp;</a></span>serve_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serve_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>run on evaluation servers to serve the iterator master </p>
<p>Invoked by the serve() function in derived <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> classes. Passes control to <a class="el" href="classDakota_1_1ApplicationInterface.html#a706547d76f07b61b158ff8231b43e3ea" title="serve the evaluation message passing schedulers and perform one synchronous evaluation at a time">serve_evaluations_synch()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aa2fff53bc102ed8138a2e58fbe08c591" title="serve the evaluation message passing schedulers and manage multiple asynchronous evaluations">serve_evaluations_asynch()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a203db1af5f56cb9186ffca180380333f" title="serve the evaluation message passing schedulers and perform one synchronous evaluation at a time as p...">serve_evaluations_synch_peer()</a>, or <a class="el" href="classDakota_1_1ApplicationInterface.html#a09809d49a953208a059e0c349db956b9" title="serve the evaluation message passing schedulers and perform multiple asynchronous evaluations as part...">serve_evaluations_asynch_peer()</a> according to specified concurrency, partition, and scheduler configuration. </p>

<p>Reimplemented from <a class="el" href="classDakota_1_1Interface.html#a582aaa84632e91b7e27efaf011c585fe">Interface</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ac570f6d6cb4162823292f88ad6f425b3">ApplicationInterface::evalServerId</a>, <a class="el" href="classDakota_1_1Interface.html#a161f6c7c983b691604ad7e07b52b886e">Interface::ieDedMasterFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aa2fff53bc102ed8138a2e58fbe08c591">ApplicationInterface::serve_evaluations_asynch()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a09809d49a953208a059e0c349db956b9">ApplicationInterface::serve_evaluations_asynch_peer()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a706547d76f07b61b158ff8231b43e3ea">ApplicationInterface::serve_evaluations_synch()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a203db1af5f56cb9186ffca180380333f">ApplicationInterface::serve_evaluations_synch_peer()</a>.</p>

</div>
</div>
<a id="a26356baa3f4edc1c7b134d8d74bb02b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26356baa3f4edc1c7b134d8d74bb02b6">&#9670;&nbsp;</a></span>stop_evaluation_servers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stop_evaluation_servers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used by the iterator master to terminate evaluation servers </p>
<p>This code is executed on the iteratorComm rank 0 processor when iteration on a particular model is complete. It sends a termination signal (tag = 0 instead of a valid fn_eval_id) to each of the slave analysis servers. NOTE: This function is called from the Strategy layer even when in serial mode. Therefore, use iteratorCommSize to provide appropriate fall through behavior. </p>

<p>Reimplemented from <a class="el" href="classDakota_1_1Interface.html#a26356baa3f4edc1c7b134d8d74bb02b6">Interface</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1ParallelLibrary.html#a0af7505d094d0f9a54eba49ef962840b">ParallelLibrary::bcast_e()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ad26295e7238e207366e6afd512cdd042">ParallelLibrary::free()</a>, <a class="el" href="classDakota_1_1ParallelConfiguration.html#ab3a5523640aec43907b771523bd0cddb">ParallelConfiguration::ie_parallel_level()</a>, <a class="el" href="classDakota_1_1Interface.html#a161f6c7c983b691604ad7e07b52b886e">Interface::ieDedMasterFlag</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a922f3dc407f5e8ba89c191ae9b64b1c1">ParallelLibrary::isend_ie()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aaa7bd63ee74d6bea2b43bfa23a6fff26">ApplicationInterface::iteratorCommSize</a>, <a class="el" href="classDakota_1_1Interface.html#af5a33a6b07c4c6f5d757d214de0f47ca">Interface::multiProcEvalFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a32b6bf5aee3ef76501106a7dac82712d">ApplicationInterface::numEvalServers</a>, <a class="el" href="classDakota_1_1Interface.html#a8b080aab3a786ee1439b43c3533f1f6a">Interface::outputLevel</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ac8e53aa237a20cb17b3063396e3c3471">ParallelLibrary::parallel_configuration()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>.</p>

</div>
</div>
<a id="a14ce13ff49174b08eda5e60edf0dff9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ce13ff49174b08eda5e60edf0dff9b">&#9670;&nbsp;</a></span>init_communicators_checks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init_communicators_checks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_eval_concurrency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>perform construct-time error checks on the parallel configuration </p>
<p>Override <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> definition if plug-in to allow batch processing in Plugin{Serial,Parallel}DirectApplicInterface.cpp </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1SysCallApplicInterface.html#a14ce13ff49174b08eda5e60edf0dff9b">SysCallApplicInterface</a>, <a class="el" href="classDakota_1_1Pybind11Interface.html#a14ce13ff49174b08eda5e60edf0dff9b">Pybind11Interface</a>, <a class="el" href="classDakota_1_1ProcessHandleApplicInterface.html#a14ce13ff49174b08eda5e60edf0dff9b">ProcessHandleApplicInterface</a>, and <a class="el" href="classDakota_1_1DirectApplicInterface.html#a14ce13ff49174b08eda5e60edf0dff9b">DirectApplicInterface</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a539b36ea1dba3c25b12530148942032b">ApplicationInterface::init_communicators()</a>.</p>

</div>
</div>
<a id="a5d398ffaf3368f949a8b85f058b81cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d398ffaf3368f949a8b85f058b81cbd">&#9670;&nbsp;</a></span>set_communicators_checks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_communicators_checks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_eval_concurrency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>perform run-time error checks on the parallel configuration </p>
<p>Override <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> definition if plug-in to allow batch processing in Plugin{Serial,Parallel}DirectApplicInterface.cpp </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1SysCallApplicInterface.html#a5d398ffaf3368f949a8b85f058b81cbd">SysCallApplicInterface</a>, <a class="el" href="classStanfordPSAAP_1_1SoleilDirectApplicInterface.html#a5d398ffaf3368f949a8b85f058b81cbd">SoleilDirectApplicInterface</a>, <a class="el" href="classDakota_1_1Pybind11Interface.html#a5d398ffaf3368f949a8b85f058b81cbd">Pybind11Interface</a>, <a class="el" href="classDakota_1_1ProcessHandleApplicInterface.html#a5d398ffaf3368f949a8b85f058b81cbd">ProcessHandleApplicInterface</a>, <a class="el" href="classSIM_1_1SerialDirectApplicInterface.html#a5d398ffaf3368f949a8b85f058b81cbd">SerialDirectApplicInterface</a>, <a class="el" href="classSIM_1_1ParallelDirectApplicInterface.html#a5d398ffaf3368f949a8b85f058b81cbd">ParallelDirectApplicInterface</a>, and <a class="el" href="classDakota_1_1DirectApplicInterface.html#a5d398ffaf3368f949a8b85f058b81cbd">DirectApplicInterface</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a41339f58905edb8ca694917f463ebf19">ApplicationInterface::set_communicators()</a>.</p>

</div>
</div>
<a id="aa4ed4408a7d7e35a26926f11c35df548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ed4408a7d7e35a26926f11c35df548">&#9670;&nbsp;</a></span>master_dynamic_schedule_analyses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void master_dynamic_schedule_analyses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>blocking dynamic schedule of all analyses within a function evaluation using message passing </p>
<p>This code is called from derived classes to provide the master portion of a master-slave algorithm for the dynamic scheduling of analyses among slave servers. It is patterned after <a class="el" href="classDakota_1_1ApplicationInterface.html#a81c9b27b4fd7483615896e0b26553e12" title="blocking dynamic schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a de...">master_dynamic_schedule_evaluations()</a>. It performs no analyses locally and matches either <a class="el" href="classDakota_1_1ApplicationInterface.html#a1f27ad37fa3d1b1cffa08074b24bd984" title="serve the master analysis scheduler and manage one synchronous analysis job at a time">serve_analyses_synch()</a> or serve_analyses_asynch() on the slave servers, depending on the value of asynchLocalAnalysisConcurrency. Dynamic scheduling assigns jobs in 2 passes. The 1st pass gives each server the same number of jobs (equal to asynchLocalAnalysisConcurrency). The 2nd pass assigns the remaining jobs to slave servers as previous jobs are completed. Single- and multilevel parallel use intra- and inter-communicators, respectively, for send/receive. Specific syntax is encapsulated within <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a>. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#ae2db1b1de2eae7b6d08b77b49e12a1d0">ApplicationInterface::asynchLocalAnalysisConcurrency</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ad26295e7238e207366e6afd512cdd042">ParallelLibrary::free()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a46a5ae777d4d6838173b7f20a8bc669b">ParallelLibrary::irecv_ea()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ad146e4114519c935f7edacc99e036f25">ParallelLibrary::isend_ea()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a2264b09fe59e7046d035a0f828dbe25e">ApplicationInterface::numAnalysisDrivers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a8be21657eaaafd3f78287e4f67dbd01b">ApplicationInterface::numAnalysisServers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ac0da1f4dda9a27fc906988a3ceaab91e">ParallelLibrary::waitall()</a>, and <a class="el" href="classDakota_1_1ParallelLibrary.html#ad52932659b4aef0184d8fae2969994c2">ParallelLibrary::waitsome()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ProcessHandleApplicInterface.html#a551f4bbf630d5778ec584edbc3e8803c">ProcessHandleApplicInterface::create_evaluation_process()</a>, <a class="el" href="classDakota_1_1SysCallApplicInterface.html#a551f4bbf630d5778ec584edbc3e8803c">SysCallApplicInterface::create_evaluation_process()</a>, and <a class="el" href="classDakota_1_1DirectApplicInterface.html#af70c12f41f85168080d1e68b0334258a">DirectApplicInterface::derived_map()</a>.</p>

</div>
</div>
<a id="a1f27ad37fa3d1b1cffa08074b24bd984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f27ad37fa3d1b1cffa08074b24bd984">&#9670;&nbsp;</a></span>serve_analyses_synch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serve_analyses_synch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serve the master analysis scheduler and manage one synchronous analysis job at a time </p>
<p>This code is called from derived classes to run synchronous analyses on slave processors. The slaves receive requests (blocking receive), do local derived_map_ac's, and return codes. This is done continuously until a termination signal is received from the master. It is patterned after <a class="el" href="classDakota_1_1ApplicationInterface.html#a706547d76f07b61b158ff8231b43e3ea" title="serve the evaluation message passing schedulers and perform one synchronous evaluation at a time">serve_evaluations_synch()</a>. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#a326384df4de6ef4fcb2ac847b7d95e07">ApplicationInterface::analysisCommRank</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#acbe4dab455bff1932cae0d18c3d10f5a">ParallelLibrary::bcast_a()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ad146e4114519c935f7edacc99e036f25">ParallelLibrary::isend_ea()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aa575b69a2031947dcf82ed3fe10642b8">ApplicationInterface::multiProcAnalysisFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#af6146a5befc9e48371082d7815ef55d5">ParallelLibrary::recv_ea()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ac113ddb7fbad0221941b365f4260f2d8">ApplicationInterface::synchronous_local_analysis()</a>, and <a class="el" href="classDakota_1_1ParallelLibrary.html#ade7b5596f2367630dd0e8f6a21521fa4">ParallelLibrary::wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ProcessHandleApplicInterface.html#a551f4bbf630d5778ec584edbc3e8803c">ProcessHandleApplicInterface::create_evaluation_process()</a>, <a class="el" href="classDakota_1_1SysCallApplicInterface.html#a551f4bbf630d5778ec584edbc3e8803c">SysCallApplicInterface::create_evaluation_process()</a>, and <a class="el" href="classDakota_1_1DirectApplicInterface.html#af70c12f41f85168080d1e68b0334258a">DirectApplicInterface::derived_map()</a>.</p>

</div>
</div>
<a id="a9a8aa9d923ded9d5bec27388a535a483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8aa9d923ded9d5bec27388a535a483">&#9670;&nbsp;</a></span>duplication_detect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool duplication_detect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Response.html">Response</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asynch_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks data_pairs and beforeSynchCorePRPQueue to see if the current evaluation request has already been performed or queued </p>
<p>Called from <a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca" title="Provides a &quot;mapping&quot; of variables to responses using a simulation. Protected due to Interface letter-...">map()</a> to check incoming evaluation request for duplication with content of data_pairs and beforeSynchCorePRPQueue. <br  />
 If duplication is detected, return true, else return false. Manage bookkeeping with historyDuplicateMap and beforeSynchDuplicateMap. Note that the list searches can get very expensive if a long list is searched on every new function evaluation (either from a large number of previous jobs, a large number of pending jobs, or both). For this reason, a user request for deactivation of the evaluation cache results in a complete bypass of <a class="el" href="classDakota_1_1ApplicationInterface.html#a9a8aa9d923ded9d5bec27388a535a483" title="checks data_pairs and beforeSynchCorePRPQueue to see if the current evaluation request has already be...">duplication_detect()</a>, even though a beforeSynchCorePRPQueue search would still be meaningful. Since the intent of this request is to streamline operations, both list searches are bypassed. </p>

<p class="reference">References <a class="el" href="classDakota_1_1Response.html#adfbe39c5d0441f94ad5f96cd2cef6676">Response::active_set()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae839b9b58b9857ffc6df3dd0b0ad7daf">ApplicationInterface::beforeSynchDuplicateMap</a>, <a class="el" href="classDakota_1_1Response.html#acea916481a383be16928bcb70432e790">Response::copy()</a>, <a class="el" href="namespaceDakota.html#a3f0f62f5ba0a2183150b2fb188bc69cb">Dakota::data_pairs</a>, <a class="el" href="classDakota_1_1ParamResponsePair.html#ae4e09678cfb0e2798ea4a3962e556ef1">ParamResponsePair::eval_id()</a>, <a class="el" href="classDakota_1_1Interface.html#ab4591fe231e7a0dde20125a8f6cdf60f">Interface::evalIdCntr</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a6075d512ae619e50a3af54bd18a7ead9">ApplicationInterface::historyDuplicateMap</a>, <a class="el" href="classDakota_1_1Interface.html#a74107aa656556a11207a60b23f83de34">Interface::interfaceId</a>, <a class="el" href="namespaceDakota.html#ab3922aba46326ca3daa6d0c20cc2a3f8">Dakota::lookup_by_val()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a7e3e67a97c3d95139b18eab61952c6fd">ApplicationInterface::nearbyDuplicateDetect</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a7c54e0ba71c5d76a9e73695a53e3a2b4">ApplicationInterface::nearbyTolerance</a>, and <a class="el" href="classDakota_1_1Response.html#a64960126b55c443d1430c09ca92364c0">Response::update()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca">ApplicationInterface::map()</a>.</p>

</div>
</div>
<a id="a81807c1636a9dae3d146c997db1d980d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81807c1636a9dae3d146c997db1d980d">&#9670;&nbsp;</a></span>init_default_asv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init_default_asv </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_fns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize default ASV if needed; this is done at run time due to post-construct time <a class="el" href="classDakota_1_1Response.html" title="Container class for response functions and their derivatives.   Response provides the enveloper base ...">Response</a> size changes. </p>
<p>If the user has specified active_set_vector as off, then <a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca" title="Provides a &quot;mapping&quot; of variables to responses using a simulation. Protected due to Interface letter-...">map()</a> uses a default ASV which is constant for all function evaluations (so that the user need not check the content of the ASV on each evaluation). Only initialized if needed and not already sized. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#ab1e9ca6f5c179f56728957c3b4dc1add">ApplicationInterface::asvControlFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a86968f57416404f124a3df401ba2a6e8">ApplicationInterface::defaultASV</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aefd75192e1d00f59bafbadb7984734fd">ApplicationInterface::gradientType</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0c0eeba22fedf9cd0edfe1626ccd1847">ApplicationInterface::gradMixedAnalyticIds</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a58ab688b052b513a9f6e82d785d2e4ea">ApplicationInterface::hessianType</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a0965f813800d1659b071bf3cc86ff18b">ApplicationInterface::hessMixedAnalyticIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca">ApplicationInterface::map()</a>.</p>

</div>
</div>
<a id="a81c9b27b4fd7483615896e0b26553e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c9b27b4fd7483615896e0b26553e12">&#9670;&nbsp;</a></span>master_dynamic_schedule_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void master_dynamic_schedule_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>blocking dynamic schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a dedicated master partition; executes on iteratorComm master </p>
<p>This code is called from <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c" title="executes a blocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns ...">synchronize()</a> to provide the master portion of a master-slave algorithm for the dynamic scheduling of evaluations among slave servers. It performs no evaluations locally and matches either <a class="el" href="classDakota_1_1ApplicationInterface.html#a706547d76f07b61b158ff8231b43e3ea" title="serve the evaluation message passing schedulers and perform one synchronous evaluation at a time">serve_evaluations_synch()</a> or <a class="el" href="classDakota_1_1ApplicationInterface.html#aa2fff53bc102ed8138a2e58fbe08c591" title="serve the evaluation message passing schedulers and manage multiple asynchronous evaluations">serve_evaluations_asynch()</a> on the slave servers, depending on the value of asynchLocalEvalConcurrency. Dynamic scheduling assigns jobs in 2 passes. The 1st pass gives each server the same number of jobs (equal to asynchLocalEvalConcurrency). The 2nd pass assigns the remaining jobs to slave servers as previous jobs are completed and returned. Single- and multilevel parallel use intra- and inter-communicators, respectively, for send/receive. Specific syntax is encapsulated within <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a>. </p>
<p>peer</p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="namespaceDakota.html#af316249372180b96b64418fad862bfb0">Dakota::lookup_by_eval_id()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a32b6bf5aee3ef76501106a7dac82712d">ApplicationInterface::numEvalServers</a>, <a class="el" href="classDakota_1_1Interface.html#a8b080aab3a786ee1439b43c3533f1f6a">Interface::outputLevel</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5bf4da80f8dd52b62ebdb184bc91ac1f">ApplicationInterface::receive_evaluation()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a13f2d6daa991a98a6166c81c6d043599">ApplicationInterface::recvBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aca365a4af48900b49d9a351f94b978ad">ApplicationInterface::recvRequests</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a4733cf30510ad34288d04049a7455811">ApplicationInterface::send_evaluation()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0bcb771de0d7359c4e89b13621c60e84">ApplicationInterface::sendBuffers</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ac0da1f4dda9a27fc906988a3ceaab91e">ParallelLibrary::waitall()</a>, and <a class="el" href="classDakota_1_1ParallelLibrary.html#ad52932659b4aef0184d8fae2969994c2">ParallelLibrary::waitsome()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c">ApplicationInterface::synchronize()</a>.</p>

</div>
</div>
<a id="ae94c7702163e6591d63bac4a08c48201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94c7702163e6591d63bac4a08c48201">&#9670;&nbsp;</a></span>peer_static_schedule_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void peer_static_schedule_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>blocking static schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a peer partition; executes on iteratorComm master </p>
<p>This code runs on the iteratorCommRank 0 processor (the iterator) and is called from <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c" title="executes a blocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns ...">synchronize()</a> in order to manage a static schedule for cases where peer 1 must block when evaluating its local job allocation (e.g., single or multiprocessor direct interface evaluations). It matches serve_evaluations_peer() for any other processors within the first evaluation partition and serve_evaluations_{synch,asynch}() for all other evaluation partitions (depending on asynchLocalEvalConcurrency). It performs function evaluations locally for its portion of the job allocation using either <a class="el" href="classDakota_1_1ApplicationInterface.html#a656ccb76e0320bc17c37d30142e77fa9" title="perform all jobs in prp_queue using asynchronous approaches on the local processor">asynchronous_local_evaluations()</a> or <a class="el" href="classDakota_1_1ApplicationInterface.html#a7e8bb538639ac5ed543d5098b8ab9ee3" title="perform all jobs in prp_queue using synchronous approaches on the local processor">synchronous_local_evaluations()</a>. Single-level and multilevel parallel use intra- and inter-communicators, respectively, for send/receive. Specific syntax is encapsulated within <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a>. The iteratorCommRank 0 processor assigns the static schedule since it is the only processor with access to beforeSynchCorePRPQueue (it runs the iterator and calls synchronize). The alternate design of each peer selecting its own jobs using the modulus operator would be applicable if execution of this function (and therefore the job list) were distributed. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a656ccb76e0320bc17c37d30142e77fa9">ApplicationInterface::asynchronous_local_evaluations()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a32b6bf5aee3ef76501106a7dac82712d">ApplicationInterface::numEvalServers</a>, <a class="el" href="classDakota_1_1Interface.html#a8b080aab3a786ee1439b43c3533f1f6a">Interface::outputLevel</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5bf4da80f8dd52b62ebdb184bc91ac1f">ApplicationInterface::receive_evaluation()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a13f2d6daa991a98a6166c81c6d043599">ApplicationInterface::recvBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aca365a4af48900b49d9a351f94b978ad">ApplicationInterface::recvRequests</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a4733cf30510ad34288d04049a7455811">ApplicationInterface::send_evaluation()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0bcb771de0d7359c4e89b13621c60e84">ApplicationInterface::sendBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a7e8bb538639ac5ed543d5098b8ab9ee3">ApplicationInterface::synchronous_local_evaluations()</a>, and <a class="el" href="classDakota_1_1ParallelLibrary.html#ac0da1f4dda9a27fc906988a3ceaab91e">ParallelLibrary::waitall()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c">ApplicationInterface::synchronize()</a>.</p>

</div>
</div>
<a id="aee0c1bebc31beef5e63c586ee5ab2102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0c1bebc31beef5e63c586ee5ab2102">&#9670;&nbsp;</a></span>peer_dynamic_schedule_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void peer_dynamic_schedule_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>blocking dynamic schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a peer partition; executes on iteratorComm master </p>
<p>This code runs on the iteratorCommRank 0 processor (the iterator) and is called from <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c" title="executes a blocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns ...">synchronize()</a> in order to manage a dynamic schedule, as enabled by nonblocking management of local asynchronous jobs. It matches serve_evaluations_{synch,asynch}() for other evaluation partitions, depending on asynchLocalEvalConcurrency; it does not match serve_evaluations_peer() since, for local asynchronous jobs, the first evaluation partition cannot be multiprocessor. It performs function evaluations locally for its portion of the job allocation using <a class="el" href="classDakota_1_1ApplicationInterface.html#af1185f9bf9f8c28564cc17e321c270c1" title="launch new jobs in prp_queue asynchronously (if capacity is available), perform nonblocking query of ...">asynchronous_local_evaluations_nowait()</a>. Single-level and multilevel parallel use intra- and inter-communicators, respectively, for send/receive. Specific syntax is encapsulated within <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a>. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#a0dc753ace80d3219f927d6aa299f3ddd">ApplicationInterface::assign_asynch_local_queue()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a57a30dfb5b4461c9f007e640d8e1ccd9">ApplicationInterface::msgPassRunningMap</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a32b6bf5aee3ef76501106a7dac82712d">ApplicationInterface::numEvalServers</a>, <a class="el" href="classDakota_1_1Interface.html#a8b080aab3a786ee1439b43c3533f1f6a">Interface::outputLevel</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a13f2d6daa991a98a6166c81c6d043599">ApplicationInterface::recvBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aca365a4af48900b49d9a351f94b978ad">ApplicationInterface::recvRequests</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a4733cf30510ad34288d04049a7455811">ApplicationInterface::send_evaluation()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0bcb771de0d7359c4e89b13621c60e84">ApplicationInterface::sendBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae80cc97b45f1fe804ea576301523f540">ApplicationInterface::test_local_backfill()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a8831ca059383efff1d8420f3eb26ef78">ApplicationInterface::test_receives_backfill()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c">ApplicationInterface::synchronize()</a>.</p>

</div>
</div>
<a id="a656ccb76e0320bc17c37d30142e77fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656ccb76e0320bc17c37d30142e77fa9">&#9670;&nbsp;</a></span>asynchronous_local_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asynchronous_local_evaluations </td>
          <td>(</td>
          <td class="paramtype">PRPQueue &amp;&#160;</td>
          <td class="paramname"><em>local_prp_queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>perform all jobs in prp_queue using asynchronous approaches on the local processor </p>
<p>This function provides blocking synchronization for the local asynch case (background system call, nonblocking fork, or threads). It can be called from <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c" title="executes a blocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and returns ...">synchronize()</a> for a complete local scheduling of all asynchronous jobs or from peer_{static,dynamic}_schedule_evaluations() to perform a local portion of the total job set. It uses <a class="el" href="classDakota_1_1ApplicationInterface.html#a0f199698e5566a07258c04affb6272ce" title="Called by map() and other functions to execute the simulation in asynchronous mode....">derived_map_asynch()</a> to initiate asynchronous evaluations and <a class="el" href="classDakota_1_1ApplicationInterface.html#aae893e24d141849c533e4d1cda641a12" title="For asynchronous function evaluations, this method is used to detect completion of jobs and process t...">wait_local_evaluations()</a> to capture completed jobs, and mirrors the <a class="el" href="classDakota_1_1ApplicationInterface.html#a81c9b27b4fd7483615896e0b26553e12" title="blocking dynamic schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a de...">master_dynamic_schedule_evaluations()</a> message passing scheduler as much as possible (<a class="el" href="classDakota_1_1ApplicationInterface.html#aae893e24d141849c533e4d1cda641a12" title="For asynchronous function evaluations, this method is used to detect completion of jobs and process t...">wait_local_evaluations()</a> is modeled after MPI_Waitsome()). </p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#a0dc753ace80d3219f927d6aa299f3ddd">ApplicationInterface::assign_asynch_local_queue()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#add5a374107d8655a79736242fb121deb">ApplicationInterface::asynchLocalActivePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a2bcd55897256c6a8bdc75361ec153d8e">ApplicationInterface::asynchLocalEvalStatic</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a90f4d590328220339cfb50a746b7c232">ApplicationInterface::batchEval</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae4483d7a723e778421cf06201990cf49">ApplicationInterface::completionSet</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ad281347a0d46cea1d522b81cf672b0b3">ApplicationInterface::launch_asynch_local()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a4aec1801f646ee1e65562c9cf9c52a0d">ApplicationInterface::localServerAssigned</a>, <a class="el" href="namespaceDakota.html#af316249372180b96b64418fad862bfb0">Dakota::lookup_by_eval_id()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a32b6bf5aee3ef76501106a7dac82712d">ApplicationInterface::numEvalServers</a>, <a class="el" href="classDakota_1_1Interface.html#a8b080aab3a786ee1439b43c3533f1f6a">Interface::outputLevel</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae5ed784d1b217d14cadd6dabc2bd0543">ApplicationInterface::process_asynch_local()</a>, <a class="el" href="classDakota_1_1Interface.html#ad326a6acce0df29ad63ca5d0b15e90bb">Interface::rawResponseMap</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#aae893e24d141849c533e4d1cda641a12">ApplicationInterface::wait_local_evaluations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#ae94c7702163e6591d63bac4a08c48201">ApplicationInterface::peer_static_schedule_evaluations()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#ab596ce6c762ef2fcfde22f3b2469b02c">ApplicationInterface::synchronize()</a>.</p>

</div>
</div>
<a id="a7e8bb538639ac5ed543d5098b8ab9ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8bb538639ac5ed543d5098b8ab9ee3">&#9670;&nbsp;</a></span>synchronous_local_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void synchronous_local_evaluations </td>
          <td>(</td>
          <td class="paramtype">PRPQueue &amp;&#160;</td>
          <td class="paramname"><em>local_prp_queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>perform all jobs in prp_queue using synchronous approaches on the local processor </p>
<p>This function provides blocking synchronization for the local synchronous case (foreground system call, blocking fork, or procedure call from <a class="el" href="classDakota_1_1ApplicationInterface.html#af70c12f41f85168080d1e68b0334258a" title="Called by map() and other functions to execute the simulation in synchronous mode....">derived_map()</a>). It is called from <a class="el" href="classDakota_1_1ApplicationInterface.html#ae94c7702163e6591d63bac4a08c48201" title="blocking static schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a pee...">peer_static_schedule_evaluations()</a> to perform a local portion of the total job set. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#a4fa4a63f6d149a9ccf16709967b553d3">ApplicationInterface::broadcast_evaluation()</a>, <a class="el" href="classDakota_1_1Interface.html#aba7d467110a2230d5eeb40a7f673f3a1">Interface::currEvalId</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#af70c12f41f85168080d1e68b0334258a">ApplicationInterface::derived_map()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a460bf8a4bf5698bc403ca958c1950941">ApplicationInterface::manage_failure()</a>, <a class="el" href="classDakota_1_1Interface.html#af5a33a6b07c4c6f5d757d214de0f47ca">Interface::multiProcEvalFlag</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a35cfdce1a9f84f8bf8040dde47e0e88d">ApplicationInterface::process_synch_local()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#ae94c7702163e6591d63bac4a08c48201">ApplicationInterface::peer_static_schedule_evaluations()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#abb4f9eafe638564737e1b96934a09bea">ApplicationInterface::peer_static_schedule_evaluations_nowait()</a>.</p>

</div>
</div>
<a id="a5ec8ac43798133cf0bd94cbf6fff50a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec8ac43798133cf0bd94cbf6fff50a4">&#9670;&nbsp;</a></span>master_dynamic_schedule_evaluations_nowait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void master_dynamic_schedule_evaluations_nowait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>execute a nonblocking dynamic schedule in a master-slave partition </p>
<p>This code is called from <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6" title="executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and retur...">synchronize_nowait()</a> to provide the master portion of a nonblocking master-slave algorithm for the dynamic scheduling of evaluations among slave servers. It performs no evaluations locally and matches either <a class="el" href="classDakota_1_1ApplicationInterface.html#a706547d76f07b61b158ff8231b43e3ea" title="serve the evaluation message passing schedulers and perform one synchronous evaluation at a time">serve_evaluations_synch()</a> or <a class="el" href="classDakota_1_1ApplicationInterface.html#aa2fff53bc102ed8138a2e58fbe08c591" title="serve the evaluation message passing schedulers and manage multiple asynchronous evaluations">serve_evaluations_asynch()</a> on the slave servers, depending on the value of asynchLocalEvalConcurrency. Dynamic scheduling assigns jobs in 2 passes. The 1st pass gives each server the same number of jobs (equal to asynchLocalEvalConcurrency). The 2nd pass assigns the remaining jobs to slave servers as previous jobs are completed. Single- and multilevel parallel use intra- and inter-communicators, respectively, for send/receive. Specific syntax is encapsulated within <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a>. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5d84b86ed363bf09f58b7a723e2c8a03">ApplicationInterface::headerFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a57a30dfb5b4461c9f007e640d8e1ccd9">ApplicationInterface::msgPassRunningMap</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a32b6bf5aee3ef76501106a7dac82712d">ApplicationInterface::numEvalServers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a13f2d6daa991a98a6166c81c6d043599">ApplicationInterface::recvBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aca365a4af48900b49d9a351f94b978ad">ApplicationInterface::recvRequests</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a4733cf30510ad34288d04049a7455811">ApplicationInterface::send_evaluation()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0bcb771de0d7359c4e89b13621c60e84">ApplicationInterface::sendBuffers</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a8831ca059383efff1d8420f3eb26ef78">ApplicationInterface::test_receives_backfill()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6">ApplicationInterface::synchronize_nowait()</a>.</p>

</div>
</div>
<a id="abb4f9eafe638564737e1b96934a09bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4f9eafe638564737e1b96934a09bea">&#9670;&nbsp;</a></span>peer_static_schedule_evaluations_nowait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void peer_static_schedule_evaluations_nowait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>execute a nonblocking static schedule in a peer partition </p>
<p>This code runs on the iteratorCommRank 0 processor (the iterator) and is called from <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6" title="executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and retur...">synchronize_nowait()</a> in order to manage a nonblocking static schedule. It matches <a class="el" href="classDakota_1_1ApplicationInterface.html#a706547d76f07b61b158ff8231b43e3ea" title="serve the evaluation message passing schedulers and perform one synchronous evaluation at a time">serve_evaluations_synch()</a> for other evaluation partitions (asynchLocalEvalConcurrency == 1). It performs blocking local function evaluations, one at a time, for its portion of the static schedule and checks for remote completions in between each local completion. Therefore, unlike <a class="el" href="classDakota_1_1ApplicationInterface.html#a5531a6d9294fd47a6cb6153df68403dc" title="execute a nonblocking dynamic schedule in a peer partition">peer_dynamic_schedule_evaluations_nowait()</a>, this scheduler will always return at least one job. Single-level and multilevel parallel use intra- and inter-communicators, respectively, for send/receive, with specific syntax as encapsulated within <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a>. The iteratorCommRank 0 processor assigns the static schedule since it is the only processor with access to beforeSynchCorePRPQueue (it runs the iterator and calls synchronize). The alternate design of each peer selecting its own jobs using the modulus operator would be applicable if execution of this function (and therefore the job list) were distributed. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0dc753ace80d3219f927d6aa299f3ddd">ApplicationInterface::assign_asynch_local_queue()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5c5924e44a3371e6ae107d5e5ccd3da8">ApplicationInterface::assign_asynch_local_queue_nowait()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#add5a374107d8655a79736242fb121deb">ApplicationInterface::asynchLocalActivePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5d84b86ed363bf09f58b7a723e2c8a03">ApplicationInterface::headerFlag</a>, <a class="el" href="classDakota_1_1Interface.html#a49a9dda05ef271e5ad2836c4616a3e14">Interface::interfaceType</a>, <a class="el" href="namespaceDakota.html#af316249372180b96b64418fad862bfb0">Dakota::lookup_by_eval_id()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a57a30dfb5b4461c9f007e640d8e1ccd9">ApplicationInterface::msgPassRunningMap</a>, <a class="el" href="classDakota_1_1Interface.html#af5a33a6b07c4c6f5d757d214de0f47ca">Interface::multiProcEvalFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0cb2dcc5b142f601894f54fca983c631">ApplicationInterface::nowaitEvalIdRef</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a32b6bf5aee3ef76501106a7dac82712d">ApplicationInterface::numEvalServers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a13f2d6daa991a98a6166c81c6d043599">ApplicationInterface::recvBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aca365a4af48900b49d9a351f94b978ad">ApplicationInterface::recvRequests</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a4733cf30510ad34288d04049a7455811">ApplicationInterface::send_evaluation()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0bcb771de0d7359c4e89b13621c60e84">ApplicationInterface::sendBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a7e8bb538639ac5ed543d5098b8ab9ee3">ApplicationInterface::synchronous_local_evaluations()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae80cc97b45f1fe804ea576301523f540">ApplicationInterface::test_local_backfill()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a8831ca059383efff1d8420f3eb26ef78">ApplicationInterface::test_receives_backfill()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6">ApplicationInterface::synchronize_nowait()</a>.</p>

</div>
</div>
<a id="a5531a6d9294fd47a6cb6153df68403dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5531a6d9294fd47a6cb6153df68403dc">&#9670;&nbsp;</a></span>peer_dynamic_schedule_evaluations_nowait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void peer_dynamic_schedule_evaluations_nowait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>execute a nonblocking dynamic schedule in a peer partition </p>
<p>This code runs on the iteratorCommRank 0 processor (the iterator) and is called from <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6" title="executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and retur...">synchronize_nowait()</a> in order to manage a nonblocking static schedule. It matches serve_evaluations_{synch,asynch}() for other evaluation partitions (depending on asynchLocalEvalConcurrency). It performs nonblocking local function evaluations for its portion of the static schedule using <a class="el" href="classDakota_1_1ApplicationInterface.html#a656ccb76e0320bc17c37d30142e77fa9" title="perform all jobs in prp_queue using asynchronous approaches on the local processor">asynchronous_local_evaluations()</a>. Single-level and multilevel parallel use intra- and inter-communicators, respectively, for send/receive, with specific syntax as encapsulated within <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a>. The iteratorCommRank 0 processor assigns the dynamic schedule since it is the only processor with access to beforeSynchCorePRPQueue (it runs the iterator and calls synchronize). The alternate design of each peer selecting its own jobs using the modulus operator would be applicable if execution of this function (and therefore the job list) were distributed. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0dc753ace80d3219f927d6aa299f3ddd">ApplicationInterface::assign_asynch_local_queue()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5c5924e44a3371e6ae107d5e5ccd3da8">ApplicationInterface::assign_asynch_local_queue_nowait()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#add5a374107d8655a79736242fb121deb">ApplicationInterface::asynchLocalActivePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a02d589aa531ab9b0ba74cdfc21187f2e">ApplicationInterface::beforeSynchCorePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5d84b86ed363bf09f58b7a723e2c8a03">ApplicationInterface::headerFlag</a>, <a class="el" href="namespaceDakota.html#af316249372180b96b64418fad862bfb0">Dakota::lookup_by_eval_id()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a57a30dfb5b4461c9f007e640d8e1ccd9">ApplicationInterface::msgPassRunningMap</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a32b6bf5aee3ef76501106a7dac82712d">ApplicationInterface::numEvalServers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a13f2d6daa991a98a6166c81c6d043599">ApplicationInterface::recvBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aca365a4af48900b49d9a351f94b978ad">ApplicationInterface::recvRequests</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a4733cf30510ad34288d04049a7455811">ApplicationInterface::send_evaluation()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0bcb771de0d7359c4e89b13621c60e84">ApplicationInterface::sendBuffers</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae80cc97b45f1fe804ea576301523f540">ApplicationInterface::test_local_backfill()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a8831ca059383efff1d8420f3eb26ef78">ApplicationInterface::test_receives_backfill()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6">ApplicationInterface::synchronize_nowait()</a>.</p>

</div>
</div>
<a id="af1185f9bf9f8c28564cc17e321c270c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1185f9bf9f8c28564cc17e321c270c1">&#9670;&nbsp;</a></span>asynchronous_local_evaluations_nowait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asynchronous_local_evaluations_nowait </td>
          <td>(</td>
          <td class="paramtype">PRPQueue &amp;&#160;</td>
          <td class="paramname"><em>local_prp_queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>launch new jobs in prp_queue asynchronously (if capacity is available), perform nonblocking query of all running jobs, and process any completed jobs (handles both local master- and local peer-scheduling cases) </p>
<p>This function provides nonblocking synchronization for the local asynch case (background system call, nonblocking fork, or threads). It is called from <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6" title="executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and retur...">synchronize_nowait()</a> and passed the complete set of all asynchronous jobs (beforeSynchCorePRPQueue). It uses <a class="el" href="classDakota_1_1ApplicationInterface.html#a0f199698e5566a07258c04affb6272ce" title="Called by map() and other functions to execute the simulation in asynchronous mode....">derived_map_asynch()</a> to initiate asynchronous evaluations and <a class="el" href="classDakota_1_1ApplicationInterface.html#a7e6f6329d17c2e4f8c0d03247ddbb3aa" title="For asynchronous function evaluations, this method is used to detect completion of jobs and process t...">test_local_evaluations()</a> to capture completed jobs in nonblocking mode. It mirrors a nonblocking message passing scheduler as much as possible (<a class="el" href="classDakota_1_1ApplicationInterface.html#a7e6f6329d17c2e4f8c0d03247ddbb3aa" title="For asynchronous function evaluations, this method is used to detect completion of jobs and process t...">test_local_evaluations()</a> modeled after MPI_Testsome()). The result of this function is rawResponseMap, which uses eval_id as a key. It is assumed that the incoming local_prp_queue contains only active and new jobs - i.e., all completed jobs are cleared by <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6" title="executes a nonblocking schedule for asynchronous evaluations in the beforeSynchCorePRPQueue and retur...">synchronize_nowait()</a>.</p>
<p>Also supports asynchronous local evaluations with static scheduling. This scheduling policy specifically ensures that a completed asynchronous evaluation eval_id is replaced with an equivalent one, modulo asynchLocalEvalConcurrency. In the nowait case, this could render some servers idle if evaluations don't come in eval_id order or some evaluations are cancelled by the caller in between calls. If this function is called with unlimited local eval concurrency, the static scheduling request is ignored. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ApplicationInterface.html#a5c5924e44a3371e6ae107d5e5ccd3da8">ApplicationInterface::assign_asynch_local_queue_nowait()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#add5a374107d8655a79736242fb121deb">ApplicationInterface::asynchLocalActivePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a2bcd55897256c6a8bdc75361ec153d8e">ApplicationInterface::asynchLocalEvalStatic</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a5d84b86ed363bf09f58b7a723e2c8a03">ApplicationInterface::headerFlag</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#ae80cc97b45f1fe804ea576301523f540">ApplicationInterface::test_local_backfill()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a2a0e88fca3d4b493e3f90d98efd23ea6">ApplicationInterface::synchronize_nowait()</a>.</p>

</div>
</div>
<a id="a706547d76f07b61b158ff8231b43e3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706547d76f07b61b158ff8231b43e3ea">&#9670;&nbsp;</a></span>serve_evaluations_synch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serve_evaluations_synch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serve the evaluation message passing schedulers and perform one synchronous evaluation at a time </p>
<p>This code is invoked by <a class="el" href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe" title="run on evaluation servers to serve the iterator master">serve_evaluations()</a> to perform one synchronous job at a time on each slave/peer server. The servers receive requests (blocking receive), do local synchronous maps, and return results. This is done continuously until a termination signal is received from the master (sent via <a class="el" href="classDakota_1_1ApplicationInterface.html#a26356baa3f4edc1c7b134d8d74bb02b6" title="used by the iterator master to terminate evaluation servers">stop_evaluation_servers()</a>). </p>

<p class="reference">References <a class="el" href="classDakota_1_1ParallelLibrary.html#a0af7505d094d0f9a54eba49ef962840b">ParallelLibrary::bcast_e()</a>, <a class="el" href="classDakota_1_1Interface.html#aba7d467110a2230d5eeb40a7f673f3a1">Interface::currEvalId</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#af70c12f41f85168080d1e68b0334258a">ApplicationInterface::derived_map()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a544a69f893c0bb3c93c67354f9f83889">ApplicationInterface::evalCommRank</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a922f3dc407f5e8ba89c191ae9b64b1c1">ParallelLibrary::isend_ie()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a25b2bb80cf1124a93e1f2e5aed290b24">ApplicationInterface::lenResponseMessage</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aafd93698b70eb2916e2e9f4f8c73c5f2">ApplicationInterface::lenVarsActSetMessage</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a460bf8a4bf5698bc403ca958c1950941">ApplicationInterface::manage_failure()</a>, <a class="el" href="classDakota_1_1Interface.html#af5a33a6b07c4c6f5d757d214de0f47ca">Interface::multiProcEvalFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a288204806aadd5d70a68c4c72aa6666a">ParallelLibrary::recv_ie()</a>, <a class="el" href="classDakota_1_1MPIPackBuffer.html#ad20897c5c8bd47f5d4005989bead0e55">MPIPackBuffer::reset()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#acf85586a030d85f483d16c41336ad115">ApplicationInterface::sharedRespData</a>, and <a class="el" href="classDakota_1_1ParallelLibrary.html#ade7b5596f2367630dd0e8f6a21521fa4">ParallelLibrary::wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe">ApplicationInterface::serve_evaluations()</a>.</p>

</div>
</div>
<a id="a203db1af5f56cb9186ffca180380333f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203db1af5f56cb9186ffca180380333f">&#9670;&nbsp;</a></span>serve_evaluations_synch_peer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serve_evaluations_synch_peer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serve the evaluation message passing schedulers and perform one synchronous evaluation at a time as part of the 1st peer </p>
<p>This code is invoked by <a class="el" href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe" title="run on evaluation servers to serve the iterator master">serve_evaluations()</a> to perform a synchronous evaluation in coordination with the iteratorCommRank 0 processor (the iterator) for static schedules. The bcast() matches either the bcast() in <a class="el" href="classDakota_1_1ApplicationInterface.html#a7e8bb538639ac5ed543d5098b8ab9ee3" title="perform all jobs in prp_queue using synchronous approaches on the local processor">synchronous_local_evaluations()</a>, which is invoked by <a class="el" href="classDakota_1_1ApplicationInterface.html#ae94c7702163e6591d63bac4a08c48201" title="blocking static schedule of all evaluations in beforeSynchCorePRPQueue using message passing on a pee...">peer_static_schedule_evaluations()</a>, or the bcast() in <a class="el" href="classDakota_1_1ApplicationInterface.html#a999c6f807e9ea92b96d6bbc2f7873cca" title="Provides a &quot;mapping&quot; of variables to responses using a simulation. Protected due to Interface letter-...">map()</a>. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ParallelLibrary.html#a0af7505d094d0f9a54eba49ef962840b">ParallelLibrary::bcast_e()</a>, <a class="el" href="classDakota_1_1Interface.html#aba7d467110a2230d5eeb40a7f673f3a1">Interface::currEvalId</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#af70c12f41f85168080d1e68b0334258a">ApplicationInterface::derived_map()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aafd93698b70eb2916e2e9f4f8c73c5f2">ApplicationInterface::lenVarsActSetMessage</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a460bf8a4bf5698bc403ca958c1950941">ApplicationInterface::manage_failure()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#acf85586a030d85f483d16c41336ad115">ApplicationInterface::sharedRespData</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe">ApplicationInterface::serve_evaluations()</a>.</p>

</div>
</div>
<a id="aa2fff53bc102ed8138a2e58fbe08c591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fff53bc102ed8138a2e58fbe08c591">&#9670;&nbsp;</a></span>serve_evaluations_asynch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serve_evaluations_asynch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serve the evaluation message passing schedulers and manage multiple asynchronous evaluations </p>
<p>This code is invoked by <a class="el" href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe" title="run on evaluation servers to serve the iterator master">serve_evaluations()</a> to perform multiple asynchronous jobs on each slave/peer server. The servers test for any incoming jobs, launch any new jobs, process any completed jobs, and return any results. Each of these components is nonblocking, although the server loop continues until a termination signal is received from the master (sent via <a class="el" href="classDakota_1_1ApplicationInterface.html#a26356baa3f4edc1c7b134d8d74bb02b6" title="used by the iterator master to terminate evaluation servers">stop_evaluation_servers()</a>). In the master-slave case, the master maintains the correct number of jobs on each slave. In the static scheduling case, each server is responsible for limiting concurrency (since the entire static schedule is sent to the peers at start up). </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#add5a374107d8655a79736242fb121deb">ApplicationInterface::asynchLocalActivePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a0af7505d094d0f9a54eba49ef962840b">ParallelLibrary::bcast_e()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae4483d7a723e778421cf06201990cf49">ApplicationInterface::completionSet</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a544a69f893c0bb3c93c67354f9f83889">ApplicationInterface::evalCommRank</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a34756512f60498292e8f49b90ef66ecd">ParallelLibrary::irecv_ie()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ad281347a0d46cea1d522b81cf672b0b3">ApplicationInterface::launch_asynch_local()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a25b2bb80cf1124a93e1f2e5aed290b24">ApplicationInterface::lenResponseMessage</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aafd93698b70eb2916e2e9f4f8c73c5f2">ApplicationInterface::lenVarsActSetMessage</a>, <a class="el" href="namespaceDakota.html#af316249372180b96b64418fad862bfb0">Dakota::lookup_by_eval_id()</a>, <a class="el" href="classDakota_1_1Interface.html#af5a33a6b07c4c6f5d757d214de0f47ca">Interface::multiProcEvalFlag</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a288204806aadd5d70a68c4c72aa6666a">ParallelLibrary::recv_ie()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a1b89c7baf77d4540e49797fc5cf26b19">ParallelLibrary::send_ie()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a22e0de6657ded44b138e2895e954d4e0">ParallelLibrary::test()</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a7e6f6329d17c2e4f8c0d03247ddbb3aa">ApplicationInterface::test_local_evaluations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe">ApplicationInterface::serve_evaluations()</a>.</p>

</div>
</div>
<a id="a09809d49a953208a059e0c349db956b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09809d49a953208a059e0c349db956b9">&#9670;&nbsp;</a></span>serve_evaluations_asynch_peer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serve_evaluations_asynch_peer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serve the evaluation message passing schedulers and perform multiple asynchronous evaluations as part of the 1st peer </p>
<p>This code is invoked by <a class="el" href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe" title="run on evaluation servers to serve the iterator master">serve_evaluations()</a> to perform multiple asynchronous jobs on multiprocessor slave/peer servers. It matches the multiProcEvalFlag bcasts in <a class="el" href="classDakota_1_1ApplicationInterface.html#a656ccb76e0320bc17c37d30142e77fa9" title="perform all jobs in prp_queue using asynchronous approaches on the local processor">ApplicationInterface::asynchronous_local_evaluations()</a>. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#add5a374107d8655a79736242fb121deb">ApplicationInterface::asynchLocalActivePRPQueue</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a0968f1e0bd0c496620975c39d01866c8">ApplicationInterface::asynchLocalEvalConcurrency</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a0af7505d094d0f9a54eba49ef962840b">ParallelLibrary::bcast_e()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ae4483d7a723e778421cf06201990cf49">ApplicationInterface::completionSet</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#ad281347a0d46cea1d522b81cf672b0b3">ApplicationInterface::launch_asynch_local()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#aafd93698b70eb2916e2e9f4f8c73c5f2">ApplicationInterface::lenVarsActSetMessage</a>, <a class="el" href="namespaceDakota.html#af316249372180b96b64418fad862bfb0">Dakota::lookup_by_eval_id()</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3">ApplicationInterface::parallelLib</a>, and <a class="el" href="classDakota_1_1ApplicationInterface.html#a7e6f6329d17c2e4f8c0d03247ddbb3aa">ApplicationInterface::test_local_evaluations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1ApplicationInterface.html#a582aaa84632e91b7e27efaf011c585fe">ApplicationInterface::serve_evaluations()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ApplicationInterface.hpp</li>
<li>ApplicationInterface.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
