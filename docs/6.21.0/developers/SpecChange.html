<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Dakota Developers Manual" />
<meta name="keywords" content="optimization, uncertainty quantification, model calibration, parameter estimation, sensitivity analysis, parallel computing, developers manual" />
<meta name="sandia.approval_type" content="formal" />
<meta name="sandia.approved" content="2010-2185" />
<link rev="owns" title="Brian M. Adams" href="mailto:briadam@sandia.gov" />
<meta name="Author" content="Brian M. Adams" />
<title>Dakota: Instructions for Modifying Dakota&#39;s Input Specification</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DAKOTA_Arrow_Name_77x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dakota
   &#160;<span id="projectnumber">Version 6.21</span>
   </div>
   <div id="projectbrief">Explore and Predict with Confidence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Instructions for Modifying <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a>'s Input Specification </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<b>Specification Change Table of Contents</b>
<ul>

<li> <a href="SpecChange.html#ModXMLSpec"> XML input specification</a>
  <ul>
  <li> <a href="SpecChange.html#ModXMLSpecReq"> XML Build Requirements</a>
  <li> <a href="SpecChange.html#ModXMLSpecTools"> XML Editing Tools</a>
  <li> <a href="SpecChange.html#ModXMLSpecFeatures"> XML Features (with map to NIDR)</a>
  </ul>

<li> <a href="SpecChange.html#RebuildGenFiles"> Rebuild generated files</a>

<li> <a href="SpecChange.html#UpdateNIDRPDDB"> Update parser source NIDRProblemDescDB.cpp</a>

<li> <a href="SpecChange.html#UpdateData"> Update Corresponding Data Classes</a>
  <ul>
  <li> <a href="SpecChange.html#UpdateDatap1"> Update the Data class header file</a>
  <li> <a href="SpecChange.html#UpdateDatap2"> Update the .cpp file</a>
  </ul>
<li> <a href="SpecChange.html#UpdatePDDB"> Update database source ProblemDescDB.cpp</a>
  <ul>
  <li> <a href="SpecChange.html#UpdatePDDBp1"> Augment/update get_<data_type>() functions</a>
  </ul>

<li> <a href="SpecChange.html#UseFns"> Use get_<data_type>() Functions</a>

<li> <a href="SpecChange.html#UpdateDocs"> Update the Documentation</a>

</ul>
</p>
<p>To modify Dakota's input specification (for maintenance or addition of new input syntax), specification maintenance mode must be enabled at Dakota configure time with the <code>-DENABLE_SPEC_MAINT</code> option, e.g., </p><div class="fragment"><div class="line">./cmake -DENABLE_SPEC_MAINT:BOOL=ON ..</div>
</div><!-- fragment --><p> This will enable regeneration of NIDR and Dakota components which must be updated following a spec change.</p>
<h1><a class="anchor" id="ModXMLSpec"></a>
XML Input Specification</h1>
<p>The authoritative source for valid Dakota input grammar is <code>dakota/src/dakota.xml</code>. The schema defining valid content for this XML file is in <code>dakota/src/dakota.xsd</code>. NIDR remains Dakota's user input file parser, so <code>dakota.xml</code> is translated to <code>dakota/src/dakota.input.nspec</code> during the Dakota build process. To update the XML input definition: </p><ul>
<li>
<p class="startli">Make sure ENABLE_SPEC_MAINT is enabled in your build and necessary Java development tools are installed (see below).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Edit the XML spec in <code>dakota.xml</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Perform a make in <code>dakota.build/src</code> which will regenerate <code>dakota.source/src/dakota</code>.input.nspec and related file.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Review that any changes induced in the <code>dakota.input.nspec</code> file are as expected.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Proceed with verifying code changes and making downstream parse handler changes as normal (described below).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Commit the modified <code>dakota.xml</code>, <code>dakota.input.nspec</code>, and other files generated to <code>dakota.source/src</code> along with your other code changes.</p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="ModXMLSpecReq"></a>
XML Build Requirements</h2>
<p>Editing the XML and then compiling Dakota requires</p>
<ul>
<li>Java Development Kit (JDK) providing the Java compiler javac. Java 6 (version 1.6) or newer should work, with Java 8 recommended. Can satisfy on RHEL6 with RPM packages <code>java-1.8.0-openjdk-devel</code> and <code>java-1.8.0-openjdk</code>. This is needed to build the Java-based XML to NIDR translator. If this becomes too burdensome, we can check in the generated <code>xml2nidr.jar</code> file.</li>
</ul>
<h2><a class="anchor" id="ModXMLSpecTools"></a>
XML Editing Tools</h2>
<p>The following tools will make editing dakota.input.xml easier.</p>
<ul>
<li>
<p class="startli"><b>Recommended: Eclipse Web Tools Platform.</b> Includes both graphical and text editors.</p>
<ol>
<li>
Download Eclipse Standard (Classic) </li>
<li>
Configure proxy if needed, setting to manual: Window &gt; Preferences &gt; General &gt; Network Connection &gt; Proxy </li>
<li>
<p class="startli">Install Web Tools Platform</p><ul>
<li>Help &gt; Install New Software</li>
<li>Work With: Kepler - <a href="http://download.eclipse.org/releases/kepler">http://download.eclipse.org/releases/kepler</a></li>
<li>Search "Eclipse X" and install two packages under Web, XML, Java<ul>
<li>Eclipse XML Editors and Tools</li>
<li>Eclipse XSL Developer Tools</li>
</ul>
</li>
<li>Optionally install C/C++ Development Tools </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Optional: add Subclipse for subversion (Subversive is the other major competing tool and I don't think requires JavaHL) Help &gt; Install New Software Work With: <a href="http://subclipse.tigris.org/update_1.6.x">http://subclipse.tigris.org/update_1.6.x</a> Install Subclipse On Linux: yum install subversion-javahl.x86_64 </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Alternately install Eclipse for Java or Eclipse Java EE development which includes webtools, then optionally add subclipse and C/C++ dev</p>
<p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Alternate: Emacs or your usual editor.</b> For example, Emacs supports an Nxml mode. You can tell it where to find the schema, edit XML, and have it perform validation against the schema. See help at <a href="http://www.gnu.org/software/emacs/manual/html_mono/nxml-mode.html">http://www.gnu.org/software/emacs/manual/html_mono/nxml-mode.html</a> </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Other Suggested Alternates:</b> XMLSpy, DreamWeaver, XML Copy Editor</p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="ModXMLSpecFeatures"></a>
XML Features (with map to NIDR)</h2>
<p>Out of necessity, Dakota XML <code>dakota.xml</code> closely mirrors <code>dakota.input.nspec</code>. Valid Dakota input grammar is constrained by <code>dakota.xml</code>, an XML document which must validate against <code>dakota.xsd</code>. The top-level element of interest is <code></code> &lt;input&gt;, which is comprised of a sequence of content elements (keywords, alternates, etc.), which may themselves contain additional child content elements. The key content types are:</p>
<ul>
<li>
<p class="startli"><b>Keyword (<code></code> &lt;keyword&gt;):</b>, specified with the <code></code> &lt;keyword&gt; element whose definition is given by keywordType in <code>dakota.xsd</code>. The required attributes are: </p><ul>
<li>
<p class="startli"><b>name:</b> The keyword name (lower case with underscores) as it will be given in user input; must follow same uniqueness rules are historical NIDR. User input is allowed in mixed case, but the XML must use lower case names. </p>
<p class="interli">Since the NIDR parser allows keyword abbreviation, you <em>must</em> not add a keyword that could be misinterpreted as an abbreviation for a different keyword within the same top-level keyword, such as "environment" and "method". For example, adding the keyword "expansion" within the method specification would be a mistake if the keyword "expansion_factor" already was being used in this block.</p>
<p class="interli">The NIDR input is somewhat order-dependent, allowing the same keyword to be reused multiple times in the specification. This often happens with aliases, such as <code>lower_bounds</code>, <code>upper_bounds</code> and <code>initial_point</code>. Ambiguities are resolved by attaching a keyword to the most recently seen context in which it could appear, if such exists, or to the first relevant context that subsequently comes along in the input file.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>code:</b> The verbatim NIDR handler to be invoked when this keyword parsed. In NIDR this was specified with {N_macro(...)}.</p>
<p class="endli"></p>
</li>
</ul>
<p class="interli">Optional/useful parser-related elements/attributes in order of importance are: </p><ul>
<li>
<p class="startli"><b>param sub-element:</b>Parameters and data types: A keyword may have an associated parameter element with a specified data type: <code>&lt;param</code> <code>type="PARAMTYPE"</code> /&gt;. NIDR data types remain the same (INTEGER, REAL, STRING and LISTs thereof, but new data types INPUT_FILE and OUTPUT_FILE add convenience for the GUI, mapping to STRING for NIDR purposes. Parameters can also include attributes <code>constraint</code>, <code>in_taglist</code>, or <code>taglist</code>, which are used to help validate the user-specified parameter value. For example <code>constraint &gt;= 0 LEN normal_uncertain</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>alias sub-element:</b> Historical aliases for this keyword (can appear multiple times). Alias has a single attribute <b>name</b> which must be lower case with underscores.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>id:</b> Unique ID for the keyword, usually name with an integer appended, but not currently used/enforced.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>minOccurs:</b> Minimum occurrences of the keyword in current context (set to 1 for required, 0 for optional)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>maxOccurs:</b> Maximum occurrences of the keyword in current context (for example environment may appear at most once)</p>
<p class="endli"></p>
</li>
</ul>
<p class="interli">And optional/useful GUI-related attributes are: </p><ul>
<li>
<p class="startli"><b>help:</b> (Don't add this attribute the new keywords!) A pointer to the corresponding reference manual section (deprecated as not needed with new reference manual format which mirrors keyword hierarchy).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>label:</b> a short, friendly label string for the keyword in the GUI. Format these like titles, e.g., "Initial Point
         for Search".</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>group:</b> Category or group for this keyword, e.g., optimization vs. parameter study if they are to be groups for GUI purposes</p>
<p class="endli"></p>
</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Alternation (<code></code> &lt;oneOf&gt;):</b> Alternation of groups of content is done with the element <code></code> &lt;oneOf&gt; which indicates that its immediate children are alternates. In NIDR this was done with the pipe symbol: OptionA | OptionB. oneOf allows the label attribute and its use is recommended. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Required Group (<code></code> &lt;required&gt;):</b> A required group can be specified by enclosing the contents in the <code></code> &lt;required&gt; element. In NIDR this was done by enclosing the content in parentheses: ( required group... ) </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Optional Group (<code></code> &lt;optional&gt;):</b> An optional group can be specified by enclosing the contents in the <code></code> &lt;optional&gt; element. In NIDR this was done by enclosing the content in brackets: [ optional group... ] </p>
<p class="endli"></p>
</li>
</ul>
<h1><a class="anchor" id="RebuildGenFiles"></a>
Rebuild Generated Files</h1>
<p>When configured with <code>-DENABLE_SPEC_MAINT</code>, performing a make in <code>dakota.build/src</code> will regenerate all files which derive from <code>dakota.xml</code>, include dakota.input.nspec, NIDR_keywds.hpp, and dakota.input.summary. If you commit changes to a source repository, be sure to commit any automatically generated files in addition to any modified in the following steps. It is not strictly necessary to run make at this point in the sequence, and in fact may generate errors if necessary handlers aren't yet available.</p>
<dl class="section warning"><dt>Warning</dt><dd>Please do not manually modify generated files!</dd></dl>
<h1><a class="anchor" id="UpdateNIDRPDDB"></a>
Update Parser Source NIDRProblemDescDB.cpp</h1>
<p>Many keywords have data associated with them: an integer, a floating-point number, a string, or arrays of such entities. Data requirements are specified in dakota.input.nspec by the tokens INTEGER, REAL, STRING, INTEGERLIST, REALLIST, STRINGLIST. (Some keywords have no associated data and hence no such token.) After each keyword and data token, the dakota.input.nspec file specifies functions that the NIDR parser should call to record the appearance of the keyword and deal with any associated data. The general form of this specification is</p>
<p>{ startfcn, startdata, stopfcn, stopdata }</p>
<p>i.e., a brace-enclosed list of one to four functions and data pointers, with trailing entities taken to be zero if not present; zero for a function means no function will be called. The startfcn must deal with any associated data. Otherwise, the distinction between startfcn and stopfcn is relevant only to keywords that begin a group of keywords (enclosed in parentheses or square brackets). The startfcn is called before other entities in the group are processed, and the stop function is called after they are processed. Top-level keywords often have both startfcn and stopfcn; stopfcn is uncommon but possible for lower-level keywords. The startdata and (if needed) stopdata values are usually pointers to little structures that provide keyword-specific details to generic functions for startfcn and stopfcn. Some keywords that begin groups (such as "approx_problem" within the top-level "environment" keyword) have no need of either a startfcn or a stopfcn; this is indicated by "{0}".</p>
<p>Most of the things within braces in dakota.input.nspec are invocations of macros defined in <code>dakota.source/src/NIDRProblemDescDB</code>.cpp. The macros simplify writing dakota.input.nspec and make it more readable. Most macro invocations refer to little structures defined in NIDRProblemDescDB.cpp, usually with the help of other macros, some of which have different definitions in different parts of NIDRProblemDescDB.cpp. When adding a keyword to dakota.input.nspec, you may need to add a structure definition or even introduce a new data type. NIDRProblemDescDB.cpp has sections corresponding to each top-level keyword. The top-level keywords are in alphabetical order, and most entities in the section for a top-level keyword are also in alphabetical order. While not required, it is probably good practice to maintain this structure, as it makes things easier to find.</p>
<p>Any integer, real, or string data associated with a keyword are provided to the keyword's startfcn, whose second argument is a pointer to a <code>Values</code> structure, defined in header file <code>nidr.h</code>.</p>
<p><b>Example 1:</b> if you added the specification: </p><pre class="fragment">    [method_setting REAL {method_setting_start, &amp;method_setting_details} ]
</pre><p> you would provide a function </p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> NIDRProblemDescDB::</div>
<div class="line">method_setting_start(<span class="keyword">const</span> <span class="keywordtype">char</span> *keyname, Values *val, <span class="keywordtype">void</span> **g, <span class="keywordtype">void</span> *v)</div>
<div class="line">{ ... }</div>
</div><!-- fragment --><p> in NIDRProblemDescDB.cpp. In this example, argument <code>&amp;method_setting_details</code> would be passed as <code>v</code>, <code>val-&gt;n</code> (the number of values) would be 1 and <code>*val-&gt;r</code> would be the REAL value given for the <code>method_setting</code> keyword. The <code>method_setting_start</code> function would suitably store this value with the help of <code>method_setting_details</code>.</p>
<p>For some top-level keywords, <code>g</code> (the third argument to the startfcn and stopfcn) provides access to a relevant context. For example, <code>method_start</code> (the startfcn for the top-level <code>method</code> keyword) executes </p><div class="fragment"><div class="line">DataMethod *dm = <span class="keyword">new</span> DataMethod;</div>
<div class="line">*g = (<span class="keywordtype">void</span>*)dm;</div>
</div><!-- fragment --><p> (and supplies a couple of default values to <code>dm</code>). The start functions for lower-level keywords within the <code>method</code> keyword get access to <code>dm</code> through their <code>g</code> arguments. Here is an example: </p><div class="fragment"><div class="line"> <span class="keywordtype">void</span> NIDRProblemDescDB::</div>
<div class="line">method_str(<span class="keyword">const</span> <span class="keywordtype">char</span> *keyname, Values *val, <span class="keywordtype">void</span> **g, <span class="keywordtype">void</span> *v)</div>
<div class="line">{</div>
<div class="line">        (*(DataMethod**)g)-&gt;**(String DataMethod::**)v = *val-&gt;s;</div>
<div class="line">        }</div>
</div><!-- fragment --><p> In this example, <code>v</code> points to a pointer-to-member, and an assignment is made to one of the components of the <a class="el" href="classDakota_1_1DataMethod.html" title="Handle class for method specification data.">DataMethod</a> object pointed to by <code>*g</code>. The corresponding stopfcn for the top-level <code>method</code> keyword is </p><div class="fragment"><div class="line"> <span class="keywordtype">void</span> NIDRProblemDescDB::</div>
<div class="line">method_stop(<span class="keyword">const</span> <span class="keywordtype">char</span> *keyname, Values *val, <span class="keywordtype">void</span> **g, <span class="keywordtype">void</span> *v)</div>
<div class="line">{</div>
<div class="line">        DataMethod *p = *(DataMethod**)g;</div>
<div class="line">        <a class="code" href="classDakota_1_1NIDRProblemDescDB.html#a8ad0426842e4b2a9cbc997aae092a85d">pDDBInstance</a>-&gt;<a class="code" href="classDakota_1_1ProblemDescDB.html#add43584a6533c7e67c2d6918012fb295">dataMethodList</a>.insert(*p);</div>
<div class="line">        <span class="keyword">delete</span> p;</div>
<div class="line">        }</div>
</div><!-- fragment --><p> which copies the now populated <a class="el" href="classDakota_1_1DataMethod.html" title="Handle class for method specification data.">DataMethod</a> object to the right place and cleans up.</p>
<p><b>Example 2:</b> if you added the specification </p><pre class="fragment">    [method_setting REALLIST {{N_mdm(RealL,methodCoeffs)}
</pre><p> then method_RealL (defined in NIDRProblemDescDB.cpp) would be called as the startfcn, and methodCoeffs would be the name of a (currently nonexistent) component of <a class="el" href="classDakota_1_1DataMethod.html" title="Handle class for method specification data.">DataMethod</a>. The N_mdm macro is defined in NIDRProblemDescDB.cpp; among other things, it turns <code>RealL</code> into <code>NIDRProblemDescDB::method_RealL</code>. This function is used to process lists of REAL values for several keywords. By looking at the source, you can see that the list values are val-&gt;r[i] for 0 &lt;= <code>i</code> &lt; val-&gt;n.</p>
<h1><a class="anchor" id="UpdateData"></a>
Update Corresponding Data Classes</h1>
<p>The Data classes (<a class="el" href="classDakota_1_1DataEnvironment.html">DataEnvironment</a>, <a class="el" href="classDakota_1_1DataMethod.html">DataMethod</a>, <a class="el" href="classDakota_1_1DataModel.html">DataModel</a>, <a class="el" href="classDakota_1_1DataVariables.html">DataVariables</a>, <a class="el" href="classDakota_1_1DataInterface.html">DataInterface</a>, and <a class="el" href="classDakota_1_1DataResponses.html">DataResponses</a>) store the parsed user input data. In this step, we extend the Data class definitions to include any new attributes referred to in <code>dakota.xml</code> or <code><a class="el" href="classDakota_1_1NIDRProblemDescDB.html" title="The derived input file database utilizing the new IDR parser.">NIDRProblemDescDB</a></code> </p>
<h2><a class="anchor" id="UpdateDatap1"></a>
Update the Data Class Header File</h2>
<p>Add a new attribute to the public data for each of the new specifications. Follow the style guide for class attribute naming conventions (or mimic the existing code).</p>
<h2><a class="anchor" id="UpdateDatap2"></a>
Update the .cpp File</h2>
<p>Define defaults for the new attributes in the constructor initialization list (if not a container with a sensible default constructor) in same order as they appear in the header. Add the new attributes to the write(MPIPackBuffer&amp;), read(MPIUnpackBuffer&amp;), and write(ostream&amp;) functions, paying careful attention to the use of a consistent ordering.</p>
<h1><a class="anchor" id="UpdatePDDB"></a>
Update Database Source ProblemDescDB.cpp</h1>
<h2><a class="anchor" id="UpdatePDDBp1"></a>
Augment/update get_&lt;data_type&gt;() Functions</h2>
<p>The next update step involves extending the database retrieval functions in <code>dakota.source/src/ProblemDescDB</code>.cpp. These retrieval functions accept an identifier string and return a database attribute of a particular type, e.g., a RealVector:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedakota.html#a77b2775985ff72df0799f4fdbd53a270">RealVector</a>&amp; get_rv(<span class="keyword">const</span> String&amp; entry_name);</div>
</div><!-- fragment --><p>The implementation of each of these functions contains tables of possible entry_name values and associated pointer-to-member values. There is one table for each relevant top-level keyword, with the top-level keyword omitted from the names in the table. Since binary search is used to look for names in these tables, each table must be kept in alphabetical order of its entry names. For example,</p>
<div class="fragment"><div class="line">...</div>
<div class="line">else <span class="keywordflow">if</span> ((L = Begins(entry_name, <span class="stringliteral">&quot;model.&quot;</span>))) {</div>
<div class="line">  <span class="keywordflow">if</span> (dbRep-&gt;methodDBLocked)</div>
<div class="line">      Locked_db();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  #define P &amp;DataModelRep::</span></div>
<div class="line">  <span class="keyword">static</span> KW&lt;RealVector, DataModelRep&gt; RVdmo[] = {     <span class="comment">// must be sorted</span></div>
<div class="line">      {<span class="stringliteral">&quot;nested.primary_response_mapping&quot;</span>, P primaryRespCoeffs},</div>
<div class="line">      {<span class="stringliteral">&quot;nested.secondary_response_mapping&quot;</span>, P secondaryRespCoeffs},</div>
<div class="line">      {<span class="stringliteral">&quot;surrogate.kriging_conmin_seed&quot;</span>, P krigingConminSeed},</div>
<div class="line">      {<span class="stringliteral">&quot;surrogate.kriging_correlations&quot;</span>, P krigingCorrelations},</div>
<div class="line">      {<span class="stringliteral">&quot;surrogate.kriging_max_correlations&quot;</span>, P krigingMaxCorrelations},</div>
<div class="line">      {<span class="stringliteral">&quot;surrogate.kriging_min_correlations&quot;</span>, P krigingMinCorrelations}};</div>
<div class="line"><span class="preprocessor">  #undef P</span></div>
<div class="line"> </div>
<div class="line">  KW&lt;RealVector, DataModelRep&gt; *kw;</div>
<div class="line">  <span class="keywordflow">if</span> ((kw = (KW&lt;RealVector, DataModelRep&gt;*)Binsearch(RVdmo, L)))</div>
<div class="line">      <span class="keywordflow">return</span> dbRep-&gt;dataModelIter-&gt;dataModelRep-&gt;*kw-&gt;p;</div>
<div class="line">}</div>
</div><!-- fragment --><p>is the "model" portion of <a class="el" href="classDakota_1_1ProblemDescDB.html#a11657c9085d87a9b16bc8c0842c8cbfb">ProblemDescDB::get_rv()</a>. Based on entry_name, it returns the relevant attribute from a <a class="el" href="classDakota_1_1DataModel.html">DataModel</a> object. Since there may be multiple model specifications, the <code>dataModelIter</code> list iterator identifies which node in the list of <a class="el" href="classDakota_1_1DataModel.html">DataModel</a> objects is used. In particular, <code>dataModelList</code> contains a list of all of the <code>data_model</code> objects, one for each time a top-level <code>model</code> keyword was seen by the parser. The particular model object used for the data retrieval is managed by <code>dataModelIter</code>, which is set in a <code>set_db_list_nodes()</code> operation that will not be described here.</p>
<p>There may be multiple <a class="el" href="classDakota_1_1DataMethod.html">DataMethod</a>, <a class="el" href="classDakota_1_1DataModel.html">DataModel</a>, <a class="el" href="classDakota_1_1DataVariables.html">DataVariables</a>, <a class="el" href="classDakota_1_1DataInterface.html">DataInterface</a>, and/or <a class="el" href="classDakota_1_1DataResponses.html">DataResponses</a> objects. However, only one specification is currently allowed so a list of <a class="el" href="classDakota_1_1DataEnvironment.html">DataEnvironment</a> objects is not needed. Rather, <a class="el" href="classDakota_1_1ProblemDescDB.html#a659071d4c201923df5f8f5f64f4c1e2b">ProblemDescDB::environmentSpec</a> is the lone <a class="el" href="classDakota_1_1DataEnvironment.html">DataEnvironment</a> object.</p>
<p>To augment the get_&lt;data_type&gt;() functions, add table entries with new identifier strings and pointer-to-member values that address the appropriate data attributes from the Data class object. The style for the identifier strings is a top-down hierarchical description, with specification levels separated by periods and words separated with underscores, e.g., <code>"keyword.group_specification.individual_specification"</code>. Use the <code>dbRep-&gt;listIter-&gt;attribute</code> syntax for variables, interface, responses, and method specifications. For example, the <code>method_setting</code> example attribute would be added to <code>get_drv()</code> as:</p>
<div class="fragment"><div class="line">{<span class="stringliteral">&quot;method_name.method_setting&quot;</span>, P methodSetting},</div>
</div><!-- fragment --><p>inserted at the beginning of the <code>RVdmo</code> array shown above (since the name in the existing first entry, i.e., "nested.primary_response_mapping", comes alphabetically after "method_name.method_setting").</p>
<h1><a class="anchor" id="UseFns"></a>
Use get_&lt;data_type&gt;() Functions</h1>
<p>At this point, the new specifications have been mapped through all of the database classes. The only remaining step is to retrieve the new data within the constructors of the classes that need it. This is done by invoking the get_&lt;data_type&gt;() function on the <a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> object using the identifier string you selected in <a class="el" href="SpecChange.html#UpdatePDDBp1">Augment/update get_&lt;data_type&gt;() Functions</a>. For example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> String&amp; interface_type = problem_db.get_string(<span class="stringliteral">&quot;interface.type&quot;</span>);</div>
</div><!-- fragment --><p> passes the <code>"interface.type"</code> identifier string to the <a class="el" href="classDakota_1_1ProblemDescDB.html#a8805a6b57225bfbac51f66f30a918c21">ProblemDescDB::get_string()</a> retrieval function, which returns the desired attribute from the active <a class="el" href="classDakota_1_1DataInterface.html">DataInterface</a> object.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use of the get_&lt;data_type&gt;() functions is restricted to class constructors, since only in class constructors are the data list iterators (i.e., <code>dataMethodIter</code>, <code>dataModelIter</code>, <code>dataVariablesIter</code>, <code>dataInterfaceIter</code>, and <code>dataResponsesIter</code>) guaranteed to be set correctly. Outside of the constructors, the database list nodes will correspond to the last set operation, and may not return data from the desired list node.</dd></dl>
<h1><a class="anchor" id="UpdateDocs"></a>
Update the Documentation</h1>
<p>Doxygen comments should be added to the Data class headers for the new attributes, and the reference manual sections describing the portions of <code>dakota.xml</code> that have been modified should be updated by updating files in <code>dakota.source/docs/KeywordMetaData/</code>. d<code>dakota.xml</code>, together with these metadata files generates the reference manual and GUI context-aware help documentation. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassDakota_1_1ProblemDescDB_html_add43584a6533c7e67c2d6918012fb295"><div class="ttname"><a href="classDakota_1_1ProblemDescDB.html#add43584a6533c7e67c2d6918012fb295">Dakota::ProblemDescDB::dataMethodList</a></div><div class="ttdeci">std::list&lt; DataMethod &gt; dataMethodList</div><div class="ttdoc">list of method specifications, one for each call to method_kwhandler() or insert_node()</div><div class="ttdef"><b>Definition:</b> ProblemDescDB.hpp:382</div></div>
<div class="ttc" id="anamespacedakota_html_a77b2775985ff72df0799f4fdbd53a270"><div class="ttname"><a href="namespacedakota.html#a77b2775985ff72df0799f4fdbd53a270">dakota::RealVector</a></div><div class="ttdeci">Teuchos::SerialDenseVector&lt; int, Real &gt; RealVector</div><div class="ttdoc">Dakota vector of reals.</div><div class="ttdef"><b>Definition:</b> util_data_types.hpp:62</div></div>
<div class="ttc" id="aclassDakota_1_1NIDRProblemDescDB_html_a8ad0426842e4b2a9cbc997aae092a85d"><div class="ttname"><a href="classDakota_1_1NIDRProblemDescDB.html#a8ad0426842e4b2a9cbc997aae092a85d">Dakota::NIDRProblemDescDB::pDDBInstance</a></div><div class="ttdeci">static NIDRProblemDescDB * pDDBInstance</div><div class="ttdoc">Pointer to the active object instance used within the static kwhandler functions in order to avoid th...</div><div class="ttdef"><b>Definition:</b> NIDRProblemDescDB.hpp:69</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
