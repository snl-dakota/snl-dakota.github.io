<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Dakota Developers Manual" />
<meta name="keywords" content="optimization, uncertainty quantification, model calibration, parameter estimation, sensitivity analysis, parallel computing, developers manual" />
<meta name="sandia.approval_type" content="formal" />
<meta name="sandia.approved" content="2010-2185" />
<link rev="owns" title="Brian M. Adams" href="mailto:briadam@sandia.gov" />
<meta name="Author" content="Brian M. Adams" />
<title>Dakota: Interfacing with Dakota as a Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DAKOTA_Arrow_Name_77x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dakota
   &#160;<span id="projectnumber">Version 6.20</span>
   </div>
   <div id="projectbrief">Explore and Predict with Confidence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Interfacing with <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> as a Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<b>Dakota Library Table of Contents</b>
<ul>
<li> <a href="DakLibrary.html#DakLibraryIntro">Introduction</a> 
<li> <a href="DakLibrary.html#DakLibraryBasic">Basic Dakota library instantiation

<li> <a href="DakLibrary.html#DakLibraryConfiguring">Configuring Dakota operation</a>
     <ul>
     <li> <a href="DakLibrary.html#DakLibraryConfigParse">Input data parsing</a> 
     <li> <a href="DakLibrary.html#DakLibraryConfigData">Problem database insertion</a>
     <li> <a href="DakLibrary.html#DakLibraryConfigMixed">Mixed mode, callbacks, and late updates</a>
     </ul>

<li> <a href="DakLibrary.html#DakLibraryDirectAppInt">Creating a simulator plugin interface</a>
     <ul>
     <li> <a href="DakLibrary.html#DakLibraryExtendDirectAppInt">Extension</a>
     <li> <a href="DakLibrary.html#DakLibraryDeriveDirectAppInt">Derivation</a>
     </ul>

<li> <a href="DakLibrary.html#DakLibraryPostRun">Retrieving data after a run</a>

<li> <a href="DakLibrary.html#DakLibraryLinking">Linking against the Dakota library</a>

</ul>
</p>
<h1><a class="anchor" id="DakLibraryIntro"></a>
Introduction</h1>
<p>Tightly integrating or linking Dakota into another application can improve user experience by delivering a more unified, inter-operable software tool for optimization and UQ analyses, improving performance by eliminating file system-based interfaces, and reducing challenges with parallel computing inter-operation. This benefit has been realized within several Sandia and external simulation applications. This section describes how to link Dakota into another C++ application.</p>
<p>Dakota has two primary application programming interfaces (APIs). The <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a> class facilitates use of Dakota as an algorithm service library within another application. In this case, the simulation application is providing a "front end" for Dakota. The second API, provided by the <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> class, provides an interface for Dakota to call the simulation code directly to perform function evaluations in core. This permits the simulation to be the "back end" for Dakota. The most complete library integration of Dakota would use both in combination, with the overall simulation framework providing both the front end and back end for Dakota, creating a sandwich, as loosely depicted here:</p>
<pre class="fragment">[------------
[ Application 
[
[  ( -----
[  ( Dakota (LibraryEnvironment)
[  (
[  (  { Function evaluation callback to Application (via DirectApplicInterface)
[  (  {  | 
[ &lt;------/
[  (  {  
[  (    
[  ( -----
[
[------------
</pre><dl class="section attention"><dt>Attention</dt><dd>Dakota may be integrated as a library in other software applications subject to the terms of the GNU Lesser General Public License (LGPL). Refer to <a href="http://www.gnu.org/licenses/lgpl.html">http://www.gnu.org/licenses/lgpl.html</a> or the LICENSE file included with Dakota.</dd></dl>
<p>When Dakota is compiled and installed, the relevant library API headers are installed to <code>CMAKE_INSTALL_PREFIX/include</code> and the runtime libraries primarily to <code>CMAKE_INSTALL_PREFIX/lib/</code> (on some platforms, to <code>CMAKE_INSTALL_PREFIX/bin/</code>. The core C/C++ code is in the library <code>dakota_src</code>, while Fortran code lives in the <code>dakota_src_fortran</code> library. Information on using the API in <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> headers is included throughout this section, while considerations for configuring and linking against Dakota and its various required and optional third&ndash;party libraries are emphasized in the section <a class="el" href="DakLibrary.html#DakLibraryLinking">Linking against the Dakota library</a>.</p>
<p>Steps involved in integrating Dakota into another application typically include:</p>
<ol>
<li>
<p class="startli">Writing C++ code for your application to instantiate, configure, and execute Dakota's <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a> ("front end"); see <a class="el" href="DakLibrary.html#DakLibraryBasic">Basic Dakota library instantiation</a> and <a class="el" href="DakLibrary.html#DakLibraryConfiguring">Configuring Dakota operation</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Writing C++ code for Dakota to call a function in your application to perform function evaluations ("back end"); see <a class="el" href="DakLibrary.html#DakLibraryDirectAppInt">Creating a simulator plugin interface</a>.</p>
<p class="endli"></p>
</li>
<li>
Compiling Dakota and linking into your application (<a class="el" href="DakLibrary.html#DakLibraryLinking">Linking against the Dakota library</a>). </li>
</ol>
<p>Several source code examples demonstrate Dakota library interfaces. The classes <a class="el" href="classSIM_1_1SerialDirectApplicInterface.html" title="Sample derived interface class for testing serial simulator plug-ins using assign_rep().">SIM::SerialDirectApplicInterface</a> and <a class="el" href="classSIM_1_1ParallelDirectApplicInterface.html" title="Sample derived interface class for testing parallel simulator plug-ins using assign_rep().">SIM::ParallelDirectApplicInterface</a> demonstrate serial and parallel simulation function evaluation plug-ins. The file <a class="el" href="library__mode_8cpp.html" title="file containing a mock simulator main for testing Dakota in library mode">library_mode.cpp</a> includes a main program that exercises Dakota libraries in serial and parallel modes with these mock simulator programs, with various ways of configuring Dakota problem definition and operation. Finally, <a class="el" href="library__split_8cpp.html" title="file containing a mock simulator main for testing DAKOTA in library mode on a split communicator">library_split.cpp</a> demonstrates running Dakota as a library modular on an MPI sub-communicator.</p>
<h1><a class="anchor" id="DakLibraryBasic"></a>
Basic Dakota library instantiation</h1>
<p>The function <a class="el" href="library__mode_8cpp.html#a4c56cdfab127f10d34fd9da8c3bdbbc8" title="Run a Dakota LibraryEnvironment, mode 1: parsing an input file.">run_dakota_parse()</a> in <a class="el" href="library__mode_8cpp.html" title="file containing a mock simulator main for testing Dakota in library mode">library_mode.cpp</a> demonstrates the basic use of Dakota library objects as one would in another main application that embeds Dakota. In this example, Dakota is configured based on a typical user-provided text-based Dakota input file (the same that would be provided at the command line with <code>dakota</code> <code>-i</code> <code>dakota_optimization.in</code>) and a function evaluator derived from a <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> is plugged into the Dakota library environment.</p>
<p>First, an object of type <a class="el" href="classDakota_1_1ProgramOptions.html" title="ProgramOptions stores options whether from the CLH or from library user; initially valid only on worl...">ProgramOptions</a> which manages top-level Dakota settings is instantiated and configured to specify the name of the Dakota user input file. Additional options for output and error redirection, restart operation, and more may be set via <a class="el" href="classDakota_1_1ProgramOptions.html" title="ProgramOptions stores options whether from the CLH or from library user; initially valid only on worl...">ProgramOptions</a>. See its class documentation for details. </p><div class="fragment"><div class="line"><span class="keywordtype">string</span> dakota_input_file = <span class="stringliteral">&quot;dakota_optimization.in&quot;</span>;</div>
<div class="line"><a class="code" href="classDakota_1_1ProgramOptions.html">Dakota::ProgramOptions</a> opts;</div>
<div class="line">opts.<a class="code" href="classDakota_1_1ProgramOptions.html#ad499a7fca9139f53caf869f473717134">input_file</a>(dakota_input_file);</div>
</div><!-- fragment --><p>Next, a <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a> is created, passing the desired settings from opts: </p><div class="fragment"><div class="line"><a class="code" href="classDakota_1_1LibraryEnvironment.html">Dakota::LibraryEnvironment</a> env(opts);</div>
</div><!-- fragment --><p>This standard constructor will parse the specified input and create <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> objects. It assumes many default settings, including that the parent application initialized MPI if running in parallel mode. (In this case, Dakota will detect whether MPI was initialized and not call MPI_Init or MPI_Finalize.) For more advanced use cases described below, alternate constructors allow constructing based on MPI communicators, with delayed finalization, and with Dakota database update function callbacks. Then the application's function evaluator implementing Dakota's <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> is plugged in with a convenience function <a class="el" href="library__mode_8cpp.html#a04d45e918d12ef2c28fcec7a7e8a5ae8" title="Convenience function with simplest example of interface plugin: plugin a serial DirectApplicInterface...">serial_interface_plugin()</a> or <a class="el" href="library__mode_8cpp.html#a6229fa90be4b3daf46cbb5310a404054" title="Convenience function to plug a library client&#39;s interface into the appropriate model,...">parallel_interface_plugin()</a>. Finally, the Dakota analysis is run by calling </p><div class="fragment"><div class="line">env.execute(); </div>
</div><!-- fragment --><p>The next two sections offer additional details on (1) alternative and supplementary ways to configure Dakota's operation (<a class="el" href="DakLibrary.html#DakLibraryConfiguring">Configuring Dakota operation</a>) and (2) how to specialize Dakota's <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> to provide a function evaluator plugin to Dakota (<a class="el" href="DakLibrary.html#DakLibraryDirectAppInt">Creating a simulator plugin interface</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>After <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a> construction, all MPI communicator partitioning has been performed and the <a class="el" href="classDakota_1_1ParallelLibrary.html" title="Class for partitioning multiple levels of parallelism and managing message passing within these level...">ParallelLibrary</a> instance may be interrogated for parallel configuration data. For example, the lowest level communicators in Dakota's multilevel parallel partitioning are the analysis communicators, which can be retrieved using: <div class="fragment"><div class="line"><span class="comment">// retrieve the set of analysis communicators for simulation initialization:</span></div>
<div class="line"><span class="comment">// one analysis comm per ParallelConfiguration (PC), one PC per Model.</span></div>
<div class="line">Array&lt;MPI_Comm&gt; analysis_comms = parallel_lib.analysis_intra_communicators();</div>
</div><!-- fragment --> These communicators can then be used for initializing parallel simulation instances when registering the plugin interface, where the number of MPI communicators in the array corresponds to one communicator per <a class="el" href="classDakota_1_1ParallelConfiguration.html" title="Container class for a set of ParallelLevel list iterators that collectively identify a particular mul...">ParallelConfiguration</a> instance. This is demonstrated below in <a class="el" href="DakLibrary.html#DakLibraryDeriveDirectAppInt">Derivation</a>.</dd></dl>
<h1><a class="anchor" id="DakLibraryConfiguring"></a>
Configuring Dakota operation</h1>
<p>This section describes several alternate ways to initially set and later manipulate Dakota's configuration, including alternatives to using a text-based input file. The algorithm configuration for a particular Dakota analysis run is managed in its <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a>, which can be populated via an input file, string literal, or C++ API, and later modified through Dakota's C++ API. All Dakota objects then draw information from this database upon instantiation.</p>
<h2><a class="anchor" id="DakLibraryConfigParse"></a>
Input data parsing</h2>
<p>The simplest way for an application to configure a Dakota analysis problem is to use Dakota's normal input parsing system to populate its problem database (<a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a>). This is done by providing standard Dakota input file syntax through the library interface, via either a file name or string literal. An advantage is that native Dakota syntax can be used, but disadvantages include the requirement for an additional input file beyond those already required by the parent application and that application users also need to know Dakota syntax.</p>
<p>The two ways to configure Dakota via input parsing are shown near the beginning of <a class="el" href="library__mode_8cpp.html#af3af25d98f0d167fe810d7d97c487249" title="Run a Dakota LibraryEnvironment, from string or input file input, supplemented with additional C++ AP...">run_dakota_mixed()</a> in <a class="el" href="library__mode_8cpp.html" title="file containing a mock simulator main for testing Dakota in library mode">library_mode.cpp</a>. Here the <a class="el" href="classDakota_1_1ProgramOptions.html" title="ProgramOptions stores options whether from the CLH or from library user; initially valid only on worl...">ProgramOptions</a> are set to either parse from a named file:</p>
<div class="fragment"><div class="line"><a class="code" href="classDakota_1_1ProgramOptions.html">Dakota::ProgramOptions</a> opts;</div>
<div class="line">opts.<a class="code" href="classDakota_1_1ProgramOptions.html#ad499a7fca9139f53caf869f473717134">input_file</a>(dakota_input_file);</div>
</div><!-- fragment --><p>or from a string literal provided by the wrapping application:</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> <a class="code" href="library__mode_8cpp.html#a94440f841119f76e8318598a8b16ec59">serial_input</a> = <span class="stringliteral">&quot;% Dakota input file ...&quot;</span>;</div>
<div class="line">opts.<a class="code" href="classDakota_1_1ProgramOptions.html#aefbf151a40d8ba59da2858906c49c934">input_string</a>(<a class="code" href="library__mode_8cpp.html#a94440f841119f76e8318598a8b16ec59">serial_input</a>);</div>
</div><!-- fragment --><p>This library approach is coarse-grained in that input is parsed, objects constructed, and the environment is immediately ready to run. The next approaches are more modular.</p>
<h2><a class="anchor" id="DakLibraryConfigData"></a>
Problem database insertion</h2>
<p>A second approach to configuring Dakota's operation is to bypass parsing phases and directly populate the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> with information on the methods, variables, interface, responses, etc., that define the Dakota analysis problem. This approach requires more interaction with Dakota classes and data structures. However, it can offer usability benefit when the integrating application does not want their users to interact with the full Dakota syntax, or efficiency benefit when for example there are a large number of variables to configure.</p>
<p>In the direct database population approach, Dakota <a class="el" href="classDakota_1_1DataMethod.html" title="Handle class for method specification data.">DataMethod</a>, <a class="el" href="classDakota_1_1DataModel.html" title="Handle class for model specification data.">DataModel</a>, <a class="el" href="classDakota_1_1DataVariables.html" title="Handle class for variables specification data.">DataVariables</a>, <a class="el" href="classDakota_1_1DataInterface.html" title="Handle class for interface specification data.">DataInterface</a>, and <a class="el" href="classDakota_1_1DataResponses.html" title="Handle class for responses specification data.">DataResponses</a> objects are instantiated and populated with the desired problem data. These objects are then published to the problem database using <a class="el" href="classDakota_1_1LibraryEnvironment.html#af97d261dfacaf0dff54acd7287ca6bd7">insert_nodes()</a> . An example of this approach is available in <a class="el" href="library__mode_8cpp.html#a7ad2268d4a9b30bce9438131d3d11d6e" title="Run a Dakota LibraryEnvironment, mode 2: from C++ API inserted data.">run_dakota_data()</a> in <a class="el" href="library__mode_8cpp.html" title="file containing a mock simulator main for testing Dakota in library mode">library_mode.cpp</a>, where the OPT++ Quasi-Newton method is configured to work on a plugin version of <code>text_book</code> or <code>rosenbrock</code>. The data objects are populated with their default values upon instantiation and are often sufficient for basic Dakota studies. Only the non-default values need to be specified. Moreover the default Dakota <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> is a SingleModel, so this object need not be configured unless tailoring its configuration or using a more advanced model type. Refer to the <a class="el" href="classDakota_1_1DataMethod.html" title="Handle class for method specification data.">DataMethod</a>, <a class="el" href="classDakota_1_1DataModel.html" title="Handle class for model specification data.">DataModel</a>, <a class="el" href="classDakota_1_1DataVariables.html" title="Handle class for variables specification data.">DataVariables</a>, <a class="el" href="classDakota_1_1DataInterface.html" title="Handle class for interface specification data.">DataInterface</a>, and <a class="el" href="classDakota_1_1DataResponses.html" title="Handle class for responses specification data.">DataResponses</a> class documentation and source code for lists of attributes and their defaults. Here is an excerpt of <a class="el" href="library__mode_8cpp.html#a7ad2268d4a9b30bce9438131d3d11d6e" title="Run a Dakota LibraryEnvironment, mode 2: from C++ API inserted data.">run_dakota_data()</a> that specifies the OPT++ solver after default construction of <a class="el" href="classDakota_1_1DataMethod.html" title="Handle class for method specification data.">DataMethod</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classDakota_1_1DataMethod.html">Dakota::DataMethod</a>   dme;</div>
<div class="line"><a class="code" href="classDakota_1_1DataMethodRep.html">Dakota::DataMethodRep</a>* dmr = dme.<a class="code" href="classDakota_1_1DataMethod.html#a0ad70dff99eca73a6a7a07208e2700e8">data_rep</a>();</div>
<div class="line">dmr-&gt;<a class="code" href="classDakota_1_1DataMethodRep.html#a232e81b24a57f058b946705f9885a44a">methodName</a> = Dakota::OPTPP_Q_NEWTON;</div>
</div><!-- fragment --><p>When using direct database population, it is critical to leave the database in an open, accessible state after initial construction. In this <a class="el" href="library__mode_8cpp.html#a7ad2268d4a9b30bce9438131d3d11d6e" title="Run a Dakota LibraryEnvironment, mode 2: from C++ API inserted data.">run_dakota_data()</a> example, a flag <code>check_bcast_construct</code> is passed into the <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a> constructor, indicating that it should not finalize the database and construct Dakota objects. Moreover, it is only necessary to populate the database on rank 0 of the MPI Comm on which Dakota is running. After database objects are inserted or adjusted, the <a class="el" href="classDakota_1_1LibraryEnvironment.html#a26c47aaca1716ab30ce4b3f375e1d077" title="Check database contents, broadcast, and construct iterators.">LibraryEnvironment::done_modifying_db()</a> function must be called before proceeding to execute. This synchronizes problem data across all ranks and constructs Dakota objects needed to run the specified analysis.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> check_bcast_construct = <span class="keyword">false</span>;</div>
<div class="line"><a class="code" href="classDakota_1_1LibraryEnvironment.html">Dakota::LibraryEnvironment</a> env(MPI_COMM_WORLD, opts, check_bcast_construct);</div>
<div class="line"><span class="keywordflow">if</span> (rank == 0)</div>
<div class="line">  <span class="comment">// insert/modify DB, then lock and proceed:</span></div>
<div class="line">env.done_modifying_db();</div>
<div class="line">env.execute();</div>
</div><!-- fragment --><h2><a class="anchor" id="DakLibraryConfigMixed"></a>
Mixed mode, callbacks, and late updates</h2>
<p>The <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a> API also supports mixed approaches that combine the parsing of a Dakota input file (or input string literal) with direct database updates. This approach is motivated by large-scale applications where large vectors are cumbersome to specify in a Dakota input file or where later updates to an input template are needed. The example <a class="el" href="library__mode_8cpp.html#af3af25d98f0d167fe810d7d97c487249" title="Run a Dakota LibraryEnvironment, from string or input file input, supplemented with additional C++ AP...">run_dakota_mixed()</a> in <a class="el" href="library__mode_8cpp.html" title="file containing a mock simulator main for testing Dakota in library mode">library_mode.cpp</a> demonstrates the combination of these more advanced approaches: (1) input text parsing, (2) database updates via a callback, (3) database updates via direct manipulation, and (4) further runtime updates to the <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> before running.</p>
<p>First, a <a class="el" href="classDakota_1_1ProgramOptions.html" title="ProgramOptions stores options whether from the CLH or from library user; initially valid only on worl...">ProgramOptions</a> class is instantiated and configured to parse either an input file or input string literal (as in earlier examples). The passed input data must contain all required inputs so the parser can validate them. Since vector data like variable values/bounds/tags, linear/nonlinear constraint coefficients/bounds, etc., are optional, these potentially large vector specifications can be omitted from the input file and updated later through the database API. Only the variable/response counts necessary for sizing, e.g.:</p>
<pre class="fragment">method
  linear_inequality_constraints = 500

variables
  continuous_design = 1000

responses
  objective_functions = 1
  nonlinear_inequality_constraints = 100000
</pre><p>and not the lists of values are required in this case. To update or add data after this initial parse, we use the <a class="el" href="classDakota_1_1ProblemDescDB.html#ae418cd2e6e5221d0589e0fb4ea39f9b3">ProblemDescDB::set()</a> family of overloaded functions, e.g.</p>
<div class="fragment"><div class="line">Dakota::RealVector drv(1000, 1.); <span class="comment">// vector of length 1000, values initialized to 1.</span></div>
<div class="line">problem_db.set(<span class="stringliteral">&quot;variables.continuous_design.initial_point&quot;</span>, drv);</div>
</div><!-- fragment --><p>where the string identifiers are the same identifiers used when pulling information from the database using one of the get_&lt;datatype&gt;() functions (refer to <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> for a full list). <br  />
 However, the supported <a class="el" href="classDakota_1_1ProblemDescDB.html#ae418cd2e6e5221d0589e0fb4ea39f9b3">ProblemDescDB::set()</a> options are a restricted subset of the database attributes, focused on vector inputs that can be large scale.</p>
<p>Second, the example demonstrates a user-provided callback function which Dakota will invoke after input parsing to update <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a>. In <code><a class="el" href="library__mode_8cpp.html" title="file containing a mock simulator main for testing Dakota in library mode">library_mode.cpp</a></code>, <a class="el" href="library__mode_8cpp.html#a584c4b9e2ff5e089877c03890b27581c" title="Example: user-provided post-parse callback (Dakota::DbCallbackFunction)">callback_function()</a> is a user-provided post-parse callback that implements the type Dakota::DbCallbackFunction.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="library__mode_8cpp.html#a584c4b9e2ff5e089877c03890b27581c">callback_function</a>(<a class="code" href="classDakota_1_1ProblemDescDB.html">Dakota::ProblemDescDB</a>* db, <span class="keywordtype">void</span> *ptr);</div>
</div><!-- fragment --><p> <br  />
</p>
<p>When Dakota calls this function it will pass back pointers to the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> instance and to user-provided data, so the application may convey its settings by calling methods on the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a>, optionally using the provided data. An example of a user data structure is demonstrated in <code><a class="el" href="structcallback__data.html">callback_data</a></code>. In this case, when the <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a> is constructed, it is constructed with the input data to initially parse, the callback function, and to leave it unlocked for further updates:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> done_with_db = <span class="keyword">false</span>;</div>
<div class="line"><a class="code" href="classDakota_1_1LibraryEnvironment.html">Dakota::LibraryEnvironment</a> env(opts, done_with_db, <a class="code" href="library__mode_8cpp.html#a584c4b9e2ff5e089877c03890b27581c">callback_function</a>, &amp;data);</div>
</div><!-- fragment --><p>Third, the example demonstrates changes to the database after parsing and callback-based updates. Again, these only need happen on Dakota's rank 0 before finalizing the DB with <a class="el" href="classDakota_1_1LibraryEnvironment.html#a26c47aaca1716ab30ce4b3f375e1d077" title="Check database contents, broadcast, and construct iterators.">LibraryEnvironment::done_modifying_db()</a>. The example demonstrates:</p>
<ol>
<li>
Getting access to the database through <code>env.problem_description_db()</code> </li>
<li>
Setting the database nodes to the appropriate method through <code>problem_db.resolve_top_method()</code> </li>
<li>
Getting data from the DB with a get string array function: <code>problem_db.get_sa</code>("interface.application.analysis_drivers") </li>
<li>
Setting update data with <code>problem_db.set</code>("variables.continuous_design.initial_point", ip); </li>
</ol>
<p>After any of these three types updates, calling <a class="el" href="classDakota_1_1LibraryEnvironment.html#a26c47aaca1716ab30ce4b3f375e1d077" title="Check database contents, broadcast, and construct iterators.">LibraryEnvironment::done_modifying_db()</a> will broadcast any updates (including potentially large vector data and post-process specification data to fill in any vector defaults that have not yet been provided through either file parsing or direct updates. (Note: scalar defaults are handled in the Data class constructors.)</p>
<p>Fourth and finally, <a class="el" href="library__mode_8cpp.html#af3af25d98f0d167fe810d7d97c487249" title="Run a Dakota LibraryEnvironment, from string or input file input, supplemented with additional C++ AP...">run_dakota_mixed()</a> demonstrates modifying a <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a>'s data after database operations and interface plugin are complete. This involves finding the right <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> (or other class) instance to modify, and directly adjusting its data through the public API. Since the database is finalized, any updates must be performed through direct set operations on the constructed objects. For example, to update other data such as variable values/bounds/tags or response bounds/targets/tags, refer to the set functions documented in <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> and <a class="el" href="classDakota_1_1Model.html">Model</a>. As an example, the following code updates the active continuous variable values, which will be employed as the initial guess for certain classes of Iterators:</p>
<div class="fragment"><div class="line">ModelList&amp; all_models  = problem_db.model_list();</div>
<div class="line">Model&amp;     first_model = *all_models.begin();</div>
<div class="line">Dakota::RealVector drv(1000, 1.); <span class="comment">// vector of length 1000, values initialized to 1.</span></div>
<div class="line">first_model.continuous_variables(drv);</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd></dd></dl>
<p>If performing such data updates within the constructor of a <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> extension/derivation (see <a class="el" href="DakLibrary.html#DakLibraryDirectAppInt">Creating a simulator plugin interface</a>), then this code is sufficient since the database is unlocked, the active list nodes of the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> have been set for you, and the correct method/model/variables/interface/responses specification instance will get updated. The difficulty in this case stems from the order of instantiation. Since the <a class="el" href="classDakota_1_1Variables.html" title="Base class for the variables class hierarchy.">Variables</a> and <a class="el" href="classDakota_1_1Response.html" title="Container class for response functions and their derivatives.   Response provides the enveloper base ...">Response</a> instances are constructed in the base <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> class, prior to construction of <a class="el" href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy.">Interface</a> instances in derived <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> classes, database information related to <a class="el" href="classDakota_1_1Variables.html" title="Base class for the variables class hierarchy.">Variables</a> and <a class="el" href="classDakota_1_1Response.html" title="Container class for response functions and their derivatives.   Response provides the enveloper base ...">Response</a> objects will have already been extracted by the time the <a class="el" href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy.">Interface</a> constructor is invoked and the database update will not propagate.</p>
<p>Therefore, it is preferred to perform these database set operations at a higher level (e.g., within your main program), prior to allowing <a class="el" href="classDakota_1_1Environment.html" title="Base class for the environment class hierarchy.">Environment</a> to broadcast, construct, and execute, such that instantiation order is not an issue. However, in this case, it is necessary to explicitly manage the list nodes of the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> using a specification instance identifier that corresponds to an identifier from the input file, e.g.:</p>
<div class="fragment"><div class="line">problem_db.set_db_variables_node(<span class="stringliteral">&quot;MY_VARIABLES_ID&quot;</span>);</div>
<div class="line">Dakota::RealVector drv(1000, 1.); <span class="comment">// vector of length 1000, values</span></div>
<div class="line">initialized to 1.</div>
<div class="line">problem_db.set(<span class="stringliteral">&quot;variables.continuous_design.initial_point&quot;</span>, drv);</div>
</div><!-- fragment --><p>Alternatively, rather than setting just a single data node, all data nodes may be set using a method specification identifier:</p>
<div class="fragment"><div class="line">problem_db.set_db_list_nodes(<span class="stringliteral">&quot;MY_METHOD_ID&quot;</span>); </div>
</div><!-- fragment --><p>since the method specification is responsible for identifying a model specification, which in turn identifies variables, interface, and responses specifications. If hard-wiring specification identifiers is undesirable, then</p>
<div class="fragment"><div class="line">problem_db.resolve_top_method(); </div>
</div><!-- fragment --><p>can also be used to deduce the active method specification and set all list nodes based on it. This is most appropriate in the case where only single specifications exist for method/model/variables/interface/responses. This is the approach demonstrated in <a class="el" href="library__mode_8cpp.html#af3af25d98f0d167fe810d7d97c487249" title="Run a Dakota LibraryEnvironment, from string or input file input, supplemented with additional C++ AP...">run_dakota_mixed()</a>. In each of these cases, setting list nodes unlocks the corresponding portions of the database, allowing set/get operations.</p>
<h1><a class="anchor" id="DakLibraryDirectAppInt"></a>
Creating a simulator plugin interface</h1>
<p>The <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> class provides an interface for Dakota to call the simulation code directly to perform function evaluations mapping variables to responses. This provides the "back end" for Dakota to call back to the simulation framework. Two approaches to defining this direct interface are described here. The first is less common, while the second is recommended when possible.</p>
<h2><a class="anchor" id="DakLibraryExtendDirectAppInt"></a>
Extension</h2>
<p>The first approach involves extending one of the existing <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> subclasses (<a class="el" href="classDakota_1_1TestDriverInterface.html">TestDriverInterface</a>, <a class="el" href="classDakota_1_1MatlabInterface.html">MatlabInterface</a>, etc.) to support additional direct simulation interfaces. For example, Dakota algebraic test problems are implemented in <a class="el" href="classDakota_1_1TestDriverInterface.html">TestDriverInterface</a>. One could add additional direct functions to Dakota in <a class="el" href="classDakota_1_1TestDriverInterface.html#a2538680bc763bb9c72bf4d6c8c63a976" title="execute an analysis code portion of a direct evaluation invocation">TestDriverInterface::derived_map_ac()</a>. In addition, <a class="el" href="classDakota_1_1DirectApplicInterface.html#a075b3f327d802ebea598132d7b4500d6" title="execute the input filter portion of a direct evaluation invocation">TestDriverInterface::derived_map_if()</a> and <a class="el" href="classDakota_1_1DirectApplicInterface.html#a325b29b720458740bddd4f66e9e49427" title="execute the output filter portion of a direct evaluation invocation">TestDriverInterface::derived_map_of()</a> can be extended to perform pre- and post-processing tasks if desired, but this is not required.</p>
<p>While this approach is the simplest, it has the disadvantage that the Dakota library will need to be recompiled when the simulation or its direct interface is modified. If it is desirable to maintain the independence of the Dakota library from the host application, then the derivation approach described in the next section should be employed.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the new direct evaluation function implementation will not be a member function of one of the Dakota classes, then the following prototype should be used in order to pass the required data: <div class="fragment"><div class="line"><span class="keywordtype">int</span> sim(<span class="keyword">const</span> <a class="code" href="classDakota_1_1Variables.html">Dakota::Variables</a>&amp; vars, <span class="keyword">const</span> <a class="code" href="classDakota_1_1ActiveSet.html">Dakota::ActiveSet</a>&amp; set,</div>
<div class="line"><a class="code" href="classDakota_1_1Response.html">Dakota::Response</a>&amp; response); </div>
</div><!-- fragment --> If the new function will be a member function, e.g., in <a class="el" href="classDakota_1_1TestDriverInterface.html">TestDriverInterface</a>, then this can be simplified to <div class="fragment"><div class="line"><span class="keywordtype">int</span> sim();</div>
</div><!-- fragment --> since the data access can be performed through the <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> class attributes.}</dd></dl>
<h2><a class="anchor" id="DakLibraryDeriveDirectAppInt"></a>
Derivation</h2>
<p>The second approach is to derive a new interface from <a class="el" href="classDakota_1_1DirectApplicInterface.html" title="Derived application interface class which spawns simulation codes and testers using direct procedure ...">DirectApplicInterface</a> and redefine several virtual functions. As demonstrated in <a class="el" href="classSIM_1_1SerialDirectApplicInterface.html" title="Sample derived interface class for testing serial simulator plug-ins using assign_rep().">SIM::SerialDirectApplicInterface</a> and <a class="el" href="classSIM_1_1ParallelDirectApplicInterface.html" title="Sample derived interface class for testing parallel simulator plug-ins using assign_rep().">SIM::ParallelDirectApplicInterface</a>, a typical derived class declaration might be</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceSIM.html">SIM</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SerialDirectApplicInterface: <span class="keyword">public</span> <a class="code" href="classDakota_1_1DirectApplicInterface.html">Dakota::DirectApplicInterface</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructor and destructor</span></div>
<div class="line"> </div>
<div class="line">  SerialDirectApplicInterface(<span class="keyword">const</span> <a class="code" href="classDakota_1_1ProblemDescDB.html">Dakota::ProblemDescDB</a>&amp; problem_db);</div>
<div class="line">  ~SerialDirectApplicInterface();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Virtual function redefinitions</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> derived_map_if(<span class="keyword">const</span> Dakota::String&amp; if_name);</div>
<div class="line">  <span class="keywordtype">int</span> derived_map_ac(<span class="keyword">const</span> Dakota::String&amp; ac_name);</div>
<div class="line">  <span class="keywordtype">int</span> derived_map_of(<span class="keyword">const</span> Dakota::String&amp; of_name);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Data</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace SIM</span></div>
</div><!-- fragment --><p>where the new derived class resides in the simulation's namespace. Similar to the case of <a class="el" href="DakLibrary.html#DakLibraryExtendDirectAppInt">Extension</a>, the <a class="el" href="classDakota_1_1DirectApplicInterface.html#a2538680bc763bb9c72bf4d6c8c63a976">DirectApplicInterface::derived_map_ac()</a> function is the required redefinition, and <a class="el" href="classDakota_1_1DirectApplicInterface.html#a075b3f327d802ebea598132d7b4500d6">DirectApplicInterface::derived_map_if()</a> and <a class="el" href="classDakota_1_1DirectApplicInterface.html#a325b29b720458740bddd4f66e9e49427">DirectApplicInterface::derived_map_of()</a> are optional.</p>
<p>Typically the new derived_map_ac() implementation delegates to the main simulation application for a function evaluation. Here Dakota variables would get mapped into the simulation's data structures, the simulation executed, and derived response data computed for return to Dakota.</p>
<p>Once a derived application class is created, it must be plugged in, or registered, with the appropriate <a class="el" href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy.">Interface</a> in the <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a>. In MPI cases where Dakota is potentially managing concurrent evaluations of the simulation, the plugin must be configured to run on the right MPI sub-communicator, or Dakota analysis_comm. The simpler case is demonstrated in <a class="el" href="library__mode_8cpp.html#a04d45e918d12ef2c28fcec7a7e8a5ae8" title="Convenience function with simplest example of interface plugin: plugin a serial DirectApplicInterface...">serial_interface_plugin()</a> in <a class="el" href="library__mode_8cpp.html" title="file containing a mock simulator main for testing Dakota in library mode">library_mode.cpp</a>, while a more advanced case using the analysis communicator is shown in <a class="el" href="library__mode_8cpp.html#a6229fa90be4b3daf46cbb5310a404054" title="Convenience function to plug a library client&#39;s interface into the appropriate model,...">parallel_interface_plugin()</a>. <br  />
</p>
<p>The Dakota <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a> provides a convenience function to plugin an <a class="el" href="classDakota_1_1Interface.html" title="Base class for the interface class hierarchy.">Interface</a>. This example will replace any interface found matching the given model, interface, and analysis driver with the passed plugin interface:</p>
<div class="fragment"><div class="line">std::string model_type(<span class="stringliteral">&quot;&quot;</span>); <span class="comment">// demo: empty string will match any model type</span></div>
<div class="line">std::string interf_type(<span class="stringliteral">&quot;direct&quot;</span>);</div>
<div class="line">std::string an_driver(<span class="stringliteral">&quot;plugin_rosenbrock&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDakota_1_1ProblemDescDB.html">Dakota::ProblemDescDB</a>&amp; problem_db = env.problem_description_db();</div>
<div class="line">std::shared_ptr&lt;Dakota::Interface&gt; serial_iface = </div>
<div class="line">  std::make_shared&lt;SIM::SerialDirectApplicInterface&gt;(problem_db);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> plugged_in =</div>
<div class="line">  env.plugin_interface(model_type, interf_type, an_driver, serial_iface);</div>
</div><!-- fragment --><p>The <a class="el" href="classDakota_1_1LibraryEnvironment.html" title="Environment corresponding to execution as an embedded library.">LibraryEnvironment</a> also provides convenience functions that allow the client to iterate the lists of available interfaces or models for more advanced cases. For instance if the client knows there is only a single interface active, it could get the list of available interfaces of length 1 and plugin to the first one. In the more advanced case where the simulation interface instance should manage parallel simulations within the context of an MPI communicator, one should pass in the relevant analysis communicator(s) to the derived constructor. For the latter case of looping over a set of models, the simplest approach of passing a single analysis communicator would use code similar to</p>
<div class="fragment"><div class="line">Dakota::ModelList filt_models = </div>
<div class="line">  env.filtered_model_list(<span class="stringliteral">&quot;single&quot;</span>, <span class="stringliteral">&quot;direct&quot;</span>, <span class="stringliteral">&quot;plugin_text_book&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDakota_1_1ProblemDescDB.html">Dakota::ProblemDescDB</a>&amp; problem_db = env.problem_description_db();</div>
<div class="line">Dakota::ModelLIter ml_iter;</div>
<div class="line"><span class="keywordflow">for</span> (ml_iter = filt_models.begin(); ml_iter != filt_models.end(); ++ml_iter) {</div>
<div class="line">  <span class="comment">// set DB nodes to input specification for this Model</span></div>
<div class="line">  problem_db.<a class="code" href="classDakota_1_1ProblemDescDB.html#af9676f88ff2191bfc4a86371f3640b8b">set_db_model_nodes</a>(ml_iter-&gt;model_id());</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDakota_1_1Interface.html">Dakota::Interface</a>&amp; model_interface = ml_iter-&gt;derived_interface();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Parallel case: plug in derived Interface object with an analysisComm.</span></div>
<div class="line">  <span class="comment">// Note: retrieval and passing of analysisComm is necessary only if</span></div>
<div class="line">  <span class="comment">// parallel operations will be performed in the derived constructor.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// retrieve the currently active analysisComm from the Model.  In the most</span></div>
<div class="line">  <span class="comment">// general case, need an array of Comms to cover all Model configurations.</span></div>
<div class="line">  <span class="keyword">const</span> MPI_Comm&amp; analysis_comm = ml_iter-&gt;analysis_comm();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// don&#39;t increment ref count since no other envelope shares this letter</span></div>
<div class="line">  model_interface.<a class="code" href="classDakota_1_1Interface.html#a5b0445f1d566f8702d70ef7386047e2e">assign_rep</a>(<span class="keyword">new</span></div>
<div class="line">    <a class="code" href="classSIM_1_1ParallelDirectApplicInterface.html">SIM::ParallelDirectApplicInterface</a>(problem_db, analysis_comm), <span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The file <a class="el" href="library__mode_8cpp.html" title="file containing a mock simulator main for testing Dakota in library mode">library_mode.cpp</a> demonstrates each of these approaches. Since a <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> may be used in multiple parallel contexts and may therefore have a set of parallel configurations, a more general approach would extract and pass an array of analysis communicators to allow initialization for each of the parallel configurations.</p>
<p>New derived direct interface instances inherit various attributes of use in configuring the simulation. In particular, the <a class="el" href="classDakota_1_1ApplicationInterface.html#a702abf9be22e51f1e67167d5db1b08d3" title="reference to the ParallelLibrary object used to manage MPI partitions for the concurrent evaluations ...">ApplicationInterface::parallelLib</a> reference provides access to MPI communicator data (e.g., the analysis communicators discussed above), <a class="el" href="classDakota_1_1DirectApplicInterface.html#a90215b56161bf6f5953c6a28d6962541" title="the set of analyses within each function evaluation (from the analysis_drivers interface specificatio...">DirectApplicInterface::analysisDrivers</a> provides the analysis driver names specified by the user in the input file, and <a class="el" href="classDakota_1_1Interface.html#affca708fb244c540cf2b34d00aae31ad" title="Analysis components for interface types that support them.">DirectApplicInterface::analysisComponents</a> provides additional analysis component identifiers (such as mesh file names) provided by the user which can be used to distinguish different instances of the same simulation interface. It is worth noting that inherited attributes that are set as part of the parallel configuration (instead of being extracted from the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a>) will be set to their defaults following construction of the base class instance for the derived class plug-in. It is not until run-time (i.e., within derived_map_if/derived_map_ac/derived_map_of) that the parallel configuration settings are re-propagated to the plug-in instance. This is the reason that the analysis communicator should be passed in to the constructor of a parallel plug-in, if the constructor will be responsible for parallel application initialization.</p>
<h1><a class="anchor" id="DakLibraryPostRun"></a>
Retrieving data after a run</h1>
<p>After executing the Dakota <a class="el" href="classDakota_1_1Environment.html" title="Base class for the environment class hierarchy.">Environment</a>, final results can be obtained through the use of <a class="el" href="classDakota_1_1Environment.html#a7881a127da96fcb28d54ec19ff97f859">Environment::variables_results()</a> and <a class="el" href="classDakota_1_1Environment.html#a8a50ef40ad7433582083419a5e2454b3">Environment::response_results()</a>, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// retrieve the final parameter values</span></div>
<div class="line"><span class="keyword">const</span> Variables&amp; vars = env.variables_results();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// retrieve the final response values</span></div>
<div class="line"><span class="keyword">const</span> Response&amp; resp  = env.response_results();</div>
</div><!-- fragment --><p>In the case of optimization, the final design is returned, and in the case of uncertainty quantification, the final statistics are returned. Dakota has a prototype results database, which will eventually provide better access to the results from a study.</p>
<h1><a class="anchor" id="DakLibraryLinking"></a>
Linking against the Dakota library</h1>
<p>This section presumes Dakota has been configured with CMake, compiled, and installed to a <code>CMAKE_INSTALL_PREFIX</code> using <code>make</code> <code>install</code> or equivalent. The Dakota libraries against which you must link will typically install to <code>CMAKE_INSTALL_PREFIX/bin/</code> and <code>CMAKE_INSTALL_PREFIX/lib/</code>, while headers are provided in <code>CMAKE_INSTALL_PREFIX/lib/</code>. The core Dakota C and C++ code is in the library <code>dakota_src</code>, while Fortran code lives in the <code>dakota_src_fortran</code> library. Runtime libraries for any configure-enabled Dakota third-party software components (such as DOT, NPSOL, OPT++, LHS, etc.) are also installed to the lib/ directory. Applications link against these Dakota libraries by specifying appropriate include and link directives.</p>
<p>There two primary ways to determine the necessary Dakota-related libraries and link order for linking your application. First, when running CMake, a list of required Dakota and Dakota-included third-party libraries will be output to the console, e.g.,</p>
<pre class="fragment">-- Dakota_LIBRARIES: dakota_src;dakota_src_fortran;nidr;teuchos;pecos;pecos_src;lhs;mods;mod;dfftpack;sparsegrid;surfpack;surfpack;surfpack_fortran;utilib;colin;interfaces;scolib;3po;pebbl;tinyxml;conmin;dace;analyzer;random;sampling;bose;dot;fsudace;hopspack;jega;jega_fe;moga;soga;eutils;utilities;ncsuopt;nlpql;cport;nomad;npsol;optpp;psuade;dakota_sciplot;amplsolver
</pre><p>While external dependencies will be output as:</p>
<pre class="fragment">-- Dakota_TPL_LIBRARIES: /usr/lib64/libcurl.so;/usr/lib64/openmpi/lib/libmpi_cxx.so;debug;/usr/lib64/libz.so;debug;/usr/lib64/librt.so;debug;/usr/lib64/libdl.so;debug;/usr/lib64/libm.so;debug;/apps/hdf5/1.8.11/lib/libhdf5_hl.so;debug;/apps/hdf5/1.8.11/lib/libhdf5.so;optimized;/usr/lib64/libz.so;optimized;/usr/lib64/librt.so;optimized;/usr/lib64/libdl.so;optimized;/usr/lib64/libm.so;optimized;/apps/hdf5/1.8.11/lib/libhdf5_hl.so;optimized;/apps/hdf5/1.8.11/lib/libhdf5.so;/apps/boost/1.49/lib/libboost_regex.so;/apps/boost/1.49/lib/libboost_filesystem.so;/apps/boost/1.49/lib/libboost_serialization.so;/apps/boost/1.49/lib/libboost_system.so;/apps/boost/1.49/lib/libboost_signals.so;/usr/lib64/libSM.so;/usr/lib64/libICE.so;/usr/lib64/libX11.so;/usr/lib64/libXext.so;/usr/lib64/libXm.so;/usr/lib64/libXpm.so;/usr/lib64/libXmu.so;/usr/lib64/libXt.so;-lpthread;/usr/lib64/liblapack.so;/usr/lib64/libblas.so
</pre><p>Note that depending on how you configured Dakota, some libraries may be omitted from these lists (for example commercial add-ons NPSOL, DOT, and NLPQL), or additional libraries may appear.</p>
<p>A second option is to check which libraries appear in <code>CMAKE_INSTALL_PREFIX/bin/</code> <code>CMAKE_INSTALL_PREFIX/lib/</code>, or more accurately, see the file Makefile.export.Dakota in the Dakota build/src/ or installation include/ directory. Here are some additional notes on specific libraries:</p>
<ul>
<li>
<p class="startli">Some Boost libraries (<code>boost_regex</code>, <code>boost_filesystem</code>, <code>boost_system</code>, <code>boost_serialization</code>) are required, and other Boost library components may be required depending on configuration, e.g., <code>boost_signals</code> when configuring with <code>HAVE_ACRO:BOOL=TRUE</code> </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">System compiler and math libraries may need to be included, as may additional system libraries such as Expat and Curl, depending on how Dakota is configured.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If configuring with graphics, you will need to add the <code>dakota_sciplot</code> library and system X libraries (partial list here): </p><div class="fragment"><div class="line">-lXpm -lXm -lXt -lXmu -lXp -lXext -lX11 -lSM -lICE</div>
</div><!-- fragment --> <p class="endli"></p>
</li>
<li>
<p class="startli">When configuring with AMPL (<code>HAVE_AMPL:BOOL=ON</code>), the AMPL solver library may require <code>dl</code>, <code>funcadd0.o</code> and <code>fl</code> libraries. We have experienced problems with the creation of <code>libamplsolver.a</code> on some platforms; use the dakota-users mailing list to get help with any problems related to this. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Optional library GSL (discouraged due to GPL license) and if linking with system-provided GSL, <code>gslcblas</code> may be needed if Dakota was configured with them. </p>
<p class="endli"></p>
</li>
<li>
Newmat: as of Dakota 5.2, <code>-lnewmat</code> is no longer required  </li>
</ul>
<p>Finally, it is important to use the same C++ compiler (possibly an MPI wrapper) for compiling Dakota and your application and potentially include Dakota-related preprocessor defines as emitted by CMake during compilation of Dakota and included in Makefile.export.Dakota. This ensures that the platform configuration settings are properly synchronized across Dakota and your application. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassDakota_1_1DataMethodRep_html_a232e81b24a57f058b946705f9885a44a"><div class="ttname"><a href="classDakota_1_1DataMethodRep.html#a232e81b24a57f058b946705f9885a44a">Dakota::DataMethodRep::methodName</a></div><div class="ttdeci">unsigned short methodName</div><div class="ttdoc">the method selection: one of the optimizer, least squares, nond, dace, or parameter study methods</div><div class="ttdef"><b>Definition:</b> DataMethod.hpp:364</div></div>
<div class="ttc" id="alibrary__mode_8cpp_html_a94440f841119f76e8318598a8b16ec59"><div class="ttname"><a href="library__mode_8cpp.html#a94440f841119f76e8318598a8b16ec59">serial_input</a></div><div class="ttdeci">static const char serial_input[]</div><div class="ttdoc">Default Dakota input string for serial case (rosenbrock):</div><div class="ttdef"><b>Definition:</b> library_mode.cpp:151</div></div>
<div class="ttc" id="aclassDakota_1_1ProgramOptions_html"><div class="ttname"><a href="classDakota_1_1ProgramOptions.html">Dakota::ProgramOptions</a></div><div class="ttdoc">ProgramOptions stores options whether from the CLH or from library user; initially valid only on worl...</div><div class="ttdef"><b>Definition:</b> ProgramOptions.hpp:31</div></div>
<div class="ttc" id="aclassDakota_1_1ActiveSet_html"><div class="ttname"><a href="classDakota_1_1ActiveSet.html">Dakota::ActiveSet</a></div><div class="ttdoc">Container class for active set tracking information. Contains the active set request vector and the d...</div><div class="ttdef"><b>Definition:</b> DakotaActiveSet.hpp:31</div></div>
<div class="ttc" id="aclassDakota_1_1ProblemDescDB_html_a968e1e94818e3172dda7b074ae197d04"><div class="ttname"><a href="classDakota_1_1ProblemDescDB.html#a968e1e94818e3172dda7b074ae197d04">Dakota::ProblemDescDB::set_db_list_nodes</a></div><div class="ttdeci">void set_db_list_nodes(const String &amp;method_tag)</div><div class="ttdoc">set dataMethodIter based on a method identifier string to activate a particular method specification ...</div><div class="ttdef"><b>Definition:</b> ProblemDescDB.cpp:434</div></div>
<div class="ttc" id="aclassDakota_1_1Interface_html_a5b0445f1d566f8702d70ef7386047e2e"><div class="ttname"><a href="classDakota_1_1Interface.html#a5b0445f1d566f8702d70ef7386047e2e">Dakota::Interface::assign_rep</a></div><div class="ttdeci">void assign_rep(std::shared_ptr&lt; Interface &gt; interface_rep)</div><div class="ttdoc">assign letter or replace existing letter with a new one</div><div class="ttdef"><b>Definition:</b> DakotaInterface.cpp:370</div></div>
<div class="ttc" id="aclassSIM_1_1ParallelDirectApplicInterface_html"><div class="ttname"><a href="classSIM_1_1ParallelDirectApplicInterface.html">SIM::ParallelDirectApplicInterface</a></div><div class="ttdoc">Sample derived interface class for testing parallel simulator plug-ins using assign_rep().</div><div class="ttdef"><b>Definition:</b> PluginParallelDirectApplicInterface.hpp:32</div></div>
<div class="ttc" id="aclassDakota_1_1ProblemDescDB_html_a6bad9de623ab35d65dab9bdbbb8db576"><div class="ttname"><a href="classDakota_1_1ProblemDescDB.html#a6bad9de623ab35d65dab9bdbbb8db576">Dakota::ProblemDescDB::set_db_variables_node</a></div><div class="ttdeci">void set_db_variables_node(const String &amp;variables_tag)</div><div class="ttdoc">set dataVariablesIter based on the variables identifier string</div><div class="ttdef"><b>Definition:</b> ProblemDescDB.cpp:721</div></div>
<div class="ttc" id="aclassDakota_1_1ProblemDescDB_html_a0de5f71a2406cc52d69deebbbc997403"><div class="ttname"><a href="classDakota_1_1ProblemDescDB.html#a0de5f71a2406cc52d69deebbbc997403">Dakota::ProblemDescDB::resolve_top_method</a></div><div class="ttdeci">void resolve_top_method(bool set_model_nodes=true)</div><div class="ttdoc">For a (default) environment lacking a top method pointer, this function is used to determine which of...</div><div class="ttdef"><b>Definition:</b> ProblemDescDB.cpp:475</div></div>
<div class="ttc" id="aclassDakota_1_1LibraryEnvironment_html"><div class="ttname"><a href="classDakota_1_1LibraryEnvironment.html">Dakota::LibraryEnvironment</a></div><div class="ttdoc">Environment corresponding to execution as an embedded library.</div><div class="ttdef"><b>Definition:</b> LibraryEnvironment.hpp:26</div></div>
<div class="ttc" id="aclassDakota_1_1DataMethod_html_a0ad70dff99eca73a6a7a07208e2700e8"><div class="ttname"><a href="classDakota_1_1DataMethod.html#a0ad70dff99eca73a6a7a07208e2700e8">Dakota::DataMethod::data_rep</a></div><div class="ttdeci">std::shared_ptr&lt; DataMethodRep &gt; data_rep()</div><div class="ttdoc">return dataMethodRep</div><div class="ttdef"><b>Definition:</b> DataMethod.hpp:1533</div></div>
<div class="ttc" id="anamespaceSIM_html"><div class="ttname"><a href="namespaceSIM.html">SIM</a></div><div class="ttdoc">A sample namespace for derived classes that use assign_rep() to plug facilities into DAKOTA.</div><div class="ttdef"><b>Definition:</b> PluginParallelDirectApplicInterface.cpp:19</div></div>
<div class="ttc" id="aclassDakota_1_1Interface_html"><div class="ttname"><a href="classDakota_1_1Interface.html">Dakota::Interface</a></div><div class="ttdoc">Base class for the interface class hierarchy.</div><div class="ttdef"><b>Definition:</b> DakotaInterface.hpp:50</div></div>
<div class="ttc" id="aclassDakota_1_1ProgramOptions_html_ad499a7fca9139f53caf869f473717134"><div class="ttname"><a href="classDakota_1_1ProgramOptions.html#ad499a7fca9139f53caf869f473717134">Dakota::ProgramOptions::input_file</a></div><div class="ttdeci">const String &amp; input_file() const</div><div class="ttdoc">Dakota input file base name (no tag)</div><div class="ttdef"><b>Definition:</b> ProgramOptions.cpp:112</div></div>
<div class="ttc" id="aclassDakota_1_1ProgramOptions_html_aefbf151a40d8ba59da2858906c49c934"><div class="ttname"><a href="classDakota_1_1ProgramOptions.html#aefbf151a40d8ba59da2858906c49c934">Dakota::ProgramOptions::input_string</a></div><div class="ttdeci">const String &amp; input_string() const</div><div class="ttdoc">alternate Dakota input string literal; also set when input is read from stdin</div><div class="ttdef"><b>Definition:</b> ProgramOptions.cpp:115</div></div>
<div class="ttc" id="aclassDakota_1_1DataMethod_html"><div class="ttname"><a href="classDakota_1_1DataMethod.html">Dakota::DataMethod</a></div><div class="ttdoc">Handle class for method specification data.</div><div class="ttdef"><b>Definition:</b> DataMethod.hpp:1481</div></div>
<div class="ttc" id="aclassDakota_1_1Response_html"><div class="ttname"><a href="classDakota_1_1Response.html">Dakota::Response</a></div><div class="ttdoc">Container class for response functions and their derivatives.   Response provides the enveloper base ...</div><div class="ttdef"><b>Definition:</b> DakotaResponse.hpp:44</div></div>
<div class="ttc" id="aclassDakota_1_1ProblemDescDB_html"><div class="ttname"><a href="classDakota_1_1ProblemDescDB.html">Dakota::ProblemDescDB</a></div><div class="ttdoc">The database containing information parsed from the DAKOTA input file.</div><div class="ttdef"><b>Definition:</b> ProblemDescDB.hpp:44</div></div>
<div class="ttc" id="aclassDakota_1_1ProblemDescDB_html_ae418cd2e6e5221d0589e0fb4ea39f9b3"><div class="ttname"><a href="classDakota_1_1ProblemDescDB.html#ae418cd2e6e5221d0589e0fb4ea39f9b3">Dakota::ProblemDescDB::set</a></div><div class="ttdeci">void set(const String &amp;entry_name, const RealVector &amp;rv)</div><div class="ttdoc">set a RealVector within the database based on an identifier string</div><div class="ttdef"><b>Definition:</b> ProblemDescDB.cpp:2807</div></div>
<div class="ttc" id="aclassDakota_1_1DirectApplicInterface_html"><div class="ttname"><a href="classDakota_1_1DirectApplicInterface.html">Dakota::DirectApplicInterface</a></div><div class="ttdoc">Derived application interface class which spawns simulation codes and testers using direct procedure ...</div><div class="ttdef"><b>Definition:</b> DirectApplicInterface.hpp:73</div></div>
<div class="ttc" id="aclassDakota_1_1ProblemDescDB_html_a9243b13775271ddac52f4ef39bbd5586"><div class="ttname"><a href="classDakota_1_1ProblemDescDB.html#a9243b13775271ddac52f4ef39bbd5586">Dakota::ProblemDescDB::model_list</a></div><div class="ttdeci">ModelList &amp; model_list()</div><div class="ttdoc">return a list of all Model objects that have been instantiated</div><div class="ttdef"><b>Definition:</b> ProblemDescDB.hpp:553</div></div>
<div class="ttc" id="aclassDakota_1_1DataMethodRep_html"><div class="ttname"><a href="classDakota_1_1DataMethodRep.html">Dakota::DataMethodRep</a></div><div class="ttdoc">Body class for method specification data.</div><div class="ttdef"><b>Definition:</b> DataMethod.hpp:290</div></div>
<div class="ttc" id="aclassDakota_1_1Variables_html"><div class="ttname"><a href="classDakota_1_1Variables.html">Dakota::Variables</a></div><div class="ttdoc">Base class for the variables class hierarchy.</div><div class="ttdef"><b>Definition:</b> DakotaVariables.hpp:108</div></div>
<div class="ttc" id="aclassDakota_1_1ProblemDescDB_html_af9676f88ff2191bfc4a86371f3640b8b"><div class="ttname"><a href="classDakota_1_1ProblemDescDB.html#af9676f88ff2191bfc4a86371f3640b8b">Dakota::ProblemDescDB::set_db_model_nodes</a></div><div class="ttdeci">void set_db_model_nodes(const String &amp;model_tag)</div><div class="ttdoc">set the model list iterators (dataModelIter, dataVariablesIter, dataInterfaceIter,...</div><div class="ttdef"><b>Definition:</b> ProblemDescDB.cpp:647</div></div>
<div class="ttc" id="alibrary__mode_8cpp_html_a584c4b9e2ff5e089877c03890b27581c"><div class="ttname"><a href="library__mode_8cpp.html#a584c4b9e2ff5e089877c03890b27581c">callback_function</a></div><div class="ttdeci">static void callback_function(Dakota::ProblemDescDB *db, void *ptr)</div><div class="ttdoc">Example: user-provided post-parse callback (Dakota::DbCallbackFunction)</div><div class="ttdef"><b>Definition:</b> library_mode.cpp:453</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
