<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Dakota Developers Manual" />
<meta name="keywords" content="optimization, uncertainty quantification, model calibration, parameter estimation, sensitivity analysis, parallel computing, developers manual" />
<meta name="sandia.approval_type" content="formal" />
<meta name="sandia.approved" content="2010-2185" />
<link rev="owns" title="Brian M. Adams" href="mailto:briadam@sandia.gov" />
<meta name="Author" content="Brian M. Adams" />
<title>Dakota: Dakota Developers Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DAKOTA_Arrow_Name_77x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dakota
   &#160;<span id="projectnumber">Version 6.20</span>
   </div>
   <div id="projectbrief">Explore and Predict with Confidence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> Developers Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Brian M. Adams, William J. Bohnhoff, Robert A. Canfield, Wesley P. Coomber, Keith R. Dalbey, Mohamed S. Ebeida, John P. Eddy, Michael S. Eldred, Gianluca Geraci, Russell W. Hooper, Patricia D. Hough, Kenneth T. Hu, John D. Jakeman, Carson Kent, Mohammad Khalil, Kathryn A. Maupin, Jason A. Monschke, Teresa Portone, Ernesto E. Prudencio, Elliott M. Ridgway, Ahmad A. Rushdi, D. Thomas Seidl, J. Adam Stephens, Laura P. Swiler, Anh Tran, Dena M. Vigil, Gregory J. von Winckel, Timothy M. Wildey, and Justin G. Winokur; with Friedrich Menhorn and Xiaoshu Zeng</dd></dl>
<p> 
<b>Main Page Table of Contents</b>
<ul>
<li> <a href="index.html#DevIntro">Introduction</a> 
<li> <a href="index.html#DevOverview">Overview of Dakota</a> 
  <ul>
  <li> <a href="index.html#DevEnvironment">Environment</a>
  <li> <a href="index.html#DevIterators">Iterators</a>
  <li> <a href="index.html#DevModels">Models</a>
  <li> <a href="index.html#DevVariables">Variables</a>
  <li> <a href="index.html#DevInterfaces">Interfaces</a>
  <li> <a href="index.html#DevResponses">Responses</a>
  </ul>
<li> <a href="index.html#DevServices">Services</a>
<li> <a href="index.html#DevGuidance">Development Practices and Guidance</a>
<li> <a href="index.html#DevAddtnl">Additional Resources</a>
</ul>
</p>
<h1><a class="anchor" id="DevIntro"></a>
Introduction</h1>
<p>The Dakota software (<a href="http://dakota.sandia.gov/">http://dakota.sandia.gov/</a>) delivers advanced parametric analysis techniques enabling quantification of margins and uncertainty, risk analysis, model calibration, and design exploration with computational models. Dakota contains algorithms for optimization with gradient and nongradient-based methods, uncertainty quantification with sampling, reliability, stochastic expansion, and interval estimation methods, parameter estimation with nonlinear least squares methods, and sensitivity/variance analysis with design of experiments and parameter study capabilities. (Solution verification and Bayesian approaches are also in development.) These capabilities may be used on their own or as components within advanced algorithms such as surrogate-based optimization, mixed integer nonlinear programming, mixed aleatory-epistemic uncertainty quantification, or optimization under uncertainty. By employing object-oriented design to implement abstractions of the key components required for iterative systems analyses, the Dakota toolkit provides a flexible problem-solving environment for design and performance analysis of computational models on high performance computers.</p>
<p>The Developers Manual focuses on documentation of Dakota design principles and class structures; it derives principally from annotated source code. For information on Dakota input command syntax or features and capabilities, refer to the Users Manual at <a href="https://snl-github.io">https://snl-github.io</a>.</p>
<h1><a class="anchor" id="DevOverview"></a>
Overview of Dakota</h1>
<p>In Dakota, the <em>environment</em> manages execution modes and input/output streams and defines the top-level iterator. This top-level iterator may be either a standard iterator or a meta-iterator. In the former case, the iterator identifies a model and the environment executes the iterator on the model to perform a single study. In the latter case, iterator recursions are present and sub-iterators may identify their own models. In both cases, models may contain additional recursions in the case of nested iteration or surrogate modeling. In a simple example, a hybrid meta-iterator might manage a global optimizer operating on a low-fidelity model that feeds promising design points into a local optimizer operating on a high-fidelity model. And in a more advanced example, a surrogate-based optimization under uncertainty approach would employ an uncertainty quantification iterator nested within an optimization iterator and would employ truth models contained within surrogate models. Thus, iterators and models provide both stand-alone capabilities as well as building blocks for more sophisticated studies.</p>
<p>A model contains a set of <em>variables</em>, an <em>interface</em>, and a set of <em>responses</em>, and the iterator operates on the model to map the variables into responses using the interface. Each of these components is a flexible abstraction with a variety of specializations for supporting different types of iterative studies. In a Dakota input file, the user specifies these components through environment, method, model, variables, interface, and responses keyword specifications.</p>
<p>The use of class hierarchies provides a mechanism for extensibility in Dakota components. In each of the various class hierarchies, adding a new capability typically involves deriving a new class and providing a set of virtual function redefinitions. These redefinitions define the coding portions specific to the new derived class, with the common portions already defined at the base class. Thus, with a small amount of new code, the existing facilities can be extended, reused, and leveraged for new purposes. The following sections tour Dakota's class organization.</p>
<h2><a class="anchor" id="DevEnvironment"></a>
Environment</h2>
<p>Class hierarchy: <a class="el" href="classDakota_1_1Environment.html">Environment</a>.</p>
<p>Environments provide the top level abstraction for managing different execution modes and managing input and output streams. Specific environments include:</p>
<ul>
<li>
<p class="startli"><a class="el" href="classDakota_1_1ExecutableEnvironment.html">ExecutableEnvironment</a>: the environment for execution of Dakota as a stand-alone application.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classDakota_1_1LibraryEnvironment.html">LibraryEnvironment</a>: the environment for execution of Dakota as an embedded library service. </li>
</ul>
<h2><a class="anchor" id="DevIterators"></a>
Iterators</h2>
<p>Class hierarchy: <a class="el" href="classDakota_1_1Iterator.html">Iterator</a>. <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> implementations may choose to split operations up into run-time phases as described in <a class="el" href="IteratorFlow.html">Understanding Iterator Flow</a>.</p>
<p>The iterator hierarchy contains a variety of iterative algorithms for optimization, uncertainty quantification, nonlinear least squares, design of experiments, and parameter studies. The hierarchy is divided into <a class="el" href="classDakota_1_1MetaIterator.html">MetaIterator</a>, <a class="el" href="classDakota_1_1Minimizer.html">Minimizer</a>, and <a class="el" href="classDakota_1_1Analyzer.html">Analyzer</a> branches. <br  />
</p>
<p>The <a class="el" href="classDakota_1_1MetaIterator.html">MetaIterator</a> classes manage sequencing and collaboration among multiple methods with support for concurrent iterator parallelism. Methods include:</p>
<ul>
<li>
<p class="startli"><a class="el" href="classDakota_1_1SeqHybridMetaIterator.html">SeqHybridMetaIterator</a>: hybrid minimization using a set of iterators employing a corresponding set of models of varying fidelity. The sequential hybrid passes the best solutions from one method in as the starting points of the next method in the sequence.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classDakota_1_1CollabHybridMetaIterator.html">CollabHybridMetaIterator</a>: hybrid minimization employing collaboration and sharing of response data among methods during the course if iteration. This class is currently a placeholder.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classDakota_1_1EmbedHybridMetaIterator.html">EmbedHybridMetaIterator</a>: hybrid minimization involving periodic use of a local search method for refinement during the iteration of an outer global method. This class is currently a placeholder.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classDakota_1_1ConcurrentMetaIterator.html">ConcurrentMetaIterator</a>: two similar algorithms are available: (1) multi-start iteration from several different starting points, and (2) pareto set optimization for several different multi-objective weightings. Employs a single iterator with a single model, but runs multiple instances of the iterator concurrently for different settings within the model. </li>
</ul>
<p>The <a class="el" href="classDakota_1_1Minimizer.html">Minimizer</a> classes address optimization and deterministic calibration and are grouped into:</p>
<ul>
<li>
<p class="startli">Optimization: <a class="el" href="classDakota_1_1Optimizer.html">Optimizer</a> provides a base class for gradient-based (e.g., <a class="el" href="classDakota_1_1CONMINOptimizer.html">CONMINOptimizer</a> and <a class="el" href="classDakota_1_1SNLLOptimizer.html">SNLLOptimizer</a>) and derivative-free (e.g., <a class="el" href="classDakota_1_1NCSUOptimizer.html">NCSUOptimizer</a>, <a class="el" href="classDakota_1_1JEGAOptimizer.html">JEGAOptimizer</a>) optimization solvers. Most of these are wrappers for third-party libraries that implement the optimization algorithms. Classes <a class="el" href="classDakota_1_1APPSEvalMgr.html">APPSEvalMgr</a> and <a class="el" href="classDakota_1_1COLINApplication.html">COLINApplication</a> provide the function evaluation interface for <a class="el" href="classDakota_1_1APPSOptimizer.html">APPSOptimizer</a> and <a class="el" href="classDakota_1_1COLINOptimizer.html">COLINOptimizer</a>, respectively.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Parameter estimation: <a class="el" href="classDakota_1_1LeastSq.html">LeastSq</a> provides a base class for <a class="el" href="classDakota_1_1NL2SOLLeastSq.html">NL2SOLLeastSq</a>, a least-squares solver based on NL2SOL, <a class="el" href="classDakota_1_1SNLLLeastSq.html">SNLLLeastSq</a>, a Gauss-Newton least-squares solver, and <a class="el" href="classDakota_1_1NLSSOLLeastSq.html">NLSSOLLeastSq</a>, an SQP-based least-squares solver.</p>
<p class="endli"></p>
</li>
<li>
Surrogate-based minimization (both optimization and nonlinear least squares): <a class="el" href="classDakota_1_1SurrBasedMinimizer.html">SurrBasedMinimizer</a> provides a base class for <a class="el" href="classDakota_1_1SurrBasedLocalMinimizer.html">SurrBasedLocalMinimizer</a>, <a class="el" href="classDakota_1_1SurrBasedGlobalMinimizer.html">SurrBasedGlobalMinimizer</a>, and <a class="el" href="classDakota_1_1EffGlobalMinimizer.html">EffGlobalMinimizer</a>. The surrogate-based local and global methods employ a single iterator with any of the available <a class="el" href="classDakota_1_1SurrogateModel.html">SurrogateModel</a> capabilities (local, multipoint, or global data fits or hierarchical approximations) and perform a sequence of approximate optimizations, each involving build, optimize, and verify steps. The efficient global method, on the other hand, hard-wires a recursion involving Gaussian process surrogate models coupled with the DIRECT global optimizer to maximize an expected improvement function. </li>
</ul>
<p>The <a class="el" href="classDakota_1_1Analyzer.html">Analyzer</a> classes are grouped into: </p><ul>
<li>
<p class="startli">Uncertainty quantification: <a class="el" href="classDakota_1_1NonD.html">NonD</a> provides a base class for non-deterministic methods in several categories:</p>
<ul>
<li>
<p class="startli">Sampling: <a class="el" href="classDakota_1_1NonDSampling.html">NonDSampling</a> is further specialized with the <a class="el" href="classDakota_1_1NonDLHSSampling.html">NonDLHSSampling</a> class for Latin hypercube and Monte Carlo sampling, and a number of other classes supporting incremental and adaptive sampling such as <a class="el" href="classDakota_1_1NonDAdaptImpSampling.html">NonDAdaptImpSampling</a> for multi-modal adaptive importance sampling.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Reliability Analysis: <a class="el" href="classDakota_1_1NonDReliability.html">NonDReliability</a> is further specialized with local and global methods (<a class="el" href="classDakota_1_1NonDLocalReliability.html">NonDLocalReliability</a> and <a class="el" href="classDakota_1_1NonDGlobalReliability.html">NonDGlobalReliability</a>). <a class="el" href="classDakota_1_1NonDPOFDarts.html">NonDPOFDarts</a> implements a computational geometry-based reliability method.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Stochastic Expansions: <a class="el" href="classDakota_1_1NonDExpansion.html">NonDExpansion</a> includes specializations for generalized polynomial chaos (<a class="el" href="classDakota_1_1NonDPolynomialChaos.html">NonDPolynomialChaos</a>) and stochastic collocation (<a class="el" href="classDakota_1_1NonDStochCollocation.html">NonDStochCollocation</a>) and is supported by the <a class="el" href="classDakota_1_1NonDIntegration.html">NonDIntegration</a> helper class, which supplies cubature, tensor-product quadrature and Smolyak sparse grid methods (<a class="el" href="classDakota_1_1NonDCubature.html">NonDCubature</a>, <a class="el" href="classDakota_1_1NonDQuadrature.html">NonDQuadrature</a>, and <a class="el" href="classDakota_1_1NonDSparseGrid.html">NonDSparseGrid</a>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Bayesian Calibration: <a class="el" href="classDakota_1_1NonDCalibration.html">NonDCalibration</a> provides a base class for nondeterministic calibration methods with specialization to Bayesian calibration in <a class="el" href="classDakota_1_1NonDBayesCalibration.html">NonDBayesCalibration</a>, and specific implementations such as <a class="el" href="classDakota_1_1NonDQUESOBayesCalibration.html">NonDQUESOBayesCalibration</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classDakota_1_1NonDInterval.html">NonDInterval</a> provides a base class for epistemic interval-based UQ methods. Three interval analysis approaches are provided: LHS (<a class="el" href="classDakota_1_1NonDLHSInterval.html">NonDLHSInterval</a>), efficient global optimization (<a class="el" href="classDakota_1_1NonDGlobalInterval.html">NonDGlobalInterval</a>), and local optimization (<a class="el" href="classDakota_1_1NonDLocalInterval.html">NonDLocalInterval</a>). Each of these three has specializations for single interval and Dempster-Shafer Theory of Evidence approaches. <br  />
</p>
<p class="endli"></p>
</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Parameter studies and design of experiments: <a class="el" href="classDakota_1_1PStudyDACE.html">PStudyDACE</a> provides a base class for <a class="el" href="classDakota_1_1ParamStudy.html">ParamStudy</a>, which provides capabilities for directed parameter space interrogation, <a class="el" href="classDakota_1_1PSUADEDesignCompExp.html">PSUADEDesignCompExp</a>, which provides access to the Morris One-At-a-Time (MOAT) method for parameter screening, and <a class="el" href="classDakota_1_1DDACEDesignCompExp.html">DDACEDesignCompExp</a> and <a class="el" href="classDakota_1_1FSUDesignCompExp.html">FSUDesignCompExp</a>, which provide for parameter space exploration through design and analysis of computer experiments. <a class="el" href="classDakota_1_1NonDLHSSampling.html">NonDLHSSampling</a> from the uncertainty quantification branch also supports design of experiments when in <code>active</code> <code>all</code> variables mode.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Solution verification studies: <a class="el" href="classDakota_1_1Verification.html">Verification</a> provides a base class for <a class="el" href="classDakota_1_1RichExtrapVerification.html">RichExtrapVerification</a> (verification via Richardson extrapolation) and other solution verification methods in development.</p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="DevModels"></a>
Models</h2>
<p>Class hierarchy: <a class="el" href="classDakota_1_1Model.html">Model</a>.</p>
<p>The model classes are responsible for mapping variables into responses when an iterator makes a function evaluation request. There are several types of models, some supporting sub-iterators and sub-models for enabling layered and nested relationships. When sub-models are used, they may be of arbitrary type so that a variety of recursions are supported.</p>
<ul>
<li>
<p class="startli"><a class="el" href="classDakota_1_1SimulationModel.html">SimulationModel</a>: variables are mapped into responses using a simulation-based <a class="el" href="classDakota_1_1Interface.html">Interface</a> object. No sub-iterators or sub-models are used.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classDakota_1_1SurrogateModel.html">SurrogateModel</a>: variables are mapped into responses using an approximation. The approximation is built and/or corrected using data from a sub-model (the truth model) and the data may be obtained using a sub-iterator (a design of experiments iterator). <a class="el" href="classDakota_1_1SurrogateModel.html">SurrogateModel</a> has two derived classes: <a class="el" href="classDakota_1_1DataFitSurrModel.html">DataFitSurrModel</a> for data fit surrogates and HierarchSurrModel for hierarchical models of varying fidelity. The relationship of the sub-iterators and sub-models is considered to be "layered" since they are not used as part of every response evaluation on the top level model, but rather used periodically in surrogate update and verification steps.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classDakota_1_1NestedModel.html">NestedModel</a>: variables are mapped into responses using a combination of an optional <a class="el" href="classDakota_1_1Interface.html">Interface</a> and a sub-iterator/sub-model pair. The relationship of the sub-iterators and sub-models is considered to be "nested" since they are used to perform a complete iterative study as part of every response evaluation on the top level model.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classDakota_1_1RecastModel.html">RecastModel</a>: recasts the inputs and outputs of a sub-model for the purposes of variable transformations (e.g., variable scaling, transformations to standardized random variables) and problem reformulation (e.g., multi-objective optimization, response scaling, augmented Lagrangian merit functions, expected improvement). </li>
</ul>
<h2><a class="anchor" id="DevVariables"></a>
Variables</h2>
<p>Class hierarchy: <a class="el" href="classDakota_1_1Variables.html">Variables</a>.</p>
<p>The <a class="el" href="classDakota_1_1Variables.html">Variables</a> class hierarchy manages design, aleatory uncertain, epistemic uncertain, and state <em>variable</em> <em>types</em> for continuous, discrete integer, and discrete real <em>domain</em> <em>types</em>. This hierarchy is specialized according to how the domain types are managed:</p>
<ul>
<li>
<p class="startli"><a class="el" href="classDakota_1_1MixedVariables.html">MixedVariables</a>: domain type distinctions are retained, such that separate continuous, discrete integer, and discrete real domain types are managed. This is the default Variable perspective, and draws its name from "mixed
continuous-discrete" optimization.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classDakota_1_1RelaxedVariables.html">RelaxedVariables</a>: domain types are combined through relaxation of discrete constraints; i.e., continuous and discrete variables are merged into continuous arrays through relaxation of integrality (for discrete integer ranges) or set membership (for discrete integer or discrete real sets) requirements. The branch and bound minimizer is the only method using this approach at present.</p>
<p class="endli"></p>
</li>
</ul>
<p>Whereas domain types are defined based on the derived <a class="el" href="classDakota_1_1Variables.html" title="Base class for the variables class hierarchy.">Variables</a> class selection, the selection of active variable types is handled within each of these derived classes using variable views. These permit different algorithms to work on different subsets of variables. Data shared among <a class="el" href="classDakota_1_1Variables.html" title="Base class for the variables class hierarchy.">Variables</a> instances is stored in <a class="el" href="classDakota_1_1SharedVariablesData.html">SharedVariablesData</a>. For details on managing variables, see <a class="el" href="VarContainersViews.html">Working with Variable Containers and Views</a>.</p>
<p>The <a class="el" href="classDakota_1_1Constraints.html">Constraints</a> hierarchy manages bound, linear, and nonlinear constraints and utilizes the same specializations for managing bounds on the variables (see <a class="el" href="classDakota_1_1MixedVarConstraints.html">MixedVarConstraints</a> and <a class="el" href="classDakota_1_1RelaxedVarConstraints.html">RelaxedVarConstraints</a>).</p>
<h2><a class="anchor" id="DevInterfaces"></a>
Interfaces</h2>
<p>Class hierarchy: <a class="el" href="classDakota_1_1Interface.html">Interface</a>.</p>
<p>Interfaces provide access to simulation codes or, conversely, approximations based on simulation code data. In the simulation case, an <a class="el" href="classDakota_1_1ApplicationInterface.html">ApplicationInterface</a> is used. <br  />
 <a class="el" href="classDakota_1_1ApplicationInterface.html">ApplicationInterface</a> is specialized according to the simulation invocation mechanism, for which the following nonintrusive approaches are supported:</p>
<ul>
<li>
<p class="startli"><a class="el" href="classDakota_1_1SysCallApplicInterface.html">SysCallApplicInterface</a>: the simulation is invoked using a system call (the C function <code>system()</code>). Asynchronous invocation utilizes a background system call. Utilizes the <a class="el" href="classDakota_1_1CommandShell.html">CommandShell</a> utility.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classDakota_1_1ForkApplicInterface.html">ForkApplicInterface</a>: the simulation is invoked using a fork (the <code>fork/exec/wait</code> family of functions). Asynchronous invocation utilizes a nonblocking fork.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classDakota_1_1SpawnApplicInterface.html">SpawnApplicInterface</a>: for Windows, fork is replaced by spawn. Asynchronous invocation utilizes a nonblocking spawn.</p>
<p class="endli"></p>
</li>
</ul>
<p>Fork and Spawn are inherited from <a class="el" href="classDakota_1_1ProcessHandleApplicInterface.html">ProcessHandleApplicInterface</a> and System and ProcessHandle are inherited from <a class="el" href="classDakota_1_1ProcessApplicInterface.html">ProcessApplicInterface</a>. A semi-intrusive approach is also supported by:</p>
<ul>
<li>
<a class="el" href="classDakota_1_1DirectApplicInterface.html">DirectApplicInterface</a>: the simulation is linked into the Dakota executable and is invoked using a procedure call. Asynchronous invocations will utilize nonblocking threads (capability not yet available). Specializations of the direct interface are implemented in <a class="el" href="classDakota_1_1MatlabInterface.html">MatlabInterface</a>, <a class="el" href="classDakota_1_1PythonInterface.html">PythonInterface</a>, <a class="el" href="classDakota_1_1ScilabInterface.html">ScilabInterface</a>, and (for built-in testers) <a class="el" href="classDakota_1_1TestDriverInterface.html">TestDriverInterface</a>, while examples of plugin interfaces for library mode in serial and parallel, respectively, are included in <a class="el" href="classSIM_1_1SerialDirectApplicInterface.html">SerialDirectApplicInterface</a> and <a class="el" href="classSIM_1_1ParallelDirectApplicInterface.html">ParallelDirectApplicInterface</a> </li>
</ul>
<p>Scheduling of jobs for asynchronous local, message passing, and hybrid parallelism approaches is performed in the <a class="el" href="classDakota_1_1ApplicationInterface.html">ApplicationInterface</a> class, with job initiation and job capture specifics implemented in the derived classes.</p>
<p>In the approximation case, global, multipoint, or local data fit approximations to simulation code response data can be built and used as surrogates for the actual, expensive simulation. The interface class providing this capability is</p>
<ul>
<li>
<a class="el" href="classDakota_1_1ApproximationInterface.html">ApproximationInterface</a>: builds an approximation using data from a truth model and then employs the approximation for mapping variables to responses. This class contains an array of <a class="el" href="classDakota_1_1Approximation.html">Approximation</a> objects, one per response function, which support a variety of approximation types using the different <a class="el" href="classDakota_1_1Approximation.html">Approximation</a> derived classes. These include <a class="el" href="classDakota_1_1SurfpackApproximation.html">SurfpackApproximation</a> (provides kriging, MARS, moving least squares, neural network, polynomial regression, and radial basis functions), <a class="el" href="classDakota_1_1GaussProcApproximation.html">GaussProcApproximation</a> (Gaussian process models), <a class="el" href="classDakota_1_1PecosApproximation.html">PecosApproximation</a> (multivariate orthogonal and Lagrange interpolation polynomials from Pecos), <a class="el" href="classDakota_1_1TANA3Approximation.html">TANA3Approximation</a> (two-point adaptive nonlinearity approximation), and <a class="el" href="classDakota_1_1TaylorApproximation.html">TaylorApproximation</a> (local Taylor series). </li>
</ul>
<p>which is an essential component within the <a class="el" href="classDakota_1_1DataFitSurrModel.html">DataFitSurrModel</a> capability described above in <a class="el" href="index.html#DevModels">Models</a>.</p>
<h2><a class="anchor" id="DevResponses"></a>
Responses</h2>
<p>Class: <a class="el" href="classDakota_1_1Response.html">Response</a>.</p>
<p>The <a class="el" href="classDakota_1_1Response.html">Response</a> class provides an abstract data representation of response functions and their first and second derivatives (gradient vectors and Hessian matrices). These response functions can be interpreted as objective functions and constraints (optimization data set), residual functions and constraints (least squares data set), or generic response functions (uncertainty quantification data set). This class is not currently part of a class hierarchy, since the abstraction has been sufficiently general and has not required specialization.</p>
<h1><a class="anchor" id="DevServices"></a>
Services</h1>
<p>A variety of services and utilities are used in Dakota for parallel computing, failure capturing, restart, graphics, etc. An overview of the classes and member functions involved in performing these services is included here.</p>
<ul>
<li>
<p class="startli">Multilevel parallel computing: Dakota supports multiple levels of nested parallelism. A meta-iterator can manage concurrent iterators, each of which manages concurrent function evaluations, each of which manages concurrent analyses executing on multiple processors. Partitioning of these levels with MPI communicators is managed in <a class="el" href="classDakota_1_1ParallelLibrary.html">ParallelLibrary</a> and scheduling routines for the levels are part of <a class="el" href="classDakota_1_1IteratorScheduler.html">IteratorScheduler</a>, <a class="el" href="classDakota_1_1ApplicationInterface.html">ApplicationInterface</a>, and <a class="el" href="classDakota_1_1ForkApplicInterface.html">ForkApplicInterface</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Option management: Global options controlling behavior are managed in <a class="el" href="classDakota_1_1ProgramOptions.html">ProgramOptions</a>, with the help of command-line option parsing in <a class="el" href="classDakota_1_1CommandLineHandler.html">CommandLineHandler</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Parsing: Dakota employs NIDR (New Input Deck Reader) via <a class="el" href="classDakota_1_1ProblemDescDB.html#a6e4df94d340ef092c2574e8fee776c75">Dakota::ProblemDescDB::parse_inputs</a> to parse user input files. NIDR uses the keyword handlers in the <a class="el" href="classDakota_1_1NIDRProblemDescDB.html">NIDRProblemDescDB</a> derived class to populate data within the <a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> base class, which maintains a <a class="el" href="classDakota_1_1DataEnvironment.html">DataEnvironment</a> specification and lists of <a class="el" href="classDakota_1_1DataMethod.html">DataMethod</a>, <a class="el" href="classDakota_1_1DataModel.html">DataModel</a>, <a class="el" href="classDakota_1_1DataVariables.html">DataVariables</a>, <a class="el" href="classDakota_1_1DataInterface.html">DataInterface</a>, and <a class="el" href="classDakota_1_1DataResponses.html">DataResponses</a> specifications. Procedures for modifying the parsing subsystem are described in <a class="el" href="SpecChange.html">Instructions for Modifying Dakota's Input Specification</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Failure capturing: Simulation failures can be trapped and managed using exception handling in <a class="el" href="classDakota_1_1ApplicationInterface.html">ApplicationInterface</a> and its derived classes.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Restart: Dakota maintains a record of all function evaluations both in memory (for capturing any duplication) and on the file system (for restarting runs). Restart options are managed through <a class="el" href="classDakota_1_1ProgramOptions.html">ProgramOptions</a> (with the help of <a class="el" href="classDakota_1_1CommandLineHandler.html">CommandLineHandler</a>); file management in <a class="el" href="classDakota_1_1OutputManager.html">OutputManager</a>; and restart file insertions occur in <a class="el" href="classDakota_1_1ApplicationInterface.html">ApplicationInterface</a>. The <code>dakota_restart_util</code> executable, built from <a class="el" href="restart__util_8cpp.html" title="file containing the DAKOTA restart utility main program">restart_util.cpp</a>, provides a variety of services for interrogating, converting, repairing, concatenating, and post-processing restart files.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Memory management: Dakota employs the techniques of reference counting and representation sharing through the use of letter-envelope and handle-body idioms (Coplien, "Advanced C++"). The former idiom provides for memory efficiency and enhanced polymorphism in the following class hierarchies: <a class="el" href="classDakota_1_1Environment.html">Environment</a>, <a class="el" href="classDakota_1_1Iterator.html">Iterator</a>, <a class="el" href="classDakota_1_1Model.html">Model</a>, <a class="el" href="classDakota_1_1Variables.html">Variables</a>, <a class="el" href="classDakota_1_1Constraints.html">Constraints</a>, <a class="el" href="classDakota_1_1Interface.html">Interface</a>, <a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a>, and <a class="el" href="classDakota_1_1Approximation.html">Approximation</a>. The latter idiom provides for memory efficiency in data-intensive classes which do not involve a class hierarchy. The <a class="el" href="classDakota_1_1Response.html">Response</a> and parser data (<a class="el" href="classDakota_1_1DataEnvironment.html">DataEnvironment</a>, <a class="el" href="classDakota_1_1DataMethod.html">DataMethod</a>, <a class="el" href="classDakota_1_1DataModel.html">DataModel</a>, <a class="el" href="classDakota_1_1DataVariables.html">DataVariables</a>, <a class="el" href="classDakota_1_1DataInterface.html">DataInterface</a>, and <a class="el" href="classDakota_1_1DataResponses.html">DataResponses</a>) classes use this idiom. When managing reference-counted data containers (e.g., <a class="el" href="classDakota_1_1Variables.html">Variables</a> or <a class="el" href="classDakota_1_1Response.html">Response</a> objects), it is important to properly manage shallow and deep copies, to allow for both efficiency and data independence as needed in a particular context.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Graphics and Output: Dakota provides 2D iteration history graphics using Motif widgets. Graphics data can also be cataloged in a tabular data file for post-processing with 3rd party tools such as Matlab, Tecplot, etc. These capabilities are encapsulated within the <a class="el" href="classDakota_1_1Graphics.html">Graphics</a> class. An experimental results database is implemented in <a class="el" href="classDakota_1_1ResultsManager.html">ResultsManager</a> and <a class="el" href="classDakota_1_1ResultsDBAny.html">ResultsDBAny</a>. Options for controlling output and facilities for managing it are in <a class="el" href="classDakota_1_1OutputManager.html">OutputManager</a>.</p>
<p class="endli"></p>
</li>
</ul>
<h1><a class="anchor" id="DevGuidance"></a>
Development Practices and Guidance</h1>
<p>The following links provide guidance for core software components or specific development activities:</p>
<ul>
<li><a class="el" href="StyleConventions.html">Coding Style Guidelines and Conventions</a> - coding practices used by the Dakota development team. </li>
<li><a class="el" href="SpecChange.html">Instructions for Modifying Dakota's Input Specification</a> - how to interact with NIDR and the associated Dakota classes. </li>
<li><a class="el" href="DakLibrary.html">Interfacing with Dakota as a Library</a> - embed Dakota as a service within your application. </li>
<li><a class="el" href="IteratorFlow.html">Understanding Iterator Flow</a> - explanation of the full granularity of steps in <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> execution. </li>
<li><a class="el" href="FnEvals.html">Performing Function Evaluations</a> - an overview of the classes and member functions involved in performing function evaluations synchronously or asynchronously. </li>
<li><a class="el" href="VarContainersViews.html">Working with Variable Containers and Views</a> - discussion of data storage for variables and explanation of active and inactive views of this data. </li>
<li><a class="el" href="demotpl.html">Demo TPL</a> - a README for bringing a new Third-Party Library (TPL) into <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a></li>
</ul>
<h1><a class="anchor" id="DevAddtnl"></a>
Additional Resources</h1>
<p>Additional development resources include:</p>
<ul>
<li>The Dakota Developer Portal linked from <a href="http://dakota.sandia.gov/content/developer-portal/">http://dakota.sandia.gov/content/developer-portal/</a> includes information on getting started as a developer and links to project management resources. </li>
<li>Project web pages are maintained at <a href="http://dakota.sandia.gov/">http://dakota.sandia.gov/</a> including links to frequently asked questions, documentation, publications, mailing lists, and other resources. </li>
<li>A Quickstart for bringing a new Third-Party Library (TPL) into <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> can be found in the <a class="el" href="namespaceDakota.html" title="The primary namespace for DAKOTA.">Dakota</a> source tree under $DAKOTA_SRC/packages/external/demo_tpl/README.md . </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
