<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Dakota Developers Manual" />
<meta name="keywords" content="optimization, uncertainty quantification, model calibration, parameter estimation, sensitivity analysis, parallel computing, developers manual" />
<meta name="sandia.approval_type" content="formal" />
<meta name="sandia.approved" content="2010-2185" />
<link rev="owns" title="Brian M. Adams" href="mailto:briadam@sandia.gov" />
<meta name="Author" content="Brian M. Adams" />
<title>Dakota: Iterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DAKOTA_Arrow_Name_77x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dakota
   &#160;<span id="projectnumber">Version</span>
   </div>
   <div id="projectbrief">Explore and Predict with Confidence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDakota.html">Dakota</a></li><li class="navelem"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classDakota_1_1Iterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Iterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for the iterator class hierarchy.  
 <a href="classDakota_1_1Iterator.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Iterator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classDakota_1_1Iterator.png" usemap="#Iterator_map" alt=""/>
  <map id="Iterator_map" name="Iterator_map">
<area href="classDakota_1_1Analyzer.html" title="Base class for NonD, DACE, and ParamStudy branches of the iterator hierarchy." alt="Analyzer" shape="rect" coords="0,56,156,80"/>
<area href="classDakota_1_1MetaIterator.html" title="Base class for meta-iterators." alt="MetaIterator" shape="rect" coords="332,56,488,80"/>
<area href="classDakota_1_1Minimizer.html" title="Base class for the optimizer and least squares branches of the iterator hierarchy." alt="Minimizer" shape="rect" coords="664,56,820,80"/>
<area href="classDakota_1_1NonD.html" title="Base class for all nondetermistic iterators (the DAKOTA/UQ branch)." alt="NonD" shape="rect" coords="166,112,322,136"/>
<area href="classDakota_1_1PStudyDACE.html" title="Base class for managing common aspects of parameter studies and design of experiments methods." alt="PStudyDACE" shape="rect" coords="166,168,322,192"/>
<area href="classDakota_1_1Verification.html" title="Base class for managing common aspects of verification studies." alt="Verification" shape="rect" coords="166,224,322,248"/>
<area href="classDakota_1_1CollabHybridMetaIterator.html" title="Meta-iterator for hybrid iteration using multiple collaborating optimization and nonlinear least squa..." alt="CollabHybridMetaIterator" shape="rect" coords="498,112,654,136"/>
<area href="classDakota_1_1ConcurrentMetaIterator.html" title="Meta-iterator for multi-start iteration or pareto set optimization." alt="ConcurrentMetaIterator" shape="rect" coords="498,168,654,192"/>
<area href="classDakota_1_1EmbedHybridMetaIterator.html" title="Meta-iterator for closely-coupled hybrid iteration, typically involving the embedding of local search..." alt="EmbedHybridMetaIterator" shape="rect" coords="498,224,654,248"/>
<area href="classDakota_1_1SeqHybridMetaIterator.html" title="Method for sequential hybrid iteration using multiple optimization and nonlinear least squares method..." alt="SeqHybridMetaIterator" shape="rect" coords="498,280,654,304"/>
<area href="classDakota_1_1LeastSq.html" title="Base class for the nonlinear least squares branch of the iterator hierarchy." alt="LeastSq" shape="rect" coords="830,112,986,136"/>
<area href="classDakota_1_1Optimizer.html" title="Base class for the optimizer branch of the iterator hierarchy." alt="Optimizer" shape="rect" coords="830,168,986,192"/>
<area href="classDakota_1_1SurrBasedMinimizer.html" title="Base class for local/global surrogate-based optimization/least squares." alt="SurrBasedMinimizer" shape="rect" coords="830,224,986,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a668a398bcf34b766e5773f039f61a9dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a668a398bcf34b766e5773f039f61a9dc">Iterator</a> (std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt; <a class="el" href="classDakota_1_1Iterator.html#a7d501757155de544e19b12f2b45dcead">traits</a>=std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;(new <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>()))</td></tr>
<tr class="memdesc:a668a398bcf34b766e5773f039f61a9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classDakota_1_1Iterator.html#a668a398bcf34b766e5773f039f61a9dc">More...</a><br /></td></tr>
<tr class="separator:a668a398bcf34b766e5773f039f61a9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46469785469e3b51dda41d692d910a00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a46469785469e3b51dda41d692d910a00">Iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt; <a class="el" href="classDakota_1_1Iterator.html#a7d501757155de544e19b12f2b45dcead">traits</a>=std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;(new <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>()))</td></tr>
<tr class="memdesc:a46469785469e3b51dda41d692d910a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard envelope constructor, which constructs its own model(s)  <a href="classDakota_1_1Iterator.html#a46469785469e3b51dda41d692d910a00">More...</a><br /></td></tr>
<tr class="separator:a46469785469e3b51dda41d692d910a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef11f0c1be2a246d383d9405f67c985"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#adef11f0c1be2a246d383d9405f67c985">Iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, <a class="el" href="classDakota_1_1Model.html">Model</a> &amp;model, std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt; <a class="el" href="classDakota_1_1Iterator.html#a7d501757155de544e19b12f2b45dcead">traits</a>=std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;(new <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>()))</td></tr>
<tr class="memdesc:adef11f0c1be2a246d383d9405f67c985"><td class="mdescLeft">&#160;</td><td class="mdescRight">alternate envelope constructor which uses the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> but accepts a model from a higher level (meta-iterator) context, instead of constructing its own  <a href="classDakota_1_1Iterator.html#adef11f0c1be2a246d383d9405f67c985">More...</a><br /></td></tr>
<tr class="separator:adef11f0c1be2a246d383d9405f67c985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66caab45c5c797d570f7fc595b8d9554"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a66caab45c5c797d570f7fc595b8d9554">Iterator</a> (const String &amp;<a class="el" href="classDakota_1_1Iterator.html#a71dc13c14c38573c2fe361b091568bd1">method_string</a>, <a class="el" href="classDakota_1_1Model.html">Model</a> &amp;model, std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt; <a class="el" href="classDakota_1_1Iterator.html#a7d501757155de544e19b12f2b45dcead">traits</a>=std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;(new <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>()))</td></tr>
<tr class="memdesc:a66caab45c5c797d570f7fc595b8d9554"><td class="mdescLeft">&#160;</td><td class="mdescRight">alternate envelope constructor for instantiations by name without the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a>  <a href="classDakota_1_1Iterator.html#a66caab45c5c797d570f7fc595b8d9554">More...</a><br /></td></tr>
<tr class="separator:a66caab45c5c797d570f7fc595b8d9554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6db128dfed6236df263f151edfc050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a9e6db128dfed6236df263f151edfc050">Iterator</a> (const <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;iterator)</td></tr>
<tr class="memdesc:a9e6db128dfed6236df263f151edfc050"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classDakota_1_1Iterator.html#a9e6db128dfed6236df263f151edfc050">More...</a><br /></td></tr>
<tr class="separator:a9e6db128dfed6236df263f151edfc050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b82815a73859e781b4798eb82f221"><td class="memItemLeft" align="right" valign="top"><a id="a844b82815a73859e781b4798eb82f221"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a844b82815a73859e781b4798eb82f221">~Iterator</a> ()</td></tr>
<tr class="memdesc:a844b82815a73859e781b4798eb82f221"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a844b82815a73859e781b4798eb82f221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac85a645b85778bcb9525654c5e4fb0"><td class="memItemLeft" align="right" valign="top"><a id="a5ac85a645b85778bcb9525654c5e4fb0"></a>
<a class="el" href="classDakota_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a5ac85a645b85778bcb9525654c5e4fb0">operator=</a> (const <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;iterator)</td></tr>
<tr class="memdesc:a5ac85a645b85778bcb9525654c5e4fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator <br /></td></tr>
<tr class="separator:a5ac85a645b85778bcb9525654c5e4fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89bef5ad711f51ceea37e61bcde54d5"><td class="memItemLeft" align="right" valign="top"><a id="ae89bef5ad711f51ceea37e61bcde54d5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ae89bef5ad711f51ceea37e61bcde54d5">derived_set_communicators</a> (ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:ae89bef5ad711f51ceea37e61bcde54d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">derived class contributions to setting the communicators associated with this <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> instance <br /></td></tr>
<tr class="separator:ae89bef5ad711f51ceea37e61bcde54d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52bd656bac37cbf7cc8926b025a0b5a"><td class="memItemLeft" align="right" valign="top"><a id="ac52bd656bac37cbf7cc8926b025a0b5a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ac52bd656bac37cbf7cc8926b025a0b5a">derived_free_communicators</a> (ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:ac52bd656bac37cbf7cc8926b025a0b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">derived class contributions to freeing the communicators associated with this <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> instance <br /></td></tr>
<tr class="separator:ac52bd656bac37cbf7cc8926b025a0b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1257cf90111aec1c47057d3bc893111"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aa1257cf90111aec1c47057d3bc893111">initialize_run</a> ()</td></tr>
<tr class="memdesc:aa1257cf90111aec1c47057d3bc893111"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to perform common operations prior to <a class="el" href="classDakota_1_1Iterator.html#a7a8df3f99e1d582c6c136b16d6e34d13" title="pre-run portion of run (optional); re-implemented by Iterators which can generate all Variables (para...">pre_run()</a>; typically memory initialization; setting of instance pointers  <a href="classDakota_1_1Iterator.html#aa1257cf90111aec1c47057d3bc893111">More...</a><br /></td></tr>
<tr class="separator:aa1257cf90111aec1c47057d3bc893111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8df3f99e1d582c6c136b16d6e34d13"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a7a8df3f99e1d582c6c136b16d6e34d13">pre_run</a> ()</td></tr>
<tr class="memdesc:a7a8df3f99e1d582c6c136b16d6e34d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">pre-run portion of run (optional); re-implemented by Iterators which can generate all <a class="el" href="classDakota_1_1Variables.html" title="Base class for the variables class hierarchy.">Variables</a> (parameter sets) a priori  <a href="classDakota_1_1Iterator.html#a7a8df3f99e1d582c6c136b16d6e34d13">More...</a><br /></td></tr>
<tr class="separator:a7a8df3f99e1d582c6c136b16d6e34d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cdbb1eb9544b4f8a42944a00a222be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a64cdbb1eb9544b4f8a42944a00a222be">core_run</a> ()</td></tr>
<tr class="memdesc:a64cdbb1eb9544b4f8a42944a00a222be"><td class="mdescLeft">&#160;</td><td class="mdescRight">core portion of run; implemented by all derived classes and may include pre/post steps in lieu of separate pre/post  <a href="classDakota_1_1Iterator.html#a64cdbb1eb9544b4f8a42944a00a222be">More...</a><br /></td></tr>
<tr class="separator:a64cdbb1eb9544b4f8a42944a00a222be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871297a2dea1389f3d8c57341f9ed45a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a871297a2dea1389f3d8c57341f9ed45a">post_run</a> (std::ostream &amp;s)</td></tr>
<tr class="memdesc:a871297a2dea1389f3d8c57341f9ed45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">post-run portion of run (optional); verbose to print results; re-implemented by Iterators that can read all Variables/Responses and perform final analysis phase in a standalone way  <a href="classDakota_1_1Iterator.html#a871297a2dea1389f3d8c57341f9ed45a">More...</a><br /></td></tr>
<tr class="separator:a871297a2dea1389f3d8c57341f9ed45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05afabcb70acd3943a391cd13076db1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#af05afabcb70acd3943a391cd13076db1">finalize_run</a> ()</td></tr>
<tr class="memdesc:af05afabcb70acd3943a391cd13076db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to perform common operations following <a class="el" href="classDakota_1_1Iterator.html#a871297a2dea1389f3d8c57341f9ed45a" title="post-run portion of run (optional); verbose to print results; re-implemented by Iterators that can re...">post_run()</a>; deallocation and resetting of instance pointers  <a href="classDakota_1_1Iterator.html#af05afabcb70acd3943a391cd13076db1">More...</a><br /></td></tr>
<tr class="separator:af05afabcb70acd3943a391cd13076db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faf36a9b3190012a78eb27592306b2b"><td class="memItemLeft" align="right" valign="top"><a id="a9faf36a9b3190012a78eb27592306b2b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a9faf36a9b3190012a78eb27592306b2b">pre_output</a> ()</td></tr>
<tr class="memdesc:a9faf36a9b3190012a78eb27592306b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">write variables to file, following pre-run <br /></td></tr>
<tr class="separator:a9faf36a9b3190012a78eb27592306b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b161441712f433017bceea927985cb"><td class="memItemLeft" align="right" valign="top"><a id="a63b161441712f433017bceea927985cb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a63b161441712f433017bceea927985cb">post_input</a> ()</td></tr>
<tr class="memdesc:a63b161441712f433017bceea927985cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">read tabular data for post-run mode <br /></td></tr>
<tr class="separator:a63b161441712f433017bceea927985cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20897c5c8bd47f5d4005989bead0e55"><td class="memItemLeft" align="right" valign="top"><a id="ad20897c5c8bd47f5d4005989bead0e55"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ad20897c5c8bd47f5d4005989bead0e55">reset</a> ()</td></tr>
<tr class="memdesc:ad20897c5c8bd47f5d4005989bead0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore initial state for repeated sub-iterator executions <br /></td></tr>
<tr class="separator:ad20897c5c8bd47f5d4005989bead0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae97a4dac332cd699354a7a68221aa63"><td class="memItemLeft" align="right" valign="top"><a id="aae97a4dac332cd699354a7a68221aa63"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aae97a4dac332cd699354a7a68221aa63">nested_variable_mappings</a> (const SizetArray &amp;c_index1, const SizetArray &amp;di_index1, const SizetArray &amp;ds_index1, const SizetArray &amp;dr_index1, const ShortArray &amp;c_target2, const ShortArray &amp;di_target2, const ShortArray &amp;ds_target2, const ShortArray &amp;dr_target2)</td></tr>
<tr class="memdesc:aae97a4dac332cd699354a7a68221aa63"><td class="mdescLeft">&#160;</td><td class="mdescRight">set primaryA{CV,DIV,DRV}MapIndices, secondaryA{CV,DIV,DRV}MapTargets within derived Iterators; supports computation of higher-level sensitivities in nested contexts (e.g., derivatives of statistics w.r.t. inserted design variables) <br /></td></tr>
<tr class="separator:aae97a4dac332cd699354a7a68221aa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f460dccd4ce4f542d36b21be635da59"><td class="memItemLeft" align="right" valign="top"><a id="a3f460dccd4ce4f542d36b21be635da59"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a3f460dccd4ce4f542d36b21be635da59">nested_response_mappings</a> (const RealMatrix &amp;primary_coeffs, const RealMatrix &amp;secondary_coeffs)</td></tr>
<tr class="memdesc:a3f460dccd4ce4f542d36b21be635da59"><td class="mdescLeft">&#160;</td><td class="mdescRight">set primaryResponseCoefficients, secondaryResponseCoefficients within derived Iterators; Necessary for scalarization case in MLMC <a class="el" href="classDakota_1_1NonDMultilevelSampling.html" title="Performs Multilevel Monte Carlo sampling for uncertainty quantification.">NonDMultilevelSampling</a> to map scalarization in nested context <br /></td></tr>
<tr class="separator:a3f460dccd4ce4f542d36b21be635da59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd777c46f0266094f1cd7b9e775776b3"><td class="memItemLeft" align="right" valign="top"><a id="abd777c46f0266094f1cd7b9e775776b3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#abd777c46f0266094f1cd7b9e775776b3">initialize_iterator</a> (int job_index)</td></tr>
<tr class="memdesc:abd777c46f0266094f1cd7b9e775776b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by <a class="el" href="classDakota_1_1IteratorScheduler.html" title="This class encapsulates scheduling operations for concurrent sub-iteration within an outer level cont...">IteratorScheduler</a> to set the starting data for a run <br /></td></tr>
<tr class="separator:abd777c46f0266094f1cd7b9e775776b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02f38f3c8fb36091fe28b4c9e6b024f"><td class="memItemLeft" align="right" valign="top"><a id="af02f38f3c8fb36091fe28b4c9e6b024f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#af02f38f3c8fb36091fe28b4c9e6b024f">pack_parameters_buffer</a> (<a class="el" href="classDakota_1_1MPIPackBuffer.html">MPIPackBuffer</a> &amp;send_buffer, int job_index)</td></tr>
<tr class="memdesc:af02f38f3c8fb36091fe28b4c9e6b024f"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by <a class="el" href="classDakota_1_1IteratorScheduler.html" title="This class encapsulates scheduling operations for concurrent sub-iteration within an outer level cont...">IteratorScheduler</a> to pack starting data for an iterator run <br /></td></tr>
<tr class="separator:af02f38f3c8fb36091fe28b4c9e6b024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe09cbd92eca65e10094855a6e4c45d"><td class="memItemLeft" align="right" valign="top"><a id="adbe09cbd92eca65e10094855a6e4c45d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#adbe09cbd92eca65e10094855a6e4c45d">unpack_parameters_buffer</a> (<a class="el" href="classDakota_1_1MPIUnpackBuffer.html">MPIUnpackBuffer</a> &amp;recv_buffer, int job_index)</td></tr>
<tr class="memdesc:adbe09cbd92eca65e10094855a6e4c45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by <a class="el" href="classDakota_1_1IteratorScheduler.html" title="This class encapsulates scheduling operations for concurrent sub-iteration within an outer level cont...">IteratorScheduler</a> to unpack starting data for an iterator run <br /></td></tr>
<tr class="separator:adbe09cbd92eca65e10094855a6e4c45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ff34aa207ab99503157604544e7681"><td class="memItemLeft" align="right" valign="top"><a id="a78ff34aa207ab99503157604544e7681"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a78ff34aa207ab99503157604544e7681">unpack_parameters_initialize</a> (<a class="el" href="classDakota_1_1MPIUnpackBuffer.html">MPIUnpackBuffer</a> &amp;recv_buffer, int job_index)</td></tr>
<tr class="memdesc:a78ff34aa207ab99503157604544e7681"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by <a class="el" href="classDakota_1_1IteratorScheduler.html" title="This class encapsulates scheduling operations for concurrent sub-iteration within an outer level cont...">IteratorScheduler</a> to unpack starting data and initialize an iterator run <br /></td></tr>
<tr class="separator:a78ff34aa207ab99503157604544e7681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ded451b627d7b7638b17ccc3dca0ca"><td class="memItemLeft" align="right" valign="top"><a id="a12ded451b627d7b7638b17ccc3dca0ca"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a12ded451b627d7b7638b17ccc3dca0ca">pack_results_buffer</a> (<a class="el" href="classDakota_1_1MPIPackBuffer.html">MPIPackBuffer</a> &amp;send_buffer, int job_index)</td></tr>
<tr class="memdesc:a12ded451b627d7b7638b17ccc3dca0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by <a class="el" href="classDakota_1_1IteratorScheduler.html" title="This class encapsulates scheduling operations for concurrent sub-iteration within an outer level cont...">IteratorScheduler</a> to pack results data from an iterator run <br /></td></tr>
<tr class="separator:a12ded451b627d7b7638b17ccc3dca0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32798e1aac42f432ff0972ebd4262c7b"><td class="memItemLeft" align="right" valign="top"><a id="a32798e1aac42f432ff0972ebd4262c7b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a32798e1aac42f432ff0972ebd4262c7b">unpack_results_buffer</a> (<a class="el" href="classDakota_1_1MPIUnpackBuffer.html">MPIUnpackBuffer</a> &amp;recv_buffer, int job_index)</td></tr>
<tr class="memdesc:a32798e1aac42f432ff0972ebd4262c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by <a class="el" href="classDakota_1_1IteratorScheduler.html" title="This class encapsulates scheduling operations for concurrent sub-iteration within an outer level cont...">IteratorScheduler</a> to unpack results data from an iterator run <br /></td></tr>
<tr class="separator:a32798e1aac42f432ff0972ebd4262c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9607427de3a8af8804492380d281785f"><td class="memItemLeft" align="right" valign="top"><a id="a9607427de3a8af8804492380d281785f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a9607427de3a8af8804492380d281785f">update_local_results</a> (int job_index)</td></tr>
<tr class="memdesc:a9607427de3a8af8804492380d281785f"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by <a class="el" href="classDakota_1_1IteratorScheduler.html" title="This class encapsulates scheduling operations for concurrent sub-iteration within an outer level cont...">IteratorScheduler</a> to update local results arrays <br /></td></tr>
<tr class="separator:a9607427de3a8af8804492380d281785f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7881a127da96fcb28d54ec19ff97f859"><td class="memItemLeft" align="right" valign="top"><a id="a7881a127da96fcb28d54ec19ff97f859"></a>
virtual const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a7881a127da96fcb28d54ec19ff97f859">variables_results</a> () const</td></tr>
<tr class="memdesc:a7881a127da96fcb28d54ec19ff97f859"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a single final iterator solution (variables) <br /></td></tr>
<tr class="separator:a7881a127da96fcb28d54ec19ff97f859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a50ef40ad7433582083419a5e2454b3"><td class="memItemLeft" align="right" valign="top"><a id="a8a50ef40ad7433582083419a5e2454b3"></a>
virtual const <a class="el" href="classDakota_1_1Response.html">Response</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a8a50ef40ad7433582083419a5e2454b3">response_results</a> () const</td></tr>
<tr class="memdesc:a8a50ef40ad7433582083419a5e2454b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a single final iterator solution (response) <br /></td></tr>
<tr class="separator:a8a50ef40ad7433582083419a5e2454b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda7ac200f96b67918cf97acf7ddf159"><td class="memItemLeft" align="right" valign="top"><a id="afda7ac200f96b67918cf97acf7ddf159"></a>
virtual const VariablesArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#afda7ac200f96b67918cf97acf7ddf159">variables_array_results</a> ()</td></tr>
<tr class="memdesc:afda7ac200f96b67918cf97acf7ddf159"><td class="mdescLeft">&#160;</td><td class="mdescRight">return multiple final iterator solutions (variables). This should only be used if <a class="el" href="classDakota_1_1Iterator.html#ada4f9ae411ee9a362aabcd2a1279aad2" title="indicates if this iterator returns multiple final points. Default return is false....">returns_multiple_points()</a> returns true. <br /></td></tr>
<tr class="separator:afda7ac200f96b67918cf97acf7ddf159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857663b6d484987933f10d42425ea2da"><td class="memItemLeft" align="right" valign="top"><a id="a857663b6d484987933f10d42425ea2da"></a>
virtual const ResponseArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a857663b6d484987933f10d42425ea2da">response_array_results</a> ()</td></tr>
<tr class="memdesc:a857663b6d484987933f10d42425ea2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">return multiple final iterator solutions (response). This should only be used if <a class="el" href="classDakota_1_1Iterator.html#ada4f9ae411ee9a362aabcd2a1279aad2" title="indicates if this iterator returns multiple final points. Default return is false....">returns_multiple_points()</a> returns true. <br /></td></tr>
<tr class="separator:a857663b6d484987933f10d42425ea2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18498de5ac17a46e72e241c37c1715b2"><td class="memItemLeft" align="right" valign="top"><a id="a18498de5ac17a46e72e241c37c1715b2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a18498de5ac17a46e72e241c37c1715b2">response_results_active_set</a> (const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;set)</td></tr>
<tr class="memdesc:a18498de5ac17a46e72e241c37c1715b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the requested data for the final iterator response results <br /></td></tr>
<tr class="separator:a18498de5ac17a46e72e241c37c1715b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a169a75b3eb3696cef0c3a02cca3c01"><td class="memItemLeft" align="right" valign="top"><a id="a1a169a75b3eb3696cef0c3a02cca3c01"></a>
virtual const RealSymMatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a1a169a75b3eb3696cef0c3a02cca3c01">response_error_estimates</a> () const</td></tr>
<tr class="memdesc:a1a169a75b3eb3696cef0c3a02cca3c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">return error estimates associated with the final iterator solution <br /></td></tr>
<tr class="separator:a1a169a75b3eb3696cef0c3a02cca3c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a2d8cc68ac5235ef1bafd40df6b59c"><td class="memItemLeft" align="right" valign="top"><a id="aa5a2d8cc68ac5235ef1bafd40df6b59c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aa5a2d8cc68ac5235ef1bafd40df6b59c">accepts_multiple_points</a> () const</td></tr>
<tr class="memdesc:aa5a2d8cc68ac5235ef1bafd40df6b59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates if this iterator accepts multiple initial points. Default return is false. Override to return true if appropriate. <br /></td></tr>
<tr class="separator:aa5a2d8cc68ac5235ef1bafd40df6b59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4f9ae411ee9a362aabcd2a1279aad2"><td class="memItemLeft" align="right" valign="top"><a id="ada4f9ae411ee9a362aabcd2a1279aad2"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ada4f9ae411ee9a362aabcd2a1279aad2">returns_multiple_points</a> () const</td></tr>
<tr class="memdesc:ada4f9ae411ee9a362aabcd2a1279aad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates if this iterator returns multiple final points. Default return is false. Override to return true if appropriate. <br /></td></tr>
<tr class="separator:ada4f9ae411ee9a362aabcd2a1279aad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add017ffe75491bce5a825de1282bba06"><td class="memItemLeft" align="right" valign="top"><a id="add017ffe75491bce5a825de1282bba06"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#add017ffe75491bce5a825de1282bba06">initial_point</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;pt)</td></tr>
<tr class="memdesc:add017ffe75491bce5a825de1282bba06"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the initial point for this iterator (user-functions mode for which <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> updating is not used) <br /></td></tr>
<tr class="separator:add017ffe75491bce5a825de1282bba06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a02f9b2d17f54f49fd0c4fb02cf7a6"><td class="memItemLeft" align="right" valign="top"><a id="a77a02f9b2d17f54f49fd0c4fb02cf7a6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a77a02f9b2d17f54f49fd0c4fb02cf7a6">initial_point</a> (const RealVector &amp;pt)</td></tr>
<tr class="memdesc:a77a02f9b2d17f54f49fd0c4fb02cf7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the initial point (active continuous variables) for this iterator (user-functions mode for which <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> updating is not used) <br /></td></tr>
<tr class="separator:a77a02f9b2d17f54f49fd0c4fb02cf7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cd3dd99a7ccb3ed82583753989c3d3"><td class="memItemLeft" align="right" valign="top"><a id="ae0cd3dd99a7ccb3ed82583753989c3d3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ae0cd3dd99a7ccb3ed82583753989c3d3">initial_points</a> (const VariablesArray &amp;pts)</td></tr>
<tr class="memdesc:ae0cd3dd99a7ccb3ed82583753989c3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the multiple initial points for this iterator. This should only be used if <a class="el" href="classDakota_1_1Iterator.html#aa5a2d8cc68ac5235ef1bafd40df6b59c" title="indicates if this iterator accepts multiple initial points. Default return is false....">accepts_multiple_points()</a> returns true. <br /></td></tr>
<tr class="separator:ae0cd3dd99a7ccb3ed82583753989c3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96548e836f4bc1a3873927fb48c4755a"><td class="memItemLeft" align="right" valign="top"><a id="a96548e836f4bc1a3873927fb48c4755a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a96548e836f4bc1a3873927fb48c4755a">variable_bounds</a> (const RealVector &amp;cv_lower_bnds, const RealVector &amp;cv_upper_bnds)</td></tr>
<tr class="memdesc:a96548e836f4bc1a3873927fb48c4755a"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign nonlinear inequality and equality constraint allowables for this iterator (user-functions mode for which <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> updating is not used) <br /></td></tr>
<tr class="separator:a96548e836f4bc1a3873927fb48c4755a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a3e1787c851f1bcbae5902798bd952"><td class="memItemLeft" align="right" valign="top"><a id="ae4a3e1787c851f1bcbae5902798bd952"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ae4a3e1787c851f1bcbae5902798bd952">linear_constraints</a> (const RealMatrix &amp;lin_ineq_coeffs, const RealVector &amp;lin_ineq_lb, const RealVector &amp;lin_ineq_ub, const RealMatrix &amp;lin_eq_coeffs, const RealVector &amp;lin_eq_tgt)</td></tr>
<tr class="memdesc:ae4a3e1787c851f1bcbae5902798bd952"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign linear inequality and linear equality constraints for this iterator (user-functions mode for which <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> updating is not used) <br /></td></tr>
<tr class="separator:ae4a3e1787c851f1bcbae5902798bd952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dbb30f5f43a5a270df58d34b17a072"><td class="memItemLeft" align="right" valign="top"><a id="af8dbb30f5f43a5a270df58d34b17a072"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#af8dbb30f5f43a5a270df58d34b17a072">nonlinear_constraints</a> (const RealVector &amp;nln_ineq_lb, const RealVector &amp;nln_ineq_ub, const RealVector &amp;nln_eq_tgt)</td></tr>
<tr class="memdesc:af8dbb30f5f43a5a270df58d34b17a072"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign nonlinear inequality and equality constraint allowables for this iterator (user-functions mode for which <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> updating is not used) <br /></td></tr>
<tr class="separator:af8dbb30f5f43a5a270df58d34b17a072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ed7a8dd3339697bf58f09925d6cf36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a58ed7a8dd3339697bf58f09925d6cf36">initialize_graphics</a> (int iterator_server_id=1)</td></tr>
<tr class="memdesc:a58ed7a8dd3339697bf58f09925d6cf36"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the 2D graphics window and the tabular graphics data  <a href="classDakota_1_1Iterator.html#a58ed7a8dd3339697bf58f09925d6cf36">More...</a><br /></td></tr>
<tr class="separator:a58ed7a8dd3339697bf58f09925d6cf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76253a61ea722d76381ded1872b404d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a76253a61ea722d76381ded1872b404d0">print_results</a> (std::ostream &amp;s, short results_state=FINAL_RESULTS)</td></tr>
<tr class="memdesc:a76253a61ea722d76381ded1872b404d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">print the final iterator results  <a href="classDakota_1_1Iterator.html#a76253a61ea722d76381ded1872b404d0">More...</a><br /></td></tr>
<tr class="separator:a76253a61ea722d76381ded1872b404d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8599264b519d44620b54005ff5fe7b"><td class="memItemLeft" align="right" valign="top"><a id="a7c8599264b519d44620b54005ff5fe7b"></a>
virtual const <a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a7c8599264b519d44620b54005ff5fe7b">algorithm_space_model</a> () const</td></tr>
<tr class="memdesc:a7c8599264b519d44620b54005ff5fe7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the result of any recasting or surrogate model recursion layered on top of iteratedModel by the derived <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> ctor chain <br /></td></tr>
<tr class="separator:a7c8599264b519d44620b54005ff5fe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e0bfc6169ff6a96bbdd9202dcce8a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a13e0bfc6169ff6a96bbdd9202dcce8a1">check_sub_iterator_conflict</a> ()</td></tr>
<tr class="memdesc:a13e0bfc6169ff6a96bbdd9202dcce8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect any conflicts due to recursive use of the same Fortran solver  <a href="classDakota_1_1Iterator.html#a13e0bfc6169ff6a96bbdd9202dcce8a1">More...</a><br /></td></tr>
<tr class="separator:a13e0bfc6169ff6a96bbdd9202dcce8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804bbe2d38d1c4af781b35250a44cf4e"><td class="memItemLeft" align="right" valign="top"><a id="a804bbe2d38d1c4af781b35250a44cf4e"></a>
virtual unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a804bbe2d38d1c4af781b35250a44cf4e">uses_method</a> () const</td></tr>
<tr class="memdesc:a804bbe2d38d1c4af781b35250a44cf4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return name of any enabling iterator used by this iterator <br /></td></tr>
<tr class="separator:a804bbe2d38d1c4af781b35250a44cf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7722d1b6ec982fd26655452e89ef2f8f"><td class="memItemLeft" align="right" valign="top"><a id="a7722d1b6ec982fd26655452e89ef2f8f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a7722d1b6ec982fd26655452e89ef2f8f">method_recourse</a> ()</td></tr>
<tr class="memdesc:a7722d1b6ec982fd26655452e89ef2f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a method switch, if possible, due to a detected conflict <br /></td></tr>
<tr class="separator:a7722d1b6ec982fd26655452e89ef2f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39085084981a1f7318db884aca87444"><td class="memItemLeft" align="right" valign="top"><a id="ad39085084981a1f7318db884aca87444"></a>
virtual const VariablesArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ad39085084981a1f7318db884aca87444">all_variables</a> ()</td></tr>
<tr class="memdesc:ad39085084981a1f7318db884aca87444"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the complete set of evaluated variables <br /></td></tr>
<tr class="separator:ad39085084981a1f7318db884aca87444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9508a4ced376133f70e35204cb08d47"><td class="memItemLeft" align="right" valign="top"><a id="ab9508a4ced376133f70e35204cb08d47"></a>
virtual const RealMatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ab9508a4ced376133f70e35204cb08d47">all_samples</a> ()</td></tr>
<tr class="memdesc:ab9508a4ced376133f70e35204cb08d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the complete set of evaluated samples <br /></td></tr>
<tr class="separator:ab9508a4ced376133f70e35204cb08d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0b882490d61becdf4e409fe3cc771a"><td class="memItemLeft" align="right" valign="top"><a id="a2c0b882490d61becdf4e409fe3cc771a"></a>
virtual const IntResponseMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a2c0b882490d61becdf4e409fe3cc771a">all_responses</a> () const</td></tr>
<tr class="memdesc:a2c0b882490d61becdf4e409fe3cc771a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the complete set of computed responses <br /></td></tr>
<tr class="separator:a2c0b882490d61becdf4e409fe3cc771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27577c3595ab5a70c2ed8b4d7f4a1cc1"><td class="memItemLeft" align="right" valign="top"><a id="a27577c3595ab5a70c2ed8b4d7f4a1cc1"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a27577c3595ab5a70c2ed8b4d7f4a1cc1">num_samples</a> () const</td></tr>
<tr class="memdesc:a27577c3595ab5a70c2ed8b4d7f4a1cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current number of samples <br /></td></tr>
<tr class="separator:a27577c3595ab5a70c2ed8b4d7f4a1cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac539ee8a0a09068409fff22998d1e478"><td class="memItemLeft" align="right" valign="top"><a id="ac539ee8a0a09068409fff22998d1e478"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ac539ee8a0a09068409fff22998d1e478">sampling_reset</a> (size_t min_samples, bool all_data_flag, bool stats_flag)</td></tr>
<tr class="memdesc:ac539ee8a0a09068409fff22998d1e478"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset sampling iterator to use at least min_samples <br /></td></tr>
<tr class="separator:ac539ee8a0a09068409fff22998d1e478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dd22c2a8a380733ab8a36d1f6162c9"><td class="memItemLeft" align="right" valign="top"><a id="a30dd22c2a8a380733ab8a36d1f6162c9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a30dd22c2a8a380733ab8a36d1f6162c9">sampling_reference</a> (size_t samples_ref)</td></tr>
<tr class="memdesc:a30dd22c2a8a380733ab8a36d1f6162c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set reference number of samples, which is a lower bound during reset <br /></td></tr>
<tr class="separator:a30dd22c2a8a380733ab8a36d1f6162c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d459b546354ed714fa610bd2ff308d"><td class="memItemLeft" align="right" valign="top"><a id="ac0d459b546354ed714fa610bd2ff308d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ac0d459b546354ed714fa610bd2ff308d">sampling_increment</a> ()</td></tr>
<tr class="memdesc:ac0d459b546354ed714fa610bd2ff308d"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment to next in sequence of refinement samples <br /></td></tr>
<tr class="separator:ac0d459b546354ed714fa610bd2ff308d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e1fea7b605a45d5bdcbc9f06c64df3"><td class="memItemLeft" align="right" valign="top"><a id="a16e1fea7b605a45d5bdcbc9f06c64df3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a16e1fea7b605a45d5bdcbc9f06c64df3">random_seed</a> (int seed)</td></tr>
<tr class="memdesc:a16e1fea7b605a45d5bdcbc9f06c64df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">set randomSeed, if present <br /></td></tr>
<tr class="separator:a16e1fea7b605a45d5bdcbc9f06c64df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa08435cf362f79bc890495df22a0813"><td class="memItemLeft" align="right" valign="top"><a id="aaa08435cf362f79bc890495df22a0813"></a>
virtual unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aaa08435cf362f79bc890495df22a0813">sampling_scheme</a> () const</td></tr>
<tr class="memdesc:aaa08435cf362f79bc890495df22a0813"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sampling name <br /></td></tr>
<tr class="separator:aaa08435cf362f79bc890495df22a0813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad143dfc5c78e1cff1483fb18b44ccfc8"><td class="memItemLeft" align="right" valign="top"><a id="ad143dfc5c78e1cff1483fb18b44ccfc8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ad143dfc5c78e1cff1483fb18b44ccfc8">compact_mode</a> () const</td></tr>
<tr class="memdesc:ad143dfc5c78e1cff1483fb18b44ccfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classDakota_1_1Analyzer.html#a9ba37de3b25fbbc58b85cf01d8f7df80" title="switch for allSamples (compact mode) instead of allVariables (normal mode)">Analyzer::compactMode</a> <br /></td></tr>
<tr class="separator:ad143dfc5c78e1cff1483fb18b44ccfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed0572b4666dcd0615fad9de1b8fa33"><td class="memItemLeft" align="right" valign="top"><a id="a0ed0572b4666dcd0615fad9de1b8fa33"></a>
virtual IntIntPair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a0ed0572b4666dcd0615fad9de1b8fa33">estimate_partition_bounds</a> ()</td></tr>
<tr class="memdesc:a0ed0572b4666dcd0615fad9de1b8fa33"><td class="mdescLeft">&#160;</td><td class="mdescRight">estimate the minimum and maximum partition sizes that can be utilized by this <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> <br /></td></tr>
<tr class="separator:a0ed0572b4666dcd0615fad9de1b8fa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8c40b3cee982c73152b661f079e3c4"><td class="memItemLeft" align="right" valign="top"><a id="a6f8c40b3cee982c73152b661f079e3c4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a6f8c40b3cee982c73152b661f079e3c4">resize</a> ()</td></tr>
<tr class="memdesc:a6f8c40b3cee982c73152b661f079e3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">reinitializes iterator based on new variable size <br /></td></tr>
<tr class="separator:a6f8c40b3cee982c73152b661f079e3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182bc534595be016df0db08c6c3393ba"><td class="memItemLeft" align="right" valign="top"><a id="a182bc534595be016df0db08c6c3393ba"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a182bc534595be016df0db08c6c3393ba">declare_sources</a> ()</td></tr>
<tr class="memdesc:a182bc534595be016df0db08c6c3393ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare sources to the evaluations database. <br /></td></tr>
<tr class="separator:a182bc534595be016df0db08c6c3393ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9504dc18cfe37e47c8ced284bbaade"><td class="memItemLeft" align="right" valign="top"><a id="a8c9504dc18cfe37e47c8ced284bbaade"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a8c9504dc18cfe37e47c8ced284bbaade">init_communicators</a> (ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:a8c9504dc18cfe37e47c8ced284bbaade"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the communicators associated with this <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> instance <br /></td></tr>
<tr class="separator:a8c9504dc18cfe37e47c8ced284bbaade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a2988e8289ea23b5ef6a9f75335493"><td class="memItemLeft" align="right" valign="top"><a id="a23a2988e8289ea23b5ef6a9f75335493"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a23a2988e8289ea23b5ef6a9f75335493">set_communicators</a> (ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:a23a2988e8289ea23b5ef6a9f75335493"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the communicators associated with this <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> instance <br /></td></tr>
<tr class="separator:a23a2988e8289ea23b5ef6a9f75335493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b321b6a360f66235a6aff7352f67061"><td class="memItemLeft" align="right" valign="top"><a id="a6b321b6a360f66235a6aff7352f67061"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a6b321b6a360f66235a6aff7352f67061">free_communicators</a> (ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:a6b321b6a360f66235a6aff7352f67061"><td class="mdescLeft">&#160;</td><td class="mdescRight">free the communicators associated with this <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> instance <br /></td></tr>
<tr class="separator:a6b321b6a360f66235a6aff7352f67061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f57321282ae3e2d47dddb807166cd4e"><td class="memItemLeft" align="right" valign="top"><a id="a3f57321282ae3e2d47dddb807166cd4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a3f57321282ae3e2d47dddb807166cd4e">resize_communicators</a> (ParLevLIter pl_iter, bool reinit_comms)</td></tr>
<tr class="memdesc:a3f57321282ae3e2d47dddb807166cd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the communicators. This is called from the letter's <a class="el" href="classDakota_1_1Iterator.html#a6f8c40b3cee982c73152b661f079e3c4" title="reinitializes iterator based on new variable size">resize()</a> <br /></td></tr>
<tr class="separator:a3f57321282ae3e2d47dddb807166cd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab518b3a2ea4d970f279fac0cdd0d9779"><td class="memItemLeft" align="right" valign="top"><a id="ab518b3a2ea4d970f279fac0cdd0d9779"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ab518b3a2ea4d970f279fac0cdd0d9779">parallel_configuration_iterator</a> (ParConfigLIter pc_iter)</td></tr>
<tr class="memdesc:ab518b3a2ea4d970f279fac0cdd0d9779"><td class="mdescLeft">&#160;</td><td class="mdescRight">set methodPCIter <br /></td></tr>
<tr class="separator:ab518b3a2ea4d970f279fac0cdd0d9779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8fb81960ddd2dbe707241912f37e1b"><td class="memItemLeft" align="right" valign="top"><a id="a7c8fb81960ddd2dbe707241912f37e1b"></a>
ParConfigLIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a7c8fb81960ddd2dbe707241912f37e1b">parallel_configuration_iterator</a> () const</td></tr>
<tr class="memdesc:a7c8fb81960ddd2dbe707241912f37e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return methodPCIter <br /></td></tr>
<tr class="separator:a7c8fb81960ddd2dbe707241912f37e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce81946b81617eddf850232b58e2e72"><td class="memItemLeft" align="right" valign="top"><a id="adce81946b81617eddf850232b58e2e72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#adce81946b81617eddf850232b58e2e72">parallel_configuration_iterator_map</a> (std::map&lt; size_t, ParConfigLIter &gt; pci_map)</td></tr>
<tr class="memdesc:adce81946b81617eddf850232b58e2e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">set methodPCIterMap <br /></td></tr>
<tr class="separator:adce81946b81617eddf850232b58e2e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10de9d321a3f3b2b87d143342f78e99"><td class="memItemLeft" align="right" valign="top"><a id="af10de9d321a3f3b2b87d143342f78e99"></a>
std::map&lt; size_t, ParConfigLIter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#af10de9d321a3f3b2b87d143342f78e99">parallel_configuration_iterator_map</a> () const</td></tr>
<tr class="memdesc:af10de9d321a3f3b2b87d143342f78e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">return methodPCIterMap <br /></td></tr>
<tr class="separator:af10de9d321a3f3b2b87d143342f78e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cf4e7fbd96f3bccdcac2267be56e79"><td class="memItemLeft" align="right" valign="top"><a id="a92cf4e7fbd96f3bccdcac2267be56e79"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a92cf4e7fbd96f3bccdcac2267be56e79">run</a> (ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:a92cf4e7fbd96f3bccdcac2267be56e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke set_communicators(pl_iter) prior to <a class="el" href="classDakota_1_1Iterator.html#a13a43e6d814de94978c515cb084873b1" title="orchestrate initialize/pre/core/post/finalize phases">run()</a> <br /></td></tr>
<tr class="separator:a92cf4e7fbd96f3bccdcac2267be56e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a43e6d814de94978c515cb084873b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a13a43e6d814de94978c515cb084873b1">run</a> ()</td></tr>
<tr class="memdesc:a13a43e6d814de94978c515cb084873b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">orchestrate initialize/pre/core/post/finalize phases  <a href="classDakota_1_1Iterator.html#a13a43e6d814de94978c515cb084873b1">More...</a><br /></td></tr>
<tr class="separator:a13a43e6d814de94978c515cb084873b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d7442555917525fc1b189f40e9627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a7f7d7442555917525fc1b189f40e9627">assign_rep</a> (std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; <a class="el" href="classDakota_1_1Iterator.html#a960845f69232cbefef30a3fc32c46525">iterator_rep</a>)</td></tr>
<tr class="memdesc:a7f7d7442555917525fc1b189f40e9627"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaces existing letter with a new one  <a href="classDakota_1_1Iterator.html#a7f7d7442555917525fc1b189f40e9627">More...</a><br /></td></tr>
<tr class="separator:a7f7d7442555917525fc1b189f40e9627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe51a16e1464a78de98bb653efe48525"><td class="memItemLeft" align="right" valign="top"><a id="abe51a16e1464a78de98bb653efe48525"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#abe51a16e1464a78de98bb653efe48525">iterated_model</a> (const <a class="el" href="classDakota_1_1Model.html">Model</a> &amp;model)</td></tr>
<tr class="memdesc:abe51a16e1464a78de98bb653efe48525"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the iteratedModel (iterators and meta-iterators using a single model instance) <br /></td></tr>
<tr class="separator:abe51a16e1464a78de98bb653efe48525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5eac354d52406da5f6bdb862ee5d68"><td class="memItemLeft" align="right" valign="top"><a id="aff5eac354d52406da5f6bdb862ee5d68"></a>
<a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aff5eac354d52406da5f6bdb862ee5d68">iterated_model</a> ()</td></tr>
<tr class="memdesc:aff5eac354d52406da5f6bdb862ee5d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the iteratedModel (iterators &amp; meta-iterators using a single model instance) <br /></td></tr>
<tr class="separator:aff5eac354d52406da5f6bdb862ee5d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c8d03d2a72807624d23fd0dc3fe452"><td class="memItemLeft" align="right" valign="top"><a id="a85c8d03d2a72807624d23fd0dc3fe452"></a>
<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a85c8d03d2a72807624d23fd0dc3fe452">problem_description_db</a> () const</td></tr>
<tr class="memdesc:a85c8d03d2a72807624d23fd0dc3fe452"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the problem description database (probDescDB) <br /></td></tr>
<tr class="separator:a85c8d03d2a72807624d23fd0dc3fe452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f76fe374730676eb9181a3cc425e41"><td class="memItemLeft" align="right" valign="top"><a id="ac3f76fe374730676eb9181a3cc425e41"></a>
<a class="el" href="classDakota_1_1ParallelLibrary.html">ParallelLibrary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ac3f76fe374730676eb9181a3cc425e41">parallel_library</a> () const</td></tr>
<tr class="memdesc:ac3f76fe374730676eb9181a3cc425e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the parallel library (parallelLib) <br /></td></tr>
<tr class="separator:ac3f76fe374730676eb9181a3cc425e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f6c96808d09fa4a881e70ea5752aee"><td class="memItemLeft" align="right" valign="top"><a id="ae9f6c96808d09fa4a881e70ea5752aee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ae9f6c96808d09fa4a881e70ea5752aee">method_name</a> (unsigned short m_name)</td></tr>
<tr class="memdesc:ae9f6c96808d09fa4a881e70ea5752aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the method name to an enumeration value <br /></td></tr>
<tr class="separator:ae9f6c96808d09fa4a881e70ea5752aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb0ca7f340b3b8a6ac4f58ec2101ff8"><td class="memItemLeft" align="right" valign="top"><a id="aecb0ca7f340b3b8a6ac4f58ec2101ff8"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aecb0ca7f340b3b8a6ac4f58ec2101ff8">method_name</a> () const</td></tr>
<tr class="memdesc:aecb0ca7f340b3b8a6ac4f58ec2101ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the method name via its native enumeration value <br /></td></tr>
<tr class="separator:aecb0ca7f340b3b8a6ac4f58ec2101ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dc13c14c38573c2fe361b091568bd1"><td class="memItemLeft" align="right" valign="top"><a id="a71dc13c14c38573c2fe361b091568bd1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a71dc13c14c38573c2fe361b091568bd1">method_string</a> (const String &amp;m_str)</td></tr>
<tr class="memdesc:a71dc13c14c38573c2fe361b091568bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the method name by string <br /></td></tr>
<tr class="separator:a71dc13c14c38573c2fe361b091568bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a74249485a0713c57bf28869270a86"><td class="memItemLeft" align="right" valign="top"><a id="ac6a74249485a0713c57bf28869270a86"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ac6a74249485a0713c57bf28869270a86">method_string</a> () const</td></tr>
<tr class="memdesc:ac6a74249485a0713c57bf28869270a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the method name by string <br /></td></tr>
<tr class="separator:ac6a74249485a0713c57bf28869270a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ff02f762983acda51874c5102054f3"><td class="memItemLeft" align="right" valign="top"><a id="ab6ff02f762983acda51874c5102054f3"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ab6ff02f762983acda51874c5102054f3">method_enum_to_string</a> (unsigned short method_enum) const</td></tr>
<tr class="memdesc:ab6ff02f762983acda51874c5102054f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a method name enumeration value to a string <br /></td></tr>
<tr class="separator:ab6ff02f762983acda51874c5102054f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbeb9c83e952d160d5f4c6ac642971f0"><td class="memItemLeft" align="right" valign="top"><a id="afbeb9c83e952d160d5f4c6ac642971f0"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#afbeb9c83e952d160d5f4c6ac642971f0">method_string_to_enum</a> (const String &amp;method_str) const</td></tr>
<tr class="memdesc:afbeb9c83e952d160d5f4c6ac642971f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a method name string to an enumeration value <br /></td></tr>
<tr class="separator:afbeb9c83e952d160d5f4c6ac642971f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34bf999ea9daea4224368911cc16af5"><td class="memItemLeft" align="right" valign="top"><a id="ad34bf999ea9daea4224368911cc16af5"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ad34bf999ea9daea4224368911cc16af5">submethod_enum_to_string</a> (unsigned short submethod_enum) const</td></tr>
<tr class="memdesc:ad34bf999ea9daea4224368911cc16af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a sub-method name enumeration value to a string <br /></td></tr>
<tr class="separator:ad34bf999ea9daea4224368911cc16af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64064d7c4403ee54d8baf573bae29cc6"><td class="memItemLeft" align="right" valign="top"><a id="a64064d7c4403ee54d8baf573bae29cc6"></a>
const String &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a64064d7c4403ee54d8baf573bae29cc6">method_id</a> () const</td></tr>
<tr class="memdesc:a64064d7c4403ee54d8baf573bae29cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the method identifier (methodId) <br /></td></tr>
<tr class="separator:a64064d7c4403ee54d8baf573bae29cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af574c51ff1ee5be0a2c885e851f632d5"><td class="memItemLeft" align="right" valign="top"><a id="af574c51ff1ee5be0a2c885e851f632d5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#af574c51ff1ee5be0a2c885e851f632d5">maximum_evaluation_concurrency</a> () const</td></tr>
<tr class="memdesc:af574c51ff1ee5be0a2c885e851f632d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximum evaluation concurrency supported by the iterator <br /></td></tr>
<tr class="separator:af574c51ff1ee5be0a2c885e851f632d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982637ca9a86a4b7aded8cfc45f10d47"><td class="memItemLeft" align="right" valign="top"><a id="a982637ca9a86a4b7aded8cfc45f10d47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a982637ca9a86a4b7aded8cfc45f10d47">maximum_evaluation_concurrency</a> (int max_conc)</td></tr>
<tr class="memdesc:a982637ca9a86a4b7aded8cfc45f10d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the maximum evaluation concurrency supported by the iterator <br /></td></tr>
<tr class="separator:a982637ca9a86a4b7aded8cfc45f10d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126671a142392ad27b26c596a86463e6"><td class="memItemLeft" align="right" valign="top"><a id="a126671a142392ad27b26c596a86463e6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a126671a142392ad27b26c596a86463e6">maximum_iterations</a> () const</td></tr>
<tr class="memdesc:a126671a142392ad27b26c596a86463e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximum iterations for this iterator <br /></td></tr>
<tr class="separator:a126671a142392ad27b26c596a86463e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4bff2ea3472240672ec386612a88d6"><td class="memItemLeft" align="right" valign="top"><a id="acd4bff2ea3472240672ec386612a88d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#acd4bff2ea3472240672ec386612a88d6">maximum_iterations</a> (size_t max_iter)</td></tr>
<tr class="memdesc:acd4bff2ea3472240672ec386612a88d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the maximum iterations for this iterator <br /></td></tr>
<tr class="separator:acd4bff2ea3472240672ec386612a88d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582c18acb50c8685933831194a5669ab"><td class="memItemLeft" align="right" valign="top"><a id="a582c18acb50c8685933831194a5669ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a582c18acb50c8685933831194a5669ab">convergence_tolerance</a> (Real conv_tol)</td></tr>
<tr class="memdesc:a582c18acb50c8685933831194a5669ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the method convergence tolerance (convergenceTol) <br /></td></tr>
<tr class="separator:a582c18acb50c8685933831194a5669ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd66aa09f7c69c1bd66ed07e5b1eebb"><td class="memItemLeft" align="right" valign="top"><a id="a6bd66aa09f7c69c1bd66ed07e5b1eebb"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a6bd66aa09f7c69c1bd66ed07e5b1eebb">convergence_tolerance</a> () const</td></tr>
<tr class="memdesc:a6bd66aa09f7c69c1bd66ed07e5b1eebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the method convergence tolerance (convergenceTol) <br /></td></tr>
<tr class="separator:a6bd66aa09f7c69c1bd66ed07e5b1eebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff86d18d46a729d449d46d56bc0fba1"><td class="memItemLeft" align="right" valign="top"><a id="a2ff86d18d46a729d449d46d56bc0fba1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a2ff86d18d46a729d449d46d56bc0fba1">output_level</a> (short out_lev)</td></tr>
<tr class="memdesc:a2ff86d18d46a729d449d46d56bc0fba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the method output level (outputLevel) <br /></td></tr>
<tr class="separator:a2ff86d18d46a729d449d46d56bc0fba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0435adbf60203414e018861267c60766"><td class="memItemLeft" align="right" valign="top"><a id="a0435adbf60203414e018861267c60766"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a0435adbf60203414e018861267c60766">output_level</a> () const</td></tr>
<tr class="memdesc:a0435adbf60203414e018861267c60766"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the method output level (outputLevel) <br /></td></tr>
<tr class="separator:a0435adbf60203414e018861267c60766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b6b0b62a5279abf756758ef7feffe"><td class="memItemLeft" align="right" valign="top"><a id="a844b6b0b62a5279abf756758ef7feffe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a844b6b0b62a5279abf756758ef7feffe">summary_output</a> (bool summary_output_flag)</td></tr>
<tr class="memdesc:a844b6b0b62a5279abf756758ef7feffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set summary output control; true enables evaluation/results summary. <br /></td></tr>
<tr class="separator:a844b6b0b62a5279abf756758ef7feffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6871e01be3fa85362ace9dee57b2255c"><td class="memItemLeft" align="right" valign="top"><a id="a6871e01be3fa85362ace9dee57b2255c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a6871e01be3fa85362ace9dee57b2255c">num_final_solutions</a> () const</td></tr>
<tr class="memdesc:a6871e01be3fa85362ace9dee57b2255c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of solutions to retain in best variables/response arrays <br /></td></tr>
<tr class="separator:a6871e01be3fa85362ace9dee57b2255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be4c5bc15e7a0152b3f65338890c383"><td class="memItemLeft" align="right" valign="top"><a id="a0be4c5bc15e7a0152b3f65338890c383"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a0be4c5bc15e7a0152b3f65338890c383">num_final_solutions</a> (size_t num_final)</td></tr>
<tr class="memdesc:a0be4c5bc15e7a0152b3f65338890c383"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the number of solutions to retain in best variables/response arrays <br /></td></tr>
<tr class="separator:a0be4c5bc15e7a0152b3f65338890c383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8418192696c66abb08f8f4480fb33495"><td class="memItemLeft" align="right" valign="top"><a id="a8418192696c66abb08f8f4480fb33495"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a8418192696c66abb08f8f4480fb33495">active_set</a> (const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;set)</td></tr>
<tr class="memdesc:a8418192696c66abb08f8f4480fb33495"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the default active set (for use with iterators that employ evaluate_parameter_sets()) <br /></td></tr>
<tr class="separator:a8418192696c66abb08f8f4480fb33495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbe39c5d0441f94ad5f96cd2cef6676"><td class="memItemLeft" align="right" valign="top"><a id="adfbe39c5d0441f94ad5f96cd2cef6676"></a>
const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#adfbe39c5d0441f94ad5f96cd2cef6676">active_set</a> () const</td></tr>
<tr class="memdesc:adfbe39c5d0441f94ad5f96cd2cef6676"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the default active set (used by iterators that employ evaluate_parameter_sets()) <br /></td></tr>
<tr class="separator:adfbe39c5d0441f94ad5f96cd2cef6676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b19942816fde7f17c232ce083b7b98"><td class="memItemLeft" align="right" valign="top"><a id="af6b19942816fde7f17c232ce083b7b98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#af6b19942816fde7f17c232ce083b7b98">active_set_request_vector</a> (const ShortArray &amp;asv)</td></tr>
<tr class="memdesc:af6b19942816fde7f17c232ce083b7b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the default active set request vector (used by iterators that employ evaluate_parameter_sets()) <br /></td></tr>
<tr class="separator:af6b19942816fde7f17c232ce083b7b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87564bbb1f5fe32acd22e4689dc649"><td class="memItemLeft" align="right" valign="top"><a id="a8b87564bbb1f5fe32acd22e4689dc649"></a>
const ShortArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a8b87564bbb1f5fe32acd22e4689dc649">active_set_request_vector</a> () const</td></tr>
<tr class="memdesc:a8b87564bbb1f5fe32acd22e4689dc649"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the default active set request vector (used by iterators that employ evaluate_parameter_sets()) <br /></td></tr>
<tr class="separator:a8b87564bbb1f5fe32acd22e4689dc649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357c13c83af2af378f7842726a53f608"><td class="memItemLeft" align="right" valign="top"><a id="a357c13c83af2af378f7842726a53f608"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a357c13c83af2af378f7842726a53f608">active_set_request_values</a> (short asv_val)</td></tr>
<tr class="memdesc:a357c13c83af2af378f7842726a53f608"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the default active set request vector (used by iterators that employ evaluate_parameter_sets()) <br /></td></tr>
<tr class="separator:a357c13c83af2af378f7842726a53f608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04599cddb9969566dda578530d0c174c"><td class="memItemLeft" align="right" valign="top"><a id="a04599cddb9969566dda578530d0c174c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a04599cddb9969566dda578530d0c174c">sub_iterator_flag</a> (bool si_flag)</td></tr>
<tr class="memdesc:a04599cddb9969566dda578530d0c174c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set subIteratorFlag (and update summaryOutputFlag if needed) <br /></td></tr>
<tr class="separator:a04599cddb9969566dda578530d0c174c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e61d2bb6c2a58d7b98180555af09e4"><td class="memItemLeft" align="right" valign="top"><a id="a54e61d2bb6c2a58d7b98180555af09e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a54e61d2bb6c2a58d7b98180555af09e4">is_null</a> () const</td></tr>
<tr class="memdesc:a54e61d2bb6c2a58d7b98180555af09e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to check iteratorRep (does this envelope contain a letter?) <br /></td></tr>
<tr class="separator:a54e61d2bb6c2a58d7b98180555af09e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960845f69232cbefef30a3fc32c46525"><td class="memItemLeft" align="right" valign="top"><a id="a960845f69232cbefef30a3fc32c46525"></a>
std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a960845f69232cbefef30a3fc32c46525">iterator_rep</a> () const</td></tr>
<tr class="memdesc:a960845f69232cbefef30a3fc32c46525"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns iteratorRep for access to derived class member functions that are not mapped to the top <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> level <br /></td></tr>
<tr class="separator:a960845f69232cbefef30a3fc32c46525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fda5e4a6ba09115a83fd970ae39d5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ab4fda5e4a6ba09115a83fd970ae39d5a">eval_tag_prefix</a> (const String &amp;eval_id_str)</td></tr>
<tr class="memdesc:ab4fda5e4a6ba09115a83fd970ae39d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the hierarchical eval ID tag prefix  <a href="classDakota_1_1Iterator.html#ab4fda5e4a6ba09115a83fd970ae39d5a">More...</a><br /></td></tr>
<tr class="separator:ab4fda5e4a6ba09115a83fd970ae39d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d501757155de544e19b12f2b45dcead"><td class="memItemLeft" align="right" valign="top"><a id="a7d501757155de544e19b12f2b45dcead"></a>
std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a7d501757155de544e19b12f2b45dcead">traits</a> () const</td></tr>
<tr class="memdesc:a7d501757155de544e19b12f2b45dcead"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns methodTraits for access to derived class member functions that are not mapped to the top <a class="el" href="classDakota_1_1TraitsBase.html" title="Base class for traits.">TraitsBase</a> level <br /></td></tr>
<tr class="separator:a7d501757155de544e19b12f2b45dcead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb082ff394483602db543e6a7acb3f35"><td class="memItemLeft" align="right" valign="top"><a id="abb082ff394483602db543e6a7acb3f35"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#abb082ff394483602db543e6a7acb3f35">top_level</a> ()</td></tr>
<tr class="memdesc:abb082ff394483602db543e6a7acb3f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the iterator is the top level iterator. <br /></td></tr>
<tr class="separator:abb082ff394483602db543e6a7acb3f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66aed52d50c7a1aee737dc15f7f72e0"><td class="memItemLeft" align="right" valign="top"><a id="af66aed52d50c7a1aee737dc15f7f72e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#af66aed52d50c7a1aee737dc15f7f72e0">top_level</a> (bool tflag)</td></tr>
<tr class="memdesc:af66aed52d50c7a1aee737dc15f7f72e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator's top level flag. <br /></td></tr>
<tr class="separator:af66aed52d50c7a1aee737dc15f7f72e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6ac42595c73c833561ab0778ac178cea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a6ac42595c73c833561ab0778ac178cea">Iterator</a> (<a class="el" href="structDakota_1_1BaseConstructor.html">BaseConstructor</a>, <a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt; <a class="el" href="classDakota_1_1Iterator.html#a7d501757155de544e19b12f2b45dcead">traits</a>=std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;(new <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>()))</td></tr>
<tr class="memdesc:a6ac42595c73c833561ab0778ac178cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor initializes the base class part of letter classes (<a class="el" href="structDakota_1_1BaseConstructor.html" title="Dummy struct for overloading letter-envelope constructors.">BaseConstructor</a> overloading avoids infinite recursion in the derived class constructors - Coplien, p. 139)  <a href="classDakota_1_1Iterator.html#a6ac42595c73c833561ab0778ac178cea">More...</a><br /></td></tr>
<tr class="separator:a6ac42595c73c833561ab0778ac178cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee857e558ed33f22b9d173a7eabef8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a5ee857e558ed33f22b9d173a7eabef8d">Iterator</a> (<a class="el" href="structDakota_1_1NoDBBaseConstructor.html">NoDBBaseConstructor</a>, unsigned short <a class="el" href="classDakota_1_1Iterator.html#ae9f6c96808d09fa4a881e70ea5752aee">method_name</a>, <a class="el" href="classDakota_1_1Model.html">Model</a> &amp;model, std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt; <a class="el" href="classDakota_1_1Iterator.html#a7d501757155de544e19b12f2b45dcead">traits</a>=std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;(new <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>()))</td></tr>
<tr class="memdesc:a5ee857e558ed33f22b9d173a7eabef8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">alternate constructor for base iterator classes constructed on the fly  <a href="classDakota_1_1Iterator.html#a5ee857e558ed33f22b9d173a7eabef8d">More...</a><br /></td></tr>
<tr class="separator:a5ee857e558ed33f22b9d173a7eabef8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1d5defc27cba31425e427ba4c6e8fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#abd1d5defc27cba31425e427ba4c6e8fe">Iterator</a> (<a class="el" href="structDakota_1_1NoDBBaseConstructor.html">NoDBBaseConstructor</a>, unsigned short <a class="el" href="classDakota_1_1Iterator.html#ae9f6c96808d09fa4a881e70ea5752aee">method_name</a>, std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt; <a class="el" href="classDakota_1_1Iterator.html#a7d501757155de544e19b12f2b45dcead">traits</a>=std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;(new <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>()))</td></tr>
<tr class="memdesc:abd1d5defc27cba31425e427ba4c6e8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">alternate constructor for base iterator classes constructed on the fly  <a href="classDakota_1_1Iterator.html#abd1d5defc27cba31425e427ba4c6e8fe">More...</a><br /></td></tr>
<tr class="separator:abd1d5defc27cba31425e427ba4c6e8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf83d073662105b6211a5befe46ae718"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aaf83d073662105b6211a5befe46ae718">Iterator</a> (<a class="el" href="structDakota_1_1NoDBBaseConstructor.html">NoDBBaseConstructor</a>, <a class="el" href="classDakota_1_1Model.html">Model</a> &amp;model, size_t max_iter, size_t max_eval, Real conv_tol, std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt; <a class="el" href="classDakota_1_1Iterator.html#a7d501757155de544e19b12f2b45dcead">traits</a>=std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;(new <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>()))</td></tr>
<tr class="memdesc:aaf83d073662105b6211a5befe46ae718"><td class="mdescLeft">&#160;</td><td class="mdescRight">alternate envelope constructor for instantiations without <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a>  <a href="classDakota_1_1Iterator.html#aaf83d073662105b6211a5befe46ae718">More...</a><br /></td></tr>
<tr class="separator:aaf83d073662105b6211a5befe46ae718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707a74f84dfc750d57af34e048c3486f"><td class="memItemLeft" align="right" valign="top"><a id="a707a74f84dfc750d57af34e048c3486f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a707a74f84dfc750d57af34e048c3486f">derived_init_communicators</a> (ParLevLIter pl_iter)</td></tr>
<tr class="memdesc:a707a74f84dfc750d57af34e048c3486f"><td class="mdescLeft">&#160;</td><td class="mdescRight">derived class contributions to initializing the communicators associated with this <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> instance <br /></td></tr>
<tr class="separator:a707a74f84dfc750d57af34e048c3486f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42069156a27a9b284d798357dea97787"><td class="memItemLeft" align="right" valign="top"><a id="a42069156a27a9b284d798357dea97787"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a42069156a27a9b284d798357dea97787">update_from_model</a> (const <a class="el" href="classDakota_1_1Model.html">Model</a> &amp;model)</td></tr>
<tr class="memdesc:a42069156a27a9b284d798357dea97787"><td class="mdescLeft">&#160;</td><td class="mdescRight">set inherited data attributes based on extractions from incoming model <br /></td></tr>
<tr class="separator:a42069156a27a9b284d798357dea97787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69324998b59c1b847a4ee6d7fdb08888"><td class="memItemLeft" align="right" valign="top"><a id="a69324998b59c1b847a4ee6d7fdb08888"></a>
virtual const VariablesArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a69324998b59c1b847a4ee6d7fdb08888">initial_points</a> () const</td></tr>
<tr class="memdesc:a69324998b59c1b847a4ee6d7fdb08888"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the multiple initial points for this iterator. This will only be meaningful after a call to initial_points mutator. <br /></td></tr>
<tr class="separator:a69324998b59c1b847a4ee6d7fdb08888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c730cc9858fc41031f903e4dc14c4f"><td class="memItemLeft" align="right" valign="top"><a id="a68c730cc9858fc41031f903e4dc14c4f"></a>
<a class="el" href="namespaceDakota.html#ab927210af660acb4d00b336f6bb25c32">StrStrSizet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a68c730cc9858fc41031f903e4dc14c4f">run_identifier</a> () const</td></tr>
<tr class="memdesc:a68c730cc9858fc41031f903e4dc14c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the unique run identifier based on method name, id, and number of executions <br /></td></tr>
<tr class="separator:a68c730cc9858fc41031f903e4dc14c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f894ca56d2c8cb3f951269e3d09884d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a7f894ca56d2c8cb3f951269e3d09884d">initialize_model_graphics</a> (<a class="el" href="classDakota_1_1Model.html">Model</a> &amp;model, int iterator_server_id)</td></tr>
<tr class="memdesc:a7f894ca56d2c8cb3f951269e3d09884d"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function that encapsulates initialization operations, modular on incoming <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> instance  <a href="classDakota_1_1Iterator.html#a7f894ca56d2c8cb3f951269e3d09884d">More...</a><br /></td></tr>
<tr class="separator:a7f894ca56d2c8cb3f951269e3d09884d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba1ace5c0bc19120ea32209524e7342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#abba1ace5c0bc19120ea32209524e7342">export_final_surrogates</a> (<a class="el" href="classDakota_1_1Model.html">Model</a> &amp;data_fit_surr_model)</td></tr>
<tr class="memdesc:abba1ace5c0bc19120ea32209524e7342"><td class="mdescLeft">&#160;</td><td class="mdescRight">export final surrogates generated, e.g., GP in EGO and friends  <a href="classDakota_1_1Iterator.html#abba1ace5c0bc19120ea32209524e7342">More...</a><br /></td></tr>
<tr class="separator:abba1ace5c0bc19120ea32209524e7342"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a98a7fcf8c458c9ccfa7335713ff90067"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a98a7fcf8c458c9ccfa7335713ff90067">gnewton_set_recast</a> (const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;recast_vars, const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;recast_set, <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;sub_model_set)</td></tr>
<tr class="memdesc:a98a7fcf8c458c9ccfa7335713ff90067"><td class="mdescLeft">&#160;</td><td class="mdescRight">conversion of request vector values for the Gauss-Newton Hessian approximation  <a href="classDakota_1_1Iterator.html#a98a7fcf8c458c9ccfa7335713ff90067">More...</a><br /></td></tr>
<tr class="separator:a98a7fcf8c458c9ccfa7335713ff90067"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac8b1ee0aacc0b1693fb2c317a4388b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ac8b1ee0aacc0b1693fb2c317a4388b46">probDescDB</a></td></tr>
<tr class="memdesc:ac8b1ee0aacc0b1693fb2c317a4388b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">class member reference to the problem description database  <a href="classDakota_1_1Iterator.html#ac8b1ee0aacc0b1693fb2c317a4388b46">More...</a><br /></td></tr>
<tr class="separator:ac8b1ee0aacc0b1693fb2c317a4388b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702abf9be22e51f1e67167d5db1b08d3"><td class="memItemLeft" align="right" valign="top"><a id="a702abf9be22e51f1e67167d5db1b08d3"></a>
<a class="el" href="classDakota_1_1ParallelLibrary.html">ParallelLibrary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a702abf9be22e51f1e67167d5db1b08d3">parallelLib</a></td></tr>
<tr class="memdesc:a702abf9be22e51f1e67167d5db1b08d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">class member reference to the parallel library <br /></td></tr>
<tr class="separator:a702abf9be22e51f1e67167d5db1b08d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3689323b4938448e9250adcc3f2d0df7"><td class="memItemLeft" align="right" valign="top"><a id="a3689323b4938448e9250adcc3f2d0df7"></a>
ParConfigLIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a3689323b4938448e9250adcc3f2d0df7">methodPCIter</a></td></tr>
<tr class="memdesc:a3689323b4938448e9250adcc3f2d0df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">the active <a class="el" href="classDakota_1_1ParallelConfiguration.html" title="Container class for a set of ParallelLevel list iterators that collectively identify a particular mul...">ParallelConfiguration</a> used by this <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> instance <br /></td></tr>
<tr class="separator:a3689323b4938448e9250adcc3f2d0df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d92d85a575fee135731f788f4b15adf"><td class="memItemLeft" align="right" valign="top"><a id="a1d92d85a575fee135731f788f4b15adf"></a>
<a class="el" href="classDakota_1_1Model.html">Model</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a1d92d85a575fee135731f788f4b15adf">iteratedModel</a></td></tr>
<tr class="memdesc:a1d92d85a575fee135731f788f4b15adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">the model to be iterated (for iterators and meta-iterators employing a single model instance) <br /></td></tr>
<tr class="separator:a1d92d85a575fee135731f788f4b15adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d06d8da56b0579f8fa299e812807d7"><td class="memItemLeft" align="right" valign="top"><a id="aa8d06d8da56b0579f8fa299e812807d7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aa8d06d8da56b0579f8fa299e812807d7">myModelLayers</a></td></tr>
<tr class="memdesc:aa8d06d8da56b0579f8fa299e812807d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of Models locally (in <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> or derived classes) wrapped around the initially passed in <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> <br /></td></tr>
<tr class="separator:aa8d06d8da56b0579f8fa299e812807d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232e81b24a57f058b946705f9885a44a"><td class="memItemLeft" align="right" valign="top"><a id="a232e81b24a57f058b946705f9885a44a"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a232e81b24a57f058b946705f9885a44a">methodName</a></td></tr>
<tr class="memdesc:a232e81b24a57f058b946705f9885a44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">name of the iterator (the user's method spec) <br /></td></tr>
<tr class="separator:a232e81b24a57f058b946705f9885a44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa55b33af02e0710cef939a4b49c498"><td class="memItemLeft" align="right" valign="top"><a id="adfa55b33af02e0710cef939a4b49c498"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#adfa55b33af02e0710cef939a4b49c498">convergenceTol</a></td></tr>
<tr class="memdesc:adfa55b33af02e0710cef939a4b49c498"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteration convergence tolerance <br /></td></tr>
<tr class="separator:adfa55b33af02e0710cef939a4b49c498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3fa2e38847b23885acf3833f28538e"><td class="memItemLeft" align="right" valign="top"><a id="adb3fa2e38847b23885acf3833f28538e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#adb3fa2e38847b23885acf3833f28538e">maxIterations</a></td></tr>
<tr class="memdesc:adb3fa2e38847b23885acf3833f28538e"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of iterations for the method <br /></td></tr>
<tr class="separator:adb3fa2e38847b23885acf3833f28538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772b823c5878978abc5cd6985a9db3c2"><td class="memItemLeft" align="right" valign="top"><a id="a772b823c5878978abc5cd6985a9db3c2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a772b823c5878978abc5cd6985a9db3c2">maxFunctionEvals</a></td></tr>
<tr class="memdesc:a772b823c5878978abc5cd6985a9db3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of fn evaluations for the method <br /></td></tr>
<tr class="separator:a772b823c5878978abc5cd6985a9db3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2b07faf0a3a39201eebcfe83e3a5f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a7c2b07faf0a3a39201eebcfe83e3a5f7">maxEvalConcurrency</a></td></tr>
<tr class="memdesc:a7c2b07faf0a3a39201eebcfe83e3a5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of concurrent model evaluations  <a href="classDakota_1_1Iterator.html#a7c2b07faf0a3a39201eebcfe83e3a5f7">More...</a><br /></td></tr>
<tr class="separator:a7c2b07faf0a3a39201eebcfe83e3a5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c04b43c30a67e2bbbf6529b9617443e"><td class="memItemLeft" align="right" valign="top"><a id="a9c04b43c30a67e2bbbf6529b9617443e"></a>
<a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a9c04b43c30a67e2bbbf6529b9617443e">activeSet</a></td></tr>
<tr class="memdesc:a9c04b43c30a67e2bbbf6529b9617443e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the response data requirements on each function evaluation <br /></td></tr>
<tr class="separator:a9c04b43c30a67e2bbbf6529b9617443e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb375f251603904ac6f0f1d7d9834bb3"><td class="memItemLeft" align="right" valign="top"><a id="abb375f251603904ac6f0f1d7d9834bb3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#abb375f251603904ac6f0f1d7d9834bb3">numFinalSolutions</a></td></tr>
<tr class="memdesc:abb375f251603904ac6f0f1d7d9834bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of solutions to retain in best variables/response arrays <br /></td></tr>
<tr class="separator:abb375f251603904ac6f0f1d7d9834bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eeeeba8698193e8aede44ab8f9e53bb"><td class="memItemLeft" align="right" valign="top"><a id="a4eeeeba8698193e8aede44ab8f9e53bb"></a>
VariablesArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a4eeeeba8698193e8aede44ab8f9e53bb">bestVariablesArray</a></td></tr>
<tr class="memdesc:a4eeeeba8698193e8aede44ab8f9e53bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">collection of N best solution variables found during the study; always in context of <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> originally passed to the <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> (any in-flight Recasts must be undone) <br /></td></tr>
<tr class="separator:a4eeeeba8698193e8aede44ab8f9e53bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dc63cfa3c6899985509519ab36d32c"><td class="memItemLeft" align="right" valign="top"><a id="a03dc63cfa3c6899985509519ab36d32c"></a>
ResponseArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a03dc63cfa3c6899985509519ab36d32c">bestResponseArray</a></td></tr>
<tr class="memdesc:a03dc63cfa3c6899985509519ab36d32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">collection of N best solution responses found during the study; always in context of <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> originally passed to the <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> (any in-flight Recasts must be undone) <br /></td></tr>
<tr class="separator:a03dc63cfa3c6899985509519ab36d32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd67da3f37c661278b89126e7a9139a5"><td class="memItemLeft" align="right" valign="top"><a id="abd67da3f37c661278b89126e7a9139a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#abd67da3f37c661278b89126e7a9139a5">subIteratorFlag</a></td></tr>
<tr class="memdesc:abd67da3f37c661278b89126e7a9139a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag indicating if this <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> is a sub-iterator (<a class="el" href="classDakota_1_1NestedModel.html#a371facae40642e314c92b7b7d53c5f1c" title="the sub-iterator that is executed on every evaluation of this model">NestedModel::subIterator</a> or <a class="el" href="classDakota_1_1DataFitSurrModel.html#a50d54ed7a4765c565a031eb164c6d436" title="selects parameter sets on which to evaluate actualModel in order to generate the necessary data for b...">DataFitSurrModel::daceIterator</a>) <br /></td></tr>
<tr class="separator:abd67da3f37c661278b89126e7a9139a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b080aab3a786ee1439b43c3533f1f6a"><td class="memItemLeft" align="right" valign="top"><a id="a8b080aab3a786ee1439b43c3533f1f6a"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a8b080aab3a786ee1439b43c3533f1f6a">outputLevel</a></td></tr>
<tr class="memdesc:a8b080aab3a786ee1439b43c3533f1f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">output verbosity level: {SILENT,QUIET,NORMAL,VERBOSE,DEBUG}_OUTPUT <br /></td></tr>
<tr class="separator:a8b080aab3a786ee1439b43c3533f1f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3234db742661b4cedaf7a77b4e98b632"><td class="memItemLeft" align="right" valign="top"><a id="a3234db742661b4cedaf7a77b4e98b632"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a3234db742661b4cedaf7a77b4e98b632">summaryOutputFlag</a></td></tr>
<tr class="memdesc:a3234db742661b4cedaf7a77b4e98b632"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for summary output (evaluation stats, final results); default true, but false for on-the-fly (helper) iterators and sub-iterator use cases <br /></td></tr>
<tr class="separator:a3234db742661b4cedaf7a77b4e98b632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c39266da000ed7eb4a39e620ccf5bd"><td class="memItemLeft" align="right" valign="top"><a id="a51c39266da000ed7eb4a39e620ccf5bd"></a>
<a class="el" href="classDakota_1_1ResultsManager.html">ResultsManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a51c39266da000ed7eb4a39e620ccf5bd">resultsDB</a></td></tr>
<tr class="memdesc:a51c39266da000ed7eb4a39e620ccf5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to the global iterator results database <br /></td></tr>
<tr class="separator:a51c39266da000ed7eb4a39e620ccf5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e368a123f742a2a32e91285f8c0b764"><td class="memItemLeft" align="right" valign="top"><a id="a9e368a123f742a2a32e91285f8c0b764"></a>
EvaluationStore &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a9e368a123f742a2a32e91285f8c0b764">evaluationsDB</a></td></tr>
<tr class="memdesc:a9e368a123f742a2a32e91285f8c0b764"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to the global evaluation database <br /></td></tr>
<tr class="separator:a9e368a123f742a2a32e91285f8c0b764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f5878081a50c3b35ddae619a8337f5"><td class="memItemLeft" align="right" valign="top"><a id="a73f5878081a50c3b35ddae619a8337f5"></a>
EvaluationsDBState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a73f5878081a50c3b35ddae619a8337f5">evaluationsDBState</a></td></tr>
<tr class="memdesc:a73f5878081a50c3b35ddae619a8337f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of evaluations DB for this iterator. <br /></td></tr>
<tr class="separator:a73f5878081a50c3b35ddae619a8337f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6700e5f0b3d4b803050127b38c613221"><td class="memItemLeft" align="right" valign="top"><a id="a6700e5f0b3d4b803050127b38c613221"></a>
<a class="el" href="classDakota_1_1ResultsNames.html">ResultsNames</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a6700e5f0b3d4b803050127b38c613221">resultsNames</a></td></tr>
<tr class="memdesc:a6700e5f0b3d4b803050127b38c613221"><td class="mdescLeft">&#160;</td><td class="mdescRight">valid names for iterator results <br /></td></tr>
<tr class="separator:a6700e5f0b3d4b803050127b38c613221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b074cd001a454f368374b3fc91e9adf"><td class="memItemLeft" align="right" valign="top"><a id="a8b074cd001a454f368374b3fc91e9adf"></a>
std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a8b074cd001a454f368374b3fc91e9adf">methodTraits</a></td></tr>
<tr class="memdesc:a8b074cd001a454f368374b3fc91e9adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer that retains shared ownership of a <a class="el" href="classDakota_1_1TraitsBase.html" title="Base class for traits.">TraitsBase</a> object, or child thereof <br /></td></tr>
<tr class="separator:a8b074cd001a454f368374b3fc91e9adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e9d77a375e57b304a56f49d83af1a9"><td class="memItemLeft" align="right" valign="top"><a id="a14e9d77a375e57b304a56f49d83af1a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a14e9d77a375e57b304a56f49d83af1a9">topLevel</a></td></tr>
<tr class="memdesc:a14e9d77a375e57b304a56f49d83af1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is the top level iterator. <br /></td></tr>
<tr class="separator:a14e9d77a375e57b304a56f49d83af1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8650f4b069c5429ff675b25a8aa8f9"><td class="memItemLeft" align="right" valign="top"><a id="aac8650f4b069c5429ff675b25a8aa8f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aac8650f4b069c5429ff675b25a8aa8f9">exportSurrogate</a> = false</td></tr>
<tr class="memdesc:aac8650f4b069c5429ff675b25a8aa8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to export final surrogates <br /></td></tr>
<tr class="separator:aac8650f4b069c5429ff675b25a8aa8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816ce730220620c8f42804f2ce78f91e"><td class="memItemLeft" align="right" valign="top"><a id="a816ce730220620c8f42804f2ce78f91e"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a816ce730220620c8f42804f2ce78f91e">surrExportPrefix</a></td></tr>
<tr class="memdesc:a816ce730220620c8f42804f2ce78f91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">base filename for exported surrogates <br /></td></tr>
<tr class="separator:a816ce730220620c8f42804f2ce78f91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8f9a72cee17bc5a9d6b0f7f622d577"><td class="memItemLeft" align="right" valign="top"><a id="afb8f9a72cee17bc5a9d6b0f7f622d577"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#afb8f9a72cee17bc5a9d6b0f7f622d577">surrExportFormat</a> = NO_MODEL_FORMAT</td></tr>
<tr class="memdesc:afb8f9a72cee17bc5a9d6b0f7f622d577"><td class="mdescLeft">&#160;</td><td class="mdescRight">(bitwise) format(s) to export <br /></td></tr>
<tr class="separator:afb8f9a72cee17bc5a9d6b0f7f622d577"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aed763b0cfe29d94b0b93e1290431568d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aed763b0cfe29d94b0b93e1290431568d">get_iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db)</td></tr>
<tr class="memdesc:aed763b0cfe29d94b0b93e1290431568d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the envelope to instantiate the correct letter class.  <a href="classDakota_1_1Iterator.html#aed763b0cfe29d94b0b93e1290431568d">More...</a><br /></td></tr>
<tr class="separator:aed763b0cfe29d94b0b93e1290431568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b06d1b485dcd029ccec3c1a91d5b6f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a15b06d1b485dcd029ccec3c1a91d5b6f">get_iterator</a> (<a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;problem_db, <a class="el" href="classDakota_1_1Model.html">Model</a> &amp;model)</td></tr>
<tr class="memdesc:a15b06d1b485dcd029ccec3c1a91d5b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the envelope to instantiate the correct letter class.  <a href="classDakota_1_1Iterator.html#a15b06d1b485dcd029ccec3c1a91d5b6f">More...</a><br /></td></tr>
<tr class="separator:a15b06d1b485dcd029ccec3c1a91d5b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94631d6f20663903a168403dac63517c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a94631d6f20663903a168403dac63517c">get_iterator</a> (const String &amp;<a class="el" href="classDakota_1_1Iterator.html#a71dc13c14c38573c2fe361b091568bd1">method_string</a>, <a class="el" href="classDakota_1_1Model.html">Model</a> &amp;model)</td></tr>
<tr class="memdesc:a94631d6f20663903a168403dac63517c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the envelope to instantiate the correct letter class.  <a href="classDakota_1_1Iterator.html#a94631d6f20663903a168403dac63517c">More...</a><br /></td></tr>
<tr class="separator:a94631d6f20663903a168403dac63517c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a4d4e14b16b5d0591739b5d573a60249f"><td class="memItemLeft" align="right" valign="top">static String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a4d4e14b16b5d0591739b5d573a60249f">user_auto_id</a> ()</td></tr>
<tr class="memdesc:a4d4e14b16b5d0591739b5d573a60249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the next available method ID for no-ID user methods  <a href="classDakota_1_1Iterator.html#a4d4e14b16b5d0591739b5d573a60249f">More...</a><br /></td></tr>
<tr class="separator:a4d4e14b16b5d0591739b5d573a60249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c6a4eed68adb0ff96f408d09f3a20e"><td class="memItemLeft" align="right" valign="top">static String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a03c6a4eed68adb0ff96f408d09f3a20e">no_spec_id</a> ()</td></tr>
<tr class="memdesc:a03c6a4eed68adb0ff96f408d09f3a20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the next available method ID for on-the-fly methods  <a href="classDakota_1_1Iterator.html#a03c6a4eed68adb0ff96f408d09f3a20e">More...</a><br /></td></tr>
<tr class="separator:a03c6a4eed68adb0ff96f408d09f3a20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac52bb40a45971bd6f060bf4973600bb3"><td class="memItemLeft" align="right" valign="top"><a id="ac52bb40a45971bd6f060bf4973600bb3"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#ac52bb40a45971bd6f060bf4973600bb3">methodId</a></td></tr>
<tr class="memdesc:ac52bb40a45971bd6f060bf4973600bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">method identifier string from the input file, or an auto-generated ID, such that each instance of an <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> has a unique ID <br /></td></tr>
<tr class="separator:ac52bb40a45971bd6f060bf4973600bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236722834c2c6bbe8a68348f38ba9bb6"><td class="memItemLeft" align="right" valign="top"><a id="a236722834c2c6bbe8a68348f38ba9bb6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a236722834c2c6bbe8a68348f38ba9bb6">execNum</a></td></tr>
<tr class="memdesc:a236722834c2c6bbe8a68348f38ba9bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An execution number for this instance of the class. Now that each instance has a unique methodId, this is just a simple counter. <br /></td></tr>
<tr class="separator:a236722834c2c6bbe8a68348f38ba9bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd7c48925a50fcaded34bbf174ab38a"><td class="memItemLeft" align="right" valign="top"><a id="aecd7c48925a50fcaded34bbf174ab38a"></a>
std::map&lt; size_t, ParConfigLIter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#aecd7c48925a50fcaded34bbf174ab38a">methodPCIterMap</a></td></tr>
<tr class="memdesc:aecd7c48925a50fcaded34bbf174ab38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">track the available configurations that have been created (init_communicators) and are available for activation at run time (set_communicators) <br /></td></tr>
<tr class="separator:aecd7c48925a50fcaded34bbf174ab38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2659afd98baea8973d8b36ca1eaeb2a9"><td class="memItemLeft" align="right" valign="top"><a id="a2659afd98baea8973d8b36ca1eaeb2a9"></a>
std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">iteratorRep</a></td></tr>
<tr class="memdesc:a2659afd98baea8973d8b36ca1eaeb2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the letter (initialized only for the envelope) <br /></td></tr>
<tr class="separator:a2659afd98baea8973d8b36ca1eaeb2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a314c8074450846a9e62d2876f178df74"><td class="memItemLeft" align="right" valign="top"><a id="a314c8074450846a9e62d2876f178df74"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDakota_1_1Iterator.html#a314c8074450846a9e62d2876f178df74">noSpecIdNum</a> = 0</td></tr>
<tr class="memdesc:a314c8074450846a9e62d2876f178df74"><td class="mdescLeft">&#160;</td><td class="mdescRight">the last used method ID number for on-the-fly instantiations (increment before each use) <br /></td></tr>
<tr class="separator:a314c8074450846a9e62d2876f178df74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for the iterator class hierarchy. </p>
<p>The <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> class is the base class for one of the primary class hierarchies in DAKOTA. The iterator hierarchy contains all of the iterative algorithms which use repeated execution of simulations as function evaluations. For memory efficiency and enhanced polymorphism, the iterator hierarchy employs the "letter/envelope
idiom" (see Coplien "Advanced C++", p. 133), for which the base class (<a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a>) serves as the envelope and one of the derived classes (selected in <a class="el" href="classDakota_1_1Iterator.html#aed763b0cfe29d94b0b93e1290431568d" title="Used by the envelope to instantiate the correct letter class.">Iterator::get_iterator()</a>) serves as the letter. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a668a398bcf34b766e5773f039f61a9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668a398bcf34b766e5773f039f61a9dc">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td>
          <td class="paramname"><em>traits</em> = <code>std::shared_ptr&lt;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>&gt;(new&#160;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>())</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default constructor </p>
<p>The default constructor is used in Vector&lt;Iterator&gt; instantiations and for initialization of <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> objects contained in meta-Iterators and <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> recursions. iteratorRep is NULL in this case. </p>

</div>
</div>
<a id="a46469785469e3b51dda41d692d910a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46469785469e3b51dda41d692d910a00">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td>
          <td class="paramname"><em>traits</em> = <code>std::shared_ptr&lt;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>&gt;(new&#160;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>standard envelope constructor, which constructs its own model(s) </p>
<p>This constructor assigns a representation pointer into this envelope, transferring ownership. It behaves the same as a default construction followed by <a class="el" href="classDakota_1_1Iterator.html#a7f7d7442555917525fc1b189f40e9627" title="replaces existing letter with a new one">assign_rep()</a>. Envelope constructor only needs to extract enough data to properly execute <a class="el" href="classDakota_1_1Iterator.html#aed763b0cfe29d94b0b93e1290431568d" title="Used by the envelope to instantiate the correct letter class.">get_iterator()</a>, since letter holds the actual base class data. This version is used for top-level ProblemDescDB-driven construction of all Iterators and MetaIterators, which construct their own <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> instances. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, and <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

</div>
</div>
<a id="adef11f0c1be2a246d383d9405f67c985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef11f0c1be2a246d383d9405f67c985">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td>
          <td class="paramname"><em>traits</em> = <code>std::shared_ptr&lt;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>&gt;(new&#160;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>alternate envelope constructor which uses the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> but accepts a model from a higher level (meta-iterator) context, instead of constructing its own </p>
<p>Envelope constructor only needs to extract enough data to properly execute <a class="el" href="classDakota_1_1Iterator.html#aed763b0cfe29d94b0b93e1290431568d" title="Used by the envelope to instantiate the correct letter class.">get_iterator()</a>, since letter holds the actual base class data. This version is used for ProblemDescDB-driven construction of Iterators that are passed a <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> from a higher-level context (e.g., a <a class="el" href="classDakota_1_1MetaIterator.html" title="Base class for meta-iterators.">MetaIterator</a> instantiates its sub-iterator(s) by name instead of pointer and passes in its iteratedModel, since these sub-iterators lack their own model pointers). </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, and <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

</div>
</div>
<a id="a66caab45c5c797d570f7fc595b8d9554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66caab45c5c797d570f7fc595b8d9554">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>method_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td>
          <td class="paramname"><em>traits</em> = <code>std::shared_ptr&lt;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>&gt;(new&#160;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>alternate envelope constructor for instantiations by name without the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> </p>
<p>Used in sub-iterator instantiations within iterator constructors. Envelope constructor only needs to extract enough data to properly execute <a class="el" href="classDakota_1_1Iterator.html#aed763b0cfe29d94b0b93e1290431568d" title="Used by the envelope to instantiate the correct letter class.">get_iterator()</a>, since letter holds the actual base class data. This version is used for lightweight constructions without the <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a>. </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, and <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

</div>
</div>
<a id="a9e6db128dfed6236df263f151edfc050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6db128dfed6236df263f151edfc050">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy constructor </p>
<p>Copy constructor manages sharing of iteratorRep. </p>

</div>
</div>
<a id="a6ac42595c73c833561ab0778ac178cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac42595c73c833561ab0778ac178cea">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDakota_1_1BaseConstructor.html">BaseConstructor</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td>
          <td class="paramname"><em>traits</em> = <code>std::shared_ptr&lt;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>&gt;(new&#160;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor initializes the base class part of letter classes (<a class="el" href="structDakota_1_1BaseConstructor.html" title="Dummy struct for overloading letter-envelope constructors.">BaseConstructor</a> overloading avoids infinite recursion in the derived class constructors - Coplien, p. 139) </p>
<p>This constructor builds the base class data for all inherited iterators, including meta-iterators. <a class="el" href="classDakota_1_1Iterator.html#aed763b0cfe29d94b0b93e1290431568d" title="Used by the envelope to instantiate the correct letter class.">get_iterator()</a> instantiates a derived class and the derived class selects this base class constructor in its initialization list (to avoid the recursion of the base class constructor calling <a class="el" href="classDakota_1_1Iterator.html#aed763b0cfe29d94b0b93e1290431568d" title="Used by the envelope to instantiate the correct letter class.">get_iterator()</a> again). Since the letter IS the representation, its representation pointer is set to NULL </p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#ab6ff02f762983acda51874c5102054f3">Iterator::method_enum_to_string()</a>, <a class="el" href="classDakota_1_1Iterator.html#ac52bb40a45971bd6f060bf4973600bb3">Iterator::methodId</a>, <a class="el" href="classDakota_1_1Iterator.html#a232e81b24a57f058b946705f9885a44a">Iterator::methodName</a>, <a class="el" href="classDakota_1_1Iterator.html#a8b080aab3a786ee1439b43c3533f1f6a">Iterator::outputLevel</a>, and <a class="el" href="classDakota_1_1Iterator.html#a4d4e14b16b5d0591739b5d573a60249f">Iterator::user_auto_id()</a>.</p>

</div>
</div>
<a id="a5ee857e558ed33f22b9d173a7eabef8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee857e558ed33f22b9d173a7eabef8d">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDakota_1_1NoDBBaseConstructor.html">NoDBBaseConstructor</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td>
          <td class="paramname"><em>traits</em> = <code>std::shared_ptr&lt;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>&gt;(new&#160;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>alternate constructor for base iterator classes constructed on the fly </p>
<p>This alternate constructor builds base class data for inherited iterators. It is used for on-the-fly instantiations for which DB queries cannot be used, and is not used for construction of meta-iterators. </p>

</div>
</div>
<a id="abd1d5defc27cba31425e427ba4c6e8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1d5defc27cba31425e427ba4c6e8fe">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDakota_1_1NoDBBaseConstructor.html">NoDBBaseConstructor</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td>
          <td class="paramname"><em>traits</em> = <code>std::shared_ptr&lt;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>&gt;(new&#160;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>alternate constructor for base iterator classes constructed on the fly </p>
<p>This alternate constructor builds base class data for inherited iterators. It is used for on-the-fly instantiations for which DB queries cannot be used, and is not used for construction of meta-iterators. It has no incoming model, so only sets up a minimal set of defaults. However, its use is preferable to the default constructor, which should remain as minimal as possible. </p>

</div>
</div>
<a id="aaf83d073662105b6211a5befe46ae718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf83d073662105b6211a5befe46ae718">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDakota_1_1NoDBBaseConstructor.html">NoDBBaseConstructor</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>conv_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a> &gt;&#160;</td>
          <td class="paramname"><em>traits</em> = <code>std::shared_ptr&lt;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>&gt;(new&#160;<a class="el" href="classDakota_1_1TraitsBase.html">TraitsBase</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>alternate envelope constructor for instantiations without <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> </p>
<p>This alternate constructor builds base class data for inherited iterators. It is used for on-the-fly instantiations for which DB queries cannot be used, and is not used for construction of meta-iterators. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa1257cf90111aec1c47057d3bc893111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1257cf90111aec1c47057d3bc893111">&#9670;&nbsp;</a></span>initialize_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility function to perform common operations prior to <a class="el" href="classDakota_1_1Iterator.html#a7a8df3f99e1d582c6c136b16d6e34d13" title="pre-run portion of run (optional); re-implemented by Iterators which can generate all Variables (para...">pre_run()</a>; typically memory initialization; setting of instance pointers </p>
<p>Perform initialization phases of run sequence, like allocating memory and setting instance pointers. Commonly used in sub-iterator executions. This is a virtual function; when re-implementing, a derived class must call its nearest parent's <a class="el" href="classDakota_1_1Iterator.html#aa1257cf90111aec1c47057d3bc893111" title="utility function to perform common operations prior to pre_run(); typically memory initialization; se...">initialize_run()</a>, typically <em>before</em> performing its own implementation steps. </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1ROLOptimizer.html#a2b89cdd7927b59734d95c555da9b3898">ROLOptimizer</a>, <a class="el" href="classDakota_1_1SNLLOptimizer.html#aa1257cf90111aec1c47057d3bc893111">SNLLOptimizer</a>, <a class="el" href="classDakota_1_1SNLLLeastSq.html#aa1257cf90111aec1c47057d3bc893111">SNLLLeastSq</a>, <a class="el" href="classDakota_1_1Optimizer.html#aa1257cf90111aec1c47057d3bc893111">Optimizer</a>, <a class="el" href="classDakota_1_1NonD.html#aa1257cf90111aec1c47057d3bc893111">NonD</a>, <a class="el" href="classDakota_1_1Minimizer.html#aa1257cf90111aec1c47057d3bc893111">Minimizer</a>, <a class="el" href="classDakota_1_1LeastSq.html#aa1257cf90111aec1c47057d3bc893111">LeastSq</a>, <a class="el" href="classDakota_1_1Analyzer.html#aa1257cf90111aec1c47057d3bc893111">Analyzer</a>, <a class="el" href="classDakota_1_1CONMINOptimizer.html#aa1257cf90111aec1c47057d3bc893111">CONMINOptimizer</a>, and <a class="el" href="classDakota_1_1APPSOptimizer.html#aa1257cf90111aec1c47057d3bc893111">APPSOptimizer</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Iterator.html#a13a43e6d814de94978c515cb084873b1">Iterator::run()</a>, and <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a9a340e1bcac306f6c13a40258006a2ba">SeqHybridMetaIterator::run_sequential_adaptive()</a>.</p>

</div>
</div>
<a id="a7a8df3f99e1d582c6c136b16d6e34d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8df3f99e1d582c6c136b16d6e34d13">&#9670;&nbsp;</a></span>pre_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pre_run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pre-run portion of run (optional); re-implemented by Iterators which can generate all <a class="el" href="classDakota_1_1Variables.html" title="Base class for the variables class hierarchy.">Variables</a> (parameter sets) a priori </p>
<p>pre-run phase, which a derived iterator may optionally reimplement; when not present, pre-run is likely integrated into the derived run function. This is a virtual function; when re-implementing, a derived class must call its nearest parent's <a class="el" href="classDakota_1_1Iterator.html#a7a8df3f99e1d582c6c136b16d6e34d13" title="pre-run portion of run (optional); re-implemented by Iterators which can generate all Variables (para...">pre_run()</a>, if implemented, typically <em>before</em> performing its own implementation steps. </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1SurrBasedLocalMinimizer.html#a7a8df3f99e1d582c6c136b16d6e34d13">SurrBasedLocalMinimizer</a>, <a class="el" href="classDakota_1_1PSUADEDesignCompExp.html#a7a8df3f99e1d582c6c136b16d6e34d13">PSUADEDesignCompExp</a>, <a class="el" href="classDakota_1_1ParamStudy.html#a7a8df3f99e1d582c6c136b16d6e34d13">ParamStudy</a>, <a class="el" href="classDakota_1_1NonDSampling.html#a7a8df3f99e1d582c6c136b16d6e34d13">NonDSampling</a>, <a class="el" href="classDakota_1_1NonDRKDDarts.html#a7a8df3f99e1d582c6c136b16d6e34d13">NonDRKDDarts</a>, <a class="el" href="classDakota_1_1NonDNonHierarchSampling.html#a7a8df3f99e1d582c6c136b16d6e34d13">NonDNonHierarchSampling</a>, <a class="el" href="classDakota_1_1NonDMultilevControlVarSampling.html#a7a8df3f99e1d582c6c136b16d6e34d13">NonDMultilevControlVarSampling</a>, <a class="el" href="classDakota_1_1NonDLocalReliability.html#a7a8df3f99e1d582c6c136b16d6e34d13">NonDLocalReliability</a>, <a class="el" href="classDakota_1_1NonDLHSSampling.html#a7a8df3f99e1d582c6c136b16d6e34d13">NonDLHSSampling</a>, <a class="el" href="classDakota_1_1NonDGlobalReliability.html#a7a8df3f99e1d582c6c136b16d6e34d13">NonDGlobalReliability</a>, <a class="el" href="classDakota_1_1NonDEnsembleSampling.html#a7a8df3f99e1d582c6c136b16d6e34d13">NonDEnsembleSampling</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#a7a8df3f99e1d582c6c136b16d6e34d13">NonDBayesCalibration</a>, <a class="el" href="classDakota_1_1FSUDesignCompExp.html#a7a8df3f99e1d582c6c136b16d6e34d13">FSUDesignCompExp</a>, <a class="el" href="classDakota_1_1EffGlobalMinimizer.html#a7a8df3f99e1d582c6c136b16d6e34d13">EffGlobalMinimizer</a>, <a class="el" href="classDakota_1_1DDACEDesignCompExp.html#a7a8df3f99e1d582c6c136b16d6e34d13">DDACEDesignCompExp</a>, <a class="el" href="classDakota_1_1Analyzer.html#a7a8df3f99e1d582c6c136b16d6e34d13">Analyzer</a>, and <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a7a8df3f99e1d582c6c136b16d6e34d13">ConcurrentMetaIterator</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1NonDBayesCalibration.html#ab792d2d09db0a4ceddc9fab61d386924">NonDBayesCalibration::build_designs()</a>, and <a class="el" href="classDakota_1_1Iterator.html#a13a43e6d814de94978c515cb084873b1">Iterator::run()</a>.</p>

</div>
</div>
<a id="a64cdbb1eb9544b4f8a42944a00a222be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cdbb1eb9544b4f8a42944a00a222be">&#9670;&nbsp;</a></span>core_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core_run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>core portion of run; implemented by all derived classes and may include pre/post steps in lieu of separate pre/post </p>
<p>Virtual run function for the iterator class hierarchy. All derived classes need to redefine it. </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1ROLOptimizer.html#a68e0645a050a35afa58d1b91932cbb64">ROLOptimizer</a>, <a class="el" href="classDakota_1_1SurrBasedLocalMinimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">SurrBasedLocalMinimizer</a>, <a class="el" href="classDakota_1_1SurrBasedGlobalMinimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">SurrBasedGlobalMinimizer</a>, <a class="el" href="classDakota_1_1SNLLOptimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">SNLLOptimizer</a>, <a class="el" href="classDakota_1_1SNLLLeastSq.html#a64cdbb1eb9544b4f8a42944a00a222be">SNLLLeastSq</a>, <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a64cdbb1eb9544b4f8a42944a00a222be">SeqHybridMetaIterator</a>, <a class="el" href="classDakota_1_1RichExtrapVerification.html#a64cdbb1eb9544b4f8a42944a00a222be">RichExtrapVerification</a>, <a class="el" href="classDakota_1_1PSUADEDesignCompExp.html#a64cdbb1eb9544b4f8a42944a00a222be">PSUADEDesignCompExp</a>, <a class="el" href="classDakota_1_1ParamStudy.html#a64cdbb1eb9544b4f8a42944a00a222be">ParamStudy</a>, <a class="el" href="classDakota_1_1OptDartsOptimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">OptDartsOptimizer</a>, <a class="el" href="classDakota_1_1NOWPACOptimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">NOWPACOptimizer</a>, <a class="el" href="classDakota_1_1NonlinearCGOptimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">NonlinearCGOptimizer</a>, <a class="el" href="classDakota_1_1NonDSampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDSampling</a>, <a class="el" href="classDakota_1_1NonDRKDDarts.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDRKDDarts</a>, <a class="el" href="classDakota_1_1NonDPOFDarts.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDPOFDarts</a>, <a class="el" href="classDakota_1_1NonDMultilevelStochCollocation.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDMultilevelStochCollocation</a>, <a class="el" href="classDakota_1_1NonDMultilevelSampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDMultilevelSampling</a>, <a class="el" href="classDakota_1_1NonDMultilevelPolynomialChaos.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDMultilevelPolynomialChaos</a>, <a class="el" href="classDakota_1_1NonDMultilevelFunctionTrain.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDMultilevelFunctionTrain</a>, <a class="el" href="classDakota_1_1NonDMultilevControlVarSampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDMultilevControlVarSampling</a>, <a class="el" href="classDakota_1_1NonDMultifidelitySampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDMultifidelitySampling</a>, <a class="el" href="classDakota_1_1NonDLocalReliability.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDLocalReliability</a>, <a class="el" href="classDakota_1_1NonDLocalInterval.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDLocalInterval</a>, <a class="el" href="classDakota_1_1NonDLHSSampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDLHSSampling</a>, <a class="el" href="classDakota_1_1NonDLHSInterval.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDLHSInterval</a>, <a class="el" href="classDakota_1_1NonDIntegration.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDIntegration</a>, <a class="el" href="classDakota_1_1NonDGPImpSampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDGPImpSampling</a>, <a class="el" href="classDakota_1_1NonDGlobalReliability.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDGlobalReliability</a>, <a class="el" href="classDakota_1_1NonDGlobalInterval.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDGlobalInterval</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDExpansion</a>, <a class="el" href="classDakota_1_1NonDControlVariateSampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDControlVariateSampling</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDBayesCalibration</a>, <a class="el" href="classDakota_1_1NonDAdaptiveSampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDAdaptiveSampling</a>, <a class="el" href="classDakota_1_1NonDAdaptImpSampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDAdaptImpSampling</a>, <a class="el" href="classDakota_1_1NonDACVSampling.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDACVSampling</a>, <a class="el" href="classDakota_1_1NLSSOLLeastSq.html#a64cdbb1eb9544b4f8a42944a00a222be">NLSSOLLeastSq</a>, <a class="el" href="classDakota_1_1NL2SOLLeastSq.html#a64cdbb1eb9544b4f8a42944a00a222be">NL2SOLLeastSq</a>, <a class="el" href="classDakota_1_1NCSUOptimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">NCSUOptimizer</a>, <a class="el" href="classDakota_1_1JEGAOptimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">JEGAOptimizer</a>, <a class="el" href="classDakota_1_1FSUDesignCompExp.html#a64cdbb1eb9544b4f8a42944a00a222be">FSUDesignCompExp</a>, <a class="el" href="classDakota_1_1EmbedHybridMetaIterator.html#a64cdbb1eb9544b4f8a42944a00a222be">EmbedHybridMetaIterator</a>, <a class="el" href="classDakota_1_1EffGlobalMinimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">EffGlobalMinimizer</a>, <a class="el" href="classDakota_1_1DDACEDesignCompExp.html#a64cdbb1eb9544b4f8a42944a00a222be">DDACEDesignCompExp</a>, <a class="el" href="classDakota_1_1CONMINOptimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">CONMINOptimizer</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a64cdbb1eb9544b4f8a42944a00a222be">ConcurrentMetaIterator</a>, <a class="el" href="classDakota_1_1CollabHybridMetaIterator.html#a64cdbb1eb9544b4f8a42944a00a222be">CollabHybridMetaIterator</a>, <a class="el" href="classDakota_1_1COLINOptimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">COLINOptimizer</a>, and <a class="el" href="classDakota_1_1APPSOptimizer.html#a64cdbb1eb9544b4f8a42944a00a222be">APPSOptimizer</a>.</p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, and <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Iterator.html#a13a43e6d814de94978c515cb084873b1">Iterator::run()</a>.</p>

</div>
</div>
<a id="a871297a2dea1389f3d8c57341f9ed45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871297a2dea1389f3d8c57341f9ed45a">&#9670;&nbsp;</a></span>post_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void post_run </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>post-run portion of run (optional); verbose to print results; re-implemented by Iterators that can read all Variables/Responses and perform final analysis phase in a standalone way </p>
<p>Post-run phase, which a derived iterator may optionally reimplement; when not present, post-run is likely integrated into run. This is a virtual function; when re-implementing, a derived class must call its nearest parent's <a class="el" href="classDakota_1_1Iterator.html#a871297a2dea1389f3d8c57341f9ed45a" title="post-run portion of run (optional); verbose to print results; re-implemented by Iterators that can re...">post_run()</a>, typically <em>after</em> performing its own implementation steps. </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1NonDPolynomialChaos.html#a2637c0db38cc7856851b2d996fe0420e">NonDPolynomialChaos</a>, <a class="el" href="classDakota_1_1SurrBasedLocalMinimizer.html#a871297a2dea1389f3d8c57341f9ed45a">SurrBasedLocalMinimizer</a>, <a class="el" href="classDakota_1_1SNLLOptimizer.html#a871297a2dea1389f3d8c57341f9ed45a">SNLLOptimizer</a>, <a class="el" href="classDakota_1_1PSUADEDesignCompExp.html#a871297a2dea1389f3d8c57341f9ed45a">PSUADEDesignCompExp</a>, <a class="el" href="classDakota_1_1ParamStudy.html#a871297a2dea1389f3d8c57341f9ed45a">ParamStudy</a>, <a class="el" href="classDakota_1_1NonDRKDDarts.html#a871297a2dea1389f3d8c57341f9ed45a">NonDRKDDarts</a>, <a class="el" href="classDakota_1_1NonDReliability.html#a871297a2dea1389f3d8c57341f9ed45a">NonDReliability</a>, <a class="el" href="classDakota_1_1NonDLHSSampling.html#a871297a2dea1389f3d8c57341f9ed45a">NonDLHSSampling</a>, <a class="el" href="classDakota_1_1NonDEnsembleSampling.html#a871297a2dea1389f3d8c57341f9ed45a">NonDEnsembleSampling</a>, <a class="el" href="classDakota_1_1MetaIterator.html#a871297a2dea1389f3d8c57341f9ed45a">MetaIterator</a>, <a class="el" href="classDakota_1_1FSUDesignCompExp.html#a871297a2dea1389f3d8c57341f9ed45a">FSUDesignCompExp</a>, <a class="el" href="classDakota_1_1EffGlobalMinimizer.html#a871297a2dea1389f3d8c57341f9ed45a">EffGlobalMinimizer</a>, <a class="el" href="classDakota_1_1DDACEDesignCompExp.html#a871297a2dea1389f3d8c57341f9ed45a">DDACEDesignCompExp</a>, <a class="el" href="classDakota_1_1Optimizer.html#a871297a2dea1389f3d8c57341f9ed45a">Optimizer</a>, <a class="el" href="classDakota_1_1Minimizer.html#a871297a2dea1389f3d8c57341f9ed45a">Minimizer</a>, <a class="el" href="classDakota_1_1LeastSq.html#a871297a2dea1389f3d8c57341f9ed45a">LeastSq</a>, <a class="el" href="classDakota_1_1Analyzer.html#a871297a2dea1389f3d8c57341f9ed45a">Analyzer</a>, and <a class="el" href="classDakota_1_1COLINOptimizer.html#a871297a2dea1389f3d8c57341f9ed45a">COLINOptimizer</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Iterator.html#a13a43e6d814de94978c515cb084873b1">Iterator::run()</a>.</p>

</div>
</div>
<a id="af05afabcb70acd3943a391cd13076db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05afabcb70acd3943a391cd13076db1">&#9670;&nbsp;</a></span>finalize_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void finalize_run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility function to perform common operations following <a class="el" href="classDakota_1_1Iterator.html#a871297a2dea1389f3d8c57341f9ed45a" title="post-run portion of run (optional); verbose to print results; re-implemented by Iterators that can re...">post_run()</a>; deallocation and resetting of instance pointers </p>
<p>Optional: perform finalization phases of run sequence, like deallocating memory and resetting instance pointers. Commonly used in sub-iterator executions. This is a virtual function; when re-implementing, a derived class must call its nearest parent's <a class="el" href="classDakota_1_1Iterator.html#af05afabcb70acd3943a391cd13076db1" title="utility function to perform common operations following post_run(); deallocation and resetting of ins...">finalize_run()</a>, typically <em>after</em> performing its own implementation steps. </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1SNLLOptimizer.html#af05afabcb70acd3943a391cd13076db1">SNLLOptimizer</a>, <a class="el" href="classDakota_1_1SNLLLeastSq.html#af05afabcb70acd3943a391cd13076db1">SNLLLeastSq</a>, <a class="el" href="classDakota_1_1Optimizer.html#af05afabcb70acd3943a391cd13076db1">Optimizer</a>, <a class="el" href="classDakota_1_1NonD.html#af05afabcb70acd3943a391cd13076db1">NonD</a>, <a class="el" href="classDakota_1_1Minimizer.html#af05afabcb70acd3943a391cd13076db1">Minimizer</a>, <a class="el" href="classDakota_1_1LeastSq.html#af05afabcb70acd3943a391cd13076db1">LeastSq</a>, and <a class="el" href="classDakota_1_1Analyzer.html#af05afabcb70acd3943a391cd13076db1">Analyzer</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Iterator.html#a13a43e6d814de94978c515cb084873b1">Iterator::run()</a>, and <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a9a340e1bcac306f6c13a40258006a2ba">SeqHybridMetaIterator::run_sequential_adaptive()</a>.</p>

</div>
</div>
<a id="a58ed7a8dd3339697bf58f09925d6cf36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ed7a8dd3339697bf58f09925d6cf36">&#9670;&nbsp;</a></span>initialize_graphics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_graphics </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterator_server_id</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize the 2D graphics window and the tabular graphics data </p>
<p>This is a convenience function for encapsulating graphics initialization operations. It is overridden by derived classes that specialize the graphics display. </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1SurrBasedLocalMinimizer.html#a58ed7a8dd3339697bf58f09925d6cf36">SurrBasedLocalMinimizer</a>, <a class="el" href="classDakota_1_1SurrBasedGlobalMinimizer.html#a58ed7a8dd3339697bf58f09925d6cf36">SurrBasedGlobalMinimizer</a>, and <a class="el" href="classDakota_1_1NonDLocalReliability.html#a58ed7a8dd3339697bf58f09925d6cf36">NonDLocalReliability</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a7f894ca56d2c8cb3f951269e3d09884d">Iterator::initialize_model_graphics()</a>, <a class="el" href="classDakota_1_1Iterator.html#a1d92d85a575fee135731f788f4b15adf">Iterator::iteratedModel</a>, and <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1CollabHybridMetaIterator.html#a64cdbb1eb9544b4f8a42944a00a222be">CollabHybridMetaIterator::core_run()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a64cdbb1eb9544b4f8a42944a00a222be">ConcurrentMetaIterator::core_run()</a>, <a class="el" href="classDakota_1_1EmbedHybridMetaIterator.html#a64cdbb1eb9544b4f8a42944a00a222be">EmbedHybridMetaIterator::core_run()</a>, <a class="el" href="classDakota_1_1Environment.html#a61af3e60b94ae3e748f6fbac1e794af7">Environment::execute()</a>, <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a760202f6de331ca27a3fda79f17f5fd5">SeqHybridMetaIterator::run_sequential()</a>, and <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a9a340e1bcac306f6c13a40258006a2ba">SeqHybridMetaIterator::run_sequential_adaptive()</a>.</p>

</div>
</div>
<a id="a76253a61ea722d76381ded1872b404d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76253a61ea722d76381ded1872b404d0">&#9670;&nbsp;</a></span>print_results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print_results </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>results_state</em> = <code>FINAL_RESULTS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print the final iterator results </p>
<p>This virtual function provides additional iterator-specific final results outputs beyond the function evaluation summary printed in <a class="el" href="classDakota_1_1Iterator.html#af05afabcb70acd3943a391cd13076db1" title="utility function to perform common operations following post_run(); deallocation and resetting of ins...">finalize_run()</a>. </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1NonDWASABIBayesCalibration.html#a8469722da3d2a0b384e549038f960bf7">NonDWASABIBayesCalibration</a>, <a class="el" href="classDakota_1_1NonDQUESOBayesCalibration.html#a8469722da3d2a0b384e549038f960bf7">NonDQUESOBayesCalibration</a>, <a class="el" href="classDakota_1_1SurrBasedMinimizer.html#a76253a61ea722d76381ded1872b404d0">SurrBasedMinimizer</a>, <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a76253a61ea722d76381ded1872b404d0">SeqHybridMetaIterator</a>, <a class="el" href="classDakota_1_1RichExtrapVerification.html#a76253a61ea722d76381ded1872b404d0">RichExtrapVerification</a>, <a class="el" href="classDakota_1_1NonDPolynomialChaos.html#a76253a61ea722d76381ded1872b404d0">NonDPolynomialChaos</a>, <a class="el" href="classDakota_1_1NonDPOFDarts.html#a76253a61ea722d76381ded1872b404d0">NonDPOFDarts</a>, <a class="el" href="classDakota_1_1NonDMUQBayesCalibration.html#a76253a61ea722d76381ded1872b404d0">NonDMUQBayesCalibration</a>, <a class="el" href="classDakota_1_1NonDMultilevelStochCollocation.html#a76253a61ea722d76381ded1872b404d0">NonDMultilevelStochCollocation</a>, <a class="el" href="classDakota_1_1NonDMultilevelPolynomialChaos.html#a76253a61ea722d76381ded1872b404d0">NonDMultilevelPolynomialChaos</a>, <a class="el" href="classDakota_1_1NonDMultilevelFunctionTrain.html#a76253a61ea722d76381ded1872b404d0">NonDMultilevelFunctionTrain</a>, <a class="el" href="classDakota_1_1NonDLocalReliability.html#a76253a61ea722d76381ded1872b404d0">NonDLocalReliability</a>, <a class="el" href="classDakota_1_1NonDLHSSampling.html#a76253a61ea722d76381ded1872b404d0">NonDLHSSampling</a>, <a class="el" href="classDakota_1_1NonDInterval.html#a76253a61ea722d76381ded1872b404d0">NonDInterval</a>, <a class="el" href="classDakota_1_1NonDGPMSABayesCalibration.html#a76253a61ea722d76381ded1872b404d0">NonDGPMSABayesCalibration</a>, <a class="el" href="classDakota_1_1NonDGPImpSampling.html#a76253a61ea722d76381ded1872b404d0">NonDGPImpSampling</a>, <a class="el" href="classDakota_1_1NonDGlobalReliability.html#a76253a61ea722d76381ded1872b404d0">NonDGlobalReliability</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#a76253a61ea722d76381ded1872b404d0">NonDExpansion</a>, <a class="el" href="classDakota_1_1NonDEnsembleSampling.html#a76253a61ea722d76381ded1872b404d0">NonDEnsembleSampling</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#a76253a61ea722d76381ded1872b404d0">NonDBayesCalibration</a>, <a class="el" href="classDakota_1_1NonDAdaptiveSampling.html#a76253a61ea722d76381ded1872b404d0">NonDAdaptiveSampling</a>, <a class="el" href="classDakota_1_1NonDAdaptImpSampling.html#a76253a61ea722d76381ded1872b404d0">NonDAdaptImpSampling</a>, <a class="el" href="classDakota_1_1Verification.html#a76253a61ea722d76381ded1872b404d0">Verification</a>, <a class="el" href="classDakota_1_1PStudyDACE.html#a76253a61ea722d76381ded1872b404d0">PStudyDACE</a>, <a class="el" href="classDakota_1_1Optimizer.html#a76253a61ea722d76381ded1872b404d0">Optimizer</a>, <a class="el" href="classDakota_1_1LeastSq.html#a76253a61ea722d76381ded1872b404d0">LeastSq</a>, <a class="el" href="classDakota_1_1Analyzer.html#a76253a61ea722d76381ded1872b404d0">Analyzer</a>, and <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a76253a61ea722d76381ded1872b404d0">ConcurrentMetaIterator</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Minimizer.html#a871297a2dea1389f3d8c57341f9ed45a">Minimizer::post_run()</a>, and <a class="el" href="classDakota_1_1MetaIterator.html#a871297a2dea1389f3d8c57341f9ed45a">MetaIterator::post_run()</a>.</p>

</div>
</div>
<a id="a13e0bfc6169ff6a96bbdd9202dcce8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e0bfc6169ff6a96bbdd9202dcce8a1">&#9670;&nbsp;</a></span>check_sub_iterator_conflict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void check_sub_iterator_conflict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>detect any conflicts due to recursive use of the same Fortran solver </p>
<p>This is used to avoid clashes in state between non-object-oriented (i.e., F77, C) iterator executions, when such iterators could potentially be executing simultaneously (e.g., nested execution). It is not an issue (and a used method is not reported) in cases where a helper execution is completed before a lower level one could be initiated; an example of this is DIRECT for maximization of expected improvement: the EIF maximization is completed before a new point evaluation (which could include nested iteration) is performed. </p>

<p>Reimplemented in <a class="el" href="classDakota_1_1NonDLocalReliability.html#a13e0bfc6169ff6a96bbdd9202dcce8a1">NonDLocalReliability</a>, <a class="el" href="classDakota_1_1NonDLocalInterval.html#a13e0bfc6169ff6a96bbdd9202dcce8a1">NonDLocalInterval</a>, <a class="el" href="classDakota_1_1NLSSOLLeastSq.html#a13e0bfc6169ff6a96bbdd9202dcce8a1">NLSSOLLeastSq</a>, <a class="el" href="classDakota_1_1NCSUOptimizer.html#a13e0bfc6169ff6a96bbdd9202dcce8a1">NCSUOptimizer</a>, and <a class="el" href="classDakota_1_1CONMINOptimizer.html#a13e0bfc6169ff6a96bbdd9202dcce8a1">CONMINOptimizer</a>.</p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Iterator.html#a8c9504dc18cfe37e47c8ced284bbaade">Iterator::init_communicators()</a>.</p>

</div>
</div>
<a id="a13a43e6d814de94978c515cb084873b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a43e6d814de94978c515cb084873b1">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>orchestrate initialize/pre/core/post/finalize phases </p>
<p><a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> supports a construct/initialize-run/pre-run/core-run/post-run/ finalize-run/destruct progression. This member (non-virtual) function sequences these run phases. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ParallelLibrary.html#a663a63e5457ccb64f94dc74e6eca2a26">ParallelLibrary::command_line_post_run()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a864a517adfc01fc77b14db87f10c5856">ParallelLibrary::command_line_pre_run()</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#a65c02b5b6eb26c2417aec4f5c4fb313d">ParallelLibrary::command_line_run()</a>, <a class="el" href="classDakota_1_1Iterator.html#a64cdbb1eb9544b4f8a42944a00a222be">Iterator::core_run()</a>, <a class="el" href="classDakota_1_1Iterator.html#a182bc534595be016df0db08c6c3393ba">Iterator::declare_sources()</a>, <a class="el" href="classDakota_1_1Iterator.html#a9e368a123f742a2a32e91285f8c0b764">Iterator::evaluationsDB</a>, <a class="el" href="classDakota_1_1Iterator.html#a73f5878081a50c3b35ddae619a8337f5">Iterator::evaluationsDBState</a>, <a class="el" href="classDakota_1_1Iterator.html#a236722834c2c6bbe8a68348f38ba9bb6">Iterator::execNum</a>, <a class="el" href="classDakota_1_1Iterator.html#af05afabcb70acd3943a391cd13076db1">Iterator::finalize_run()</a>, <a class="el" href="classDakota_1_1ResultsManager.html#a53ba534ec0fa696a0bec89e2d9a2d194">ResultsManager::flush()</a>, <a class="el" href="classDakota_1_1Iterator.html#aa1257cf90111aec1c47057d3bc893111">Iterator::initialize_run()</a>, <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>, <a class="el" href="classDakota_1_1Iterator.html#ab6ff02f762983acda51874c5102054f3">Iterator::method_enum_to_string()</a>, <a class="el" href="classDakota_1_1Iterator.html#a64064d7c4403ee54d8baf573bae29cc6">Iterator::method_id()</a>, <a class="el" href="classDakota_1_1Iterator.html#ac6a74249485a0713c57bf28869270a86">Iterator::method_string()</a>, <a class="el" href="classDakota_1_1Iterator.html#a232e81b24a57f058b946705f9885a44a">Iterator::methodName</a>, <a class="el" href="classDakota_1_1Iterator.html#a8b080aab3a786ee1439b43c3533f1f6a">Iterator::outputLevel</a>, <a class="el" href="classDakota_1_1Iterator.html#a702abf9be22e51f1e67167d5db1b08d3">Iterator::parallelLib</a>, <a class="el" href="classDakota_1_1Iterator.html#a63b161441712f433017bceea927985cb">Iterator::post_input()</a>, <a class="el" href="classDakota_1_1Iterator.html#a871297a2dea1389f3d8c57341f9ed45a">Iterator::post_run()</a>, <a class="el" href="classDakota_1_1Iterator.html#a9faf36a9b3190012a78eb27592306b2b">Iterator::pre_output()</a>, <a class="el" href="classDakota_1_1Iterator.html#a7a8df3f99e1d582c6c136b16d6e34d13">Iterator::pre_run()</a>, <a class="el" href="classDakota_1_1Iterator.html#a51c39266da000ed7eb4a39e620ccf5bd">Iterator::resultsDB</a>, <a class="el" href="classDakota_1_1Iterator.html#a3234db742661b4cedaf7a77b4e98b632">Iterator::summaryOutputFlag</a>, and <a class="el" href="classDakota_1_1Iterator.html#abb082ff394483602db543e6a7acb3f35">Iterator::top_level()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Iterator.html#a92cf4e7fbd96f3bccdcac2267be56e79">Iterator::run()</a>.</p>

</div>
</div>
<a id="a7f7d7442555917525fc1b189f40e9627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7d7442555917525fc1b189f40e9627">&#9670;&nbsp;</a></span>assign_rep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assign_rep </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>iterator_rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replaces existing letter with a new one </p>
<p>The <a class="el" href="classDakota_1_1Iterator.html#a7f7d7442555917525fc1b189f40e9627" title="replaces existing letter with a new one">assign_rep()</a> function is used for publishing derived class letters to existing envelopes, as opposed to sharing representations among multiple envelopes (in particular, assign_rep is passed a letter object and operator= is passed an envelope object).</p>
<p>Use case assumes the incoming letter is instantiated on the fly and has no envelope. This case is modeled after <a class="el" href="classDakota_1_1Iterator.html#aed763b0cfe29d94b0b93e1290431568d" title="Used by the envelope to instantiate the correct letter class.">get_iterator()</a>: a letter is dynamically allocated and passed into assign_rep (its memory management is passed over to the envelope).</p>
<p>If the letter happens to be managed by another envelope, it will persist as long as the last envelope referencing it. </p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a960845f69232cbefef30a3fc32c46525">Iterator::iterator_rep()</a>, and <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1AdaptedBasisModel.html#ac0f34288353dd36807061b177e5b1620">AdaptedBasisModel::AdaptedBasisModel()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#ab792d2d09db0a4ceddc9fab61d386924">NonDBayesCalibration::build_designs()</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#a877351b45b14e40ab17eae7d33d69cca">NonDExpansion::construct_cubature()</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#a850e9f6dc7fb86d674529ce6d896a5e4">NonDExpansion::construct_expansion_sampler()</a>, <a class="el" href="classDakota_1_1NonDAdaptiveSampling.html#a2753b900af38b7b02197da24165104d3">NonDAdaptiveSampling::construct_fsu_sampler()</a>, <a class="el" href="classDakota_1_1NonD.html#a3a67d9aa6ca4d3b984b60cef76a03246">NonD::construct_lhs()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#a6e78293f0243a485edfe5a2978d8ab3c">NonDBayesCalibration::construct_map_optimizer()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#a58f36c91d2dd90dab7d0c6e48a835ebe">NonDBayesCalibration::construct_mcmc_model()</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#a9e59c4816efd569bee3387820b972983">NonDExpansion::construct_quadrature()</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#a98cdb533ff3d1df4f6d1255dfe05eba3">NonDExpansion::construct_sparse_grid()</a>, <a class="el" href="classDakota_1_1Minimizer.html#a93e6ec88067fb37fe1e49586758d28ed">Minimizer::data_transform_model()</a>, <a class="el" href="classDakota_1_1ActiveSubspaceModel.html#afc8df9538bb8fc5533d6944ac9662bde">ActiveSubspaceModel::init_fullspace_sampler()</a>, <a class="el" href="classDakota_1_1EffGlobalMinimizer.html#aad66adfc447bbc0a10a3ae5a60f9d213">EffGlobalMinimizer::initialize_sub_problem()</a>, <a class="el" href="classDakota_1_1NonDLocalInterval.html#a7722d1b6ec982fd26655452e89ef2f8f">NonDLocalInterval::method_recourse()</a>, <a class="el" href="classDakota_1_1NonDLocalReliability.html#a7722d1b6ec982fd26655452e89ef2f8f">NonDLocalReliability::method_recourse()</a>, <a class="el" href="classDakota_1_1NonDAdaptiveSampling.html#ad24430c6645ffe5bc8efe81eb5d369ea">NonDAdaptiveSampling::NonDAdaptiveSampling()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#afbef466ebbeaf7e3769ed95729befdca">NonDBayesCalibration::NonDBayesCalibration()</a>, <a class="el" href="classDakota_1_1NonDGlobalInterval.html#a0dd015e28b9a0ebcce56bd6ef2b494a7">NonDGlobalInterval::NonDGlobalInterval()</a>, <a class="el" href="classDakota_1_1NonDGlobalReliability.html#a877d620c1f4a075cb5bb4da750a0e64a">NonDGlobalReliability::NonDGlobalReliability()</a>, <a class="el" href="classDakota_1_1NonDGPImpSampling.html#a30863d6e2d89aeb6e1fba805ebf6e0ae">NonDGPImpSampling::NonDGPImpSampling()</a>, <a class="el" href="classDakota_1_1NonDGPMSABayesCalibration.html#af6bf8eb9c9c7e0e86c29e6b7fa8b58af">NonDGPMSABayesCalibration::NonDGPMSABayesCalibration()</a>, <a class="el" href="classDakota_1_1NonDLHSInterval.html#ae3c2ebf9d30dfb8234ef69cd5c91b872">NonDLHSInterval::NonDLHSInterval()</a>, <a class="el" href="classDakota_1_1NonDLocalInterval.html#a5198b06d6d1d0ca0d536aab62b2a42f7">NonDLocalInterval::NonDLocalInterval()</a>, <a class="el" href="classDakota_1_1NonDLocalReliability.html#affe855c5e8271691548fcf3ac8b5e7f3">NonDLocalReliability::NonDLocalReliability()</a>, <a class="el" href="classDakota_1_1GaussProcApproximation.html#a84a1dac23978bd34fd631a9ca0d6c155">GaussProcApproximation::optimize_theta_global()</a>, <a class="el" href="classDakota_1_1GaussProcApproximation.html#a88466748e5854917ba582fc84fb3d748">GaussProcApproximation::optimize_theta_multipoint()</a>, and <a class="el" href="classDakota_1_1SurrBasedLocalMinimizer.html#a935b272cb9c100ad22c55cddaa7e81c7">SurrBasedLocalMinimizer::relax_constraints()</a>.</p>

</div>
</div>
<a id="ab4fda5e4a6ba09115a83fd970ae39d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fda5e4a6ba09115a83fd970ae39d5a">&#9670;&nbsp;</a></span>eval_tag_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eval_tag_prefix </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>eval_id_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the hierarchical eval ID tag prefix </p>
<p>This prepend may need to become a virtual function if the tagging should propagate to other subModels or helper Iterators an <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> may contain. </p>

<p class="reference">References <a class="el" href="classDakota_1_1Model.html#ab4fda5e4a6ba09115a83fd970ae39d5a">Model::eval_tag_prefix()</a>, <a class="el" href="classDakota_1_1Iterator.html#a1d92d85a575fee135731f788f4b15adf">Iterator::iteratedModel</a>, and <a class="el" href="classDakota_1_1Iterator.html#a2659afd98baea8973d8b36ca1eaeb2a9">Iterator::iteratorRep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1NestedModel.html#a5f836ab625a3ebd3879b556d0c68b5c0">NestedModel::derived_evaluate()</a>, <a class="el" href="classDakota_1_1Iterator.html#a8c9504dc18cfe37e47c8ced284bbaade">Iterator::init_communicators()</a>, <a class="el" href="classDakota_1_1NestedModel.html#a47da5e0c26ff109507d54e5841d95a11">NestedModel::initialize_iterator()</a>, and <a class="el" href="classDakota_1_1DataFitSurrModel.html#abb523e197e578bbd8e4925f03077b211">DataFitSurrModel::run_dace()</a>.</p>

</div>
</div>
<a id="a98a7fcf8c458c9ccfa7335713ff90067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a7fcf8c458c9ccfa7335713ff90067">&#9670;&nbsp;</a></span>gnewton_set_recast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gnewton_set_recast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDakota_1_1Variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>recast_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;&#160;</td>
          <td class="paramname"><em>recast_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ActiveSet.html">ActiveSet</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_model_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>conversion of request vector values for the Gauss-Newton Hessian approximation </p>
<p>For Gauss-Newton Hessian requests, activate the 2 bit and mask the 4 bit. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ActiveSet.html#a917a574e304f46f087838056ed6359c2">ActiveSet::request_value()</a>, and <a class="el" href="classDakota_1_1ActiveSet.html#a20cc3009b8fb687f23d25d5c78f40fdd">ActiveSet::request_vector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1NonDBayesCalibration.html#a5048481f6d41252e51eca82cd6ae567c">NonDBayesCalibration::construct_map_model()</a>, and <a class="el" href="classDakota_1_1Optimizer.html#a5d5851076f7682606285739e8b25be81">Optimizer::reduce_model()</a>.</p>

</div>
</div>
<a id="a7f894ca56d2c8cb3f951269e3d09884d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f894ca56d2c8cb3f951269e3d09884d">&#9670;&nbsp;</a></span>initialize_model_graphics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_model_graphics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterator_server_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function that encapsulates initialization operations, modular on incoming <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> instance </p>
<p>This is a helper function that provides modularity on incoming <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a>. </p>

<p class="reference">References <a class="el" href="classDakota_1_1Model.html#ac56e11463e5c6be5f8e59f42b28fae2a">Model::auto_graphics()</a>, <a class="el" href="classDakota_1_1Model.html#a9fc81f80aef19d02e6a87661afd43c21">Model::create_2d_plots()</a>, <a class="el" href="classDakota_1_1Model.html#a2314f26ce26da7401ebdb4e06ad51636">Model::create_tabular_datastream()</a>, <a class="el" href="classDakota_1_1OutputManager.html#ab9e12b723509ad551ba11916a32f6c15">OutputManager::graph2DFlag</a>, <a class="el" href="classDakota_1_1ParallelLibrary.html#ae5a5ffac38d3fe61b30fc7b3169d5432">ParallelLibrary::output_manager()</a>, <a class="el" href="classDakota_1_1Iterator.html#a702abf9be22e51f1e67167d5db1b08d3">Iterator::parallelLib</a>, and <a class="el" href="classDakota_1_1OutputManager.html#a7fcb89119da44ad8939c7f5d5c9105f8">OutputManager::tabularDataFlag</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Iterator.html#a58ed7a8dd3339697bf58f09925d6cf36">Iterator::initialize_graphics()</a>, and <a class="el" href="classDakota_1_1SurrBasedGlobalMinimizer.html#a58ed7a8dd3339697bf58f09925d6cf36">SurrBasedGlobalMinimizer::initialize_graphics()</a>.</p>

</div>
</div>
<a id="abba1ace5c0bc19120ea32209524e7342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba1ace5c0bc19120ea32209524e7342">&#9670;&nbsp;</a></span>export_final_surrogates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void export_final_surrogates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>data_fit_surr_model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>export final surrogates generated, e.g., GP in EGO and friends </p>
<p>Protected function to only be called on letters </p>

<p class="reference">References <a class="el" href="namespaceDakota.html#acff531cb7537cad348ae92c039e02d99">Dakota::abort_handler()</a>, <a class="el" href="classDakota_1_1Model.html#a300a59ae653667a9fd7cd962ffd2654a">Model::approximations()</a>, <a class="el" href="classDakota_1_1Model.html#a44e9e83acf165251f5dfdcb54277a4ce">Model::current_variables()</a>, <a class="el" href="classDakota_1_1Iterator.html#aac8650f4b069c5429ff675b25a8aa8f9">Iterator::exportSurrogate</a>, <a class="el" href="classDakota_1_1Model.html#a61fd08e80c345fbef1e0228eaa94c793">Model::response_labels()</a>, <a class="el" href="classDakota_1_1Iterator.html#afb8f9a72cee17bc5a9d6b0f7f622d577">Iterator::surrExportFormat</a>, and <a class="el" href="classDakota_1_1Iterator.html#a816ce730220620c8f42804f2ce78f91e">Iterator::surrExportPrefix</a>.</p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1NonDGlobalInterval.html#a64cdbb1eb9544b4f8a42944a00a222be">NonDGlobalInterval::core_run()</a>, <a class="el" href="classDakota_1_1NonDGlobalReliability.html#a665221b9ea23ccd11e1b7ba21092836d">NonDGlobalReliability::optimize_gaussian_process()</a>, and <a class="el" href="classDakota_1_1EffGlobalMinimizer.html#a1ca267e5f9e5fd05eacd1fd8a1b28e75">EffGlobalMinimizer::retrieve_final_results()</a>.</p>

</div>
</div>
<a id="aed763b0cfe29d94b0b93e1290431568d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed763b0cfe29d94b0b93e1290431568d">&#9670;&nbsp;</a></span>get_iterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; get_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by the envelope to instantiate the correct letter class. </p>
<p>Used only by the envelope constructor to initialize iteratorRep to the appropriate derived type, as given by the DB's method_name. Supports all iterators and meta-iterators. These instantiations will NOT recurse on the Iterator(problem_db) constructor due to the use of <a class="el" href="structDakota_1_1BaseConstructor.html" title="Dummy struct for overloading letter-envelope constructors.">BaseConstructor</a>. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ProblemDescDB.html#a41e106effd29fa8783cfca5212dd284d">ProblemDescDB::get_model()</a>, <a class="el" href="classDakota_1_1ProblemDescDB.html#ad3ea82c15d1bca2480538fb84a216edc">ProblemDescDB::get_ushort()</a>, <a class="el" href="classDakota_1_1Iterator.html#aecb0ca7f340b3b8a6ac4f58ec2101ff8">Iterator::method_name()</a>, and <a class="el" href="namespaceDakota.html#adf764cbdea00d65edcd07bb9953ad2b7aac2e352685ad5b18b1162706a7853bcc">Dakota::SUBMETHOD_COLLABORATIVE</a>.</p>

</div>
</div>
<a id="a15b06d1b485dcd029ccec3c1a91d5b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b06d1b485dcd029ccec3c1a91d5b6f">&#9670;&nbsp;</a></span>get_iterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; get_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a> &amp;&#160;</td>
          <td class="paramname"><em>problem_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by the envelope to instantiate the correct letter class. </p>
<p>Used only by the envelope constructor to initialize iteratorRep to the appropriate derived type. Alternate construction of meta-iterators is supported to enable use of meta-iterators as components. These instantiations will NOT recurse on the Iterator(problem_db, model) constructor due to the use of <a class="el" href="structDakota_1_1BaseConstructor.html" title="Dummy struct for overloading letter-envelope constructors.">BaseConstructor</a>. </p>

<p class="reference">References <a class="el" href="classDakota_1_1ProblemDescDB.html#ad3ea82c15d1bca2480538fb84a216edc">ProblemDescDB::get_ushort()</a>, <a class="el" href="classDakota_1_1Iterator.html#ab6ff02f762983acda51874c5102054f3">Iterator::method_enum_to_string()</a>, <a class="el" href="classDakota_1_1Iterator.html#aecb0ca7f340b3b8a6ac4f58ec2101ff8">Iterator::method_name()</a>, <a class="el" href="classDakota_1_1Iterator.html#ac8b1ee0aacc0b1693fb2c317a4388b46">Iterator::probDescDB</a>, <a class="el" href="namespaceDakota.html#adf764cbdea00d65edcd07bb9953ad2b7aac2e352685ad5b18b1162706a7853bcc">Dakota::SUBMETHOD_COLLABORATIVE</a>, <a class="el" href="classDakota_1_1Iterator.html#ad34bf999ea9daea4224368911cc16af5">Iterator::submethod_enum_to_string()</a>, and <a class="el" href="classDakota_1_1Model.html#a045db39264d4489537dfc1c856e94581">Model::surrogate_type()</a>.</p>

</div>
</div>
<a id="a94631d6f20663903a168403dac63517c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94631d6f20663903a168403dac63517c">&#9670;&nbsp;</a></span>get_iterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classDakota_1_1Iterator.html">Iterator</a> &gt; get_iterator </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>method_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDakota_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by the envelope to instantiate the correct letter class. </p>
<p>Used only by the envelope constructor to initialize iteratorRep to the appropriate derived type, as given by the passed method_string. Lightweight instantiations by name are supported by a subset of Iterators (primarily Minimizers). </p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#ac6a74249485a0713c57bf28869270a86">Iterator::method_string()</a>, <a class="el" href="namespaceDakota.html#ae3b312a8837bf69b5df01a02523f31ca">Dakota::strbegins()</a>, and <a class="el" href="namespaceDakota.html#a751383299fabc9575a2fdef41c299713">Dakota::strends()</a>.</p>

</div>
</div>
<a id="a4d4e14b16b5d0591739b5d573a60249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4e14b16b5d0591739b5d573a60249f">&#9670;&nbsp;</a></span>user_auto_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">String user_auto_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the next available method ID for no-ID user methods </p>
<p>Rationale: The parser allows multiple user-specified methods with empty (unspecified) ID. However, only a single <a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> with empty ID can be constructed (if it's the only one present, or the "last
one parsed"). Therefore decided to prefer NO_METHOD_ID over NO_METHOD_ID_&lt;num&gt; for (partial) consistency with interface NO_ID convention. The addition of <em>METHOD</em> is it distinguish methods, models and interfaces in the HDF5 output. </p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1Iterator.html#a6ac42595c73c833561ab0778ac178cea">Iterator::Iterator()</a>.</p>

</div>
</div>
<a id="a03c6a4eed68adb0ff96f408d09f3a20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c6a4eed68adb0ff96f408d09f3a20e">&#9670;&nbsp;</a></span>no_spec_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">String no_spec_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the next available method ID for on-the-fly methods </p>
<p>Rationale: For now NOSPEC_METHOD_ID_ is chosen due to historical id="NO_SPECIFICATION" used for internally-constructed Iterators. Longer-term, consider auto-generating an ID that includes the context from which the method is constructed, e.g., the parent method or model's ID, together with its name. </p>

<p class="reference">References <a class="el" href="classDakota_1_1Iterator.html#a314c8074450846a9e62d2876f178df74">Iterator::noSpecIdNum</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac8b1ee0aacc0b1693fb2c317a4388b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b1ee0aacc0b1693fb2c317a4388b46">&#9670;&nbsp;</a></span>probDescDB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDakota_1_1ProblemDescDB.html">ProblemDescDB</a>&amp; probDescDB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>class member reference to the problem description database </p>
<p><a class="el" href="classDakota_1_1Iterator.html" title="Base class for the iterator class hierarchy.">Iterator</a> and <a class="el" href="classDakota_1_1Model.html" title="Base class for the model class hierarchy.">Model</a> cannot use a shallow copy of <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> due to circular destruction dependency (reference counts can't get to 0), since <a class="el" href="classDakota_1_1ProblemDescDB.html" title="The database containing information parsed from the DAKOTA input file.">ProblemDescDB</a> contains {iterator,model}List. </p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1MetaIterator.html#a25b47dec56bf692c2077222c89bfb609">MetaIterator::allocate_by_name()</a>, <a class="el" href="classDakota_1_1MetaIterator.html#af2b1bd2aad7aef8718d3e51b157214ec">MetaIterator::allocate_by_pointer()</a>, <a class="el" href="classDakota_1_1Analyzer.html#a0b5356d2e64a3dfd9b8268fc8073fdf2">Analyzer::Analyzer()</a>, <a class="el" href="classDakota_1_1MetaIterator.html#ab857c65940f676e1c1d03d68285644e0">MetaIterator::check_model()</a>, <a class="el" href="classDakota_1_1COLINOptimizer.html#ae81741f35fa2315acaa6c570be1feb6d">COLINOptimizer::COLINOptimizer()</a>, <a class="el" href="classDakota_1_1NonDC3FunctionTrain.html#a9eaeea0353c14cc1419a5f4d5613836e">NonDC3FunctionTrain::config_regression()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#a58f36c91d2dd90dab7d0c6e48a835ebe">NonDBayesCalibration::construct_mcmc_model()</a>, <a class="el" href="classDakota_1_1Minimizer.html#a93e6ec88067fb37fe1e49586758d28ed">Minimizer::data_transform_model()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a707a74f84dfc750d57af34e048c3486f">ConcurrentMetaIterator::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1EmbedHybridMetaIterator.html#a707a74f84dfc750d57af34e048c3486f">EmbedHybridMetaIterator::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1SurrBasedMinimizer.html#a707a74f84dfc750d57af34e048c3486f">SurrBasedMinimizer::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1EffGlobalMinimizer.html#a237777dba6bf0c33f9a81b7bbb0dc19d">EffGlobalMinimizer::EffGlobalMinimizer()</a>, <a class="el" href="classDakota_1_1MetaIterator.html#abd18219e89f3c39bd319c1128de4b9d9">MetaIterator::estimate_by_name()</a>, <a class="el" href="classDakota_1_1MetaIterator.html#a34ea69a0a255211fa9ea53e2144cc035">MetaIterator::estimate_by_pointer()</a>, <a class="el" href="classDakota_1_1CollabHybridMetaIterator.html#a0ed0572b4666dcd0615fad9de1b8fa33">CollabHybridMetaIterator::estimate_partition_bounds()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a0ed0572b4666dcd0615fad9de1b8fa33">ConcurrentMetaIterator::estimate_partition_bounds()</a>, <a class="el" href="classDakota_1_1EmbedHybridMetaIterator.html#a0ed0572b4666dcd0615fad9de1b8fa33">EmbedHybridMetaIterator::estimate_partition_bounds()</a>, <a class="el" href="classDakota_1_1SeqHybridMetaIterator.html#a0ed0572b4666dcd0615fad9de1b8fa33">SeqHybridMetaIterator::estimate_partition_bounds()</a>, <a class="el" href="classDakota_1_1FSUDesignCompExp.html#af82e6a8bb5e5f23d8af8b81171a80861">FSUDesignCompExp::FSUDesignCompExp()</a>, <a class="el" href="classDakota_1_1Optimizer.html#a133888a69c1a044e355b383c803a7809">Optimizer::get_common_stopping_criteria()</a>, <a class="el" href="classDakota_1_1Iterator.html#a15b06d1b485dcd029ccec3c1a91d5b6f">Iterator::get_iterator()</a>, <a class="el" href="classDakota_1_1NonDC3FunctionTrain.html#a38c8d19d76b30bcae5298945ae881beb">NonDC3FunctionTrain::initialize_c3_db_options()</a>, <a class="el" href="classDakota_1_1ConcurrentMetaIterator.html#a331819a0c2dd8a4c7d4a073f11acd1ef">ConcurrentMetaIterator::initialize_model()</a>, <a class="el" href="classDakota_1_1NOWPACOptimizer.html#a64acbd03ee9bd1e54bc955b269277cfe">NOWPACOptimizer::initialize_options()</a>, <a class="el" href="classDakota_1_1SurrBasedLocalMinimizer.html#aa93ac79ceeddadb14af41a5fe7fb44ae">SurrBasedLocalMinimizer::initialize_sub_minimizer()</a>, <a class="el" href="classDakota_1_1JEGAOptimizer.html#af6055e431f9309e633c4fd001eac226e">JEGAOptimizer::JEGAOptimizer()</a>, <a class="el" href="classDakota_1_1NLSSOLLeastSq.html#a95561b0f2803bb37606fd7f004358ee4">NLSSOLLeastSq::NLSSOLLeastSq()</a>, <a class="el" href="classDakota_1_1NonDAdaptImpSampling.html#ae75fd4bbfaec1fcc24a5a0697fc9e1c5">NonDAdaptImpSampling::NonDAdaptImpSampling()</a>, <a class="el" href="classDakota_1_1NonDAdaptiveSampling.html#ad24430c6645ffe5bc8efe81eb5d369ea">NonDAdaptiveSampling::NonDAdaptiveSampling()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#afbef466ebbeaf7e3769ed95729befdca">NonDBayesCalibration::NonDBayesCalibration()</a>, <a class="el" href="classDakota_1_1NonDC3FunctionTrain.html#a763c36aebbfb61c6c9d1e87d00f14f9e">NonDC3FunctionTrain::NonDC3FunctionTrain()</a>, <a class="el" href="classDakota_1_1NonDGlobalInterval.html#a0dd015e28b9a0ebcce56bd6ef2b494a7">NonDGlobalInterval::NonDGlobalInterval()</a>, <a class="el" href="classDakota_1_1NonDGlobalReliability.html#a877d620c1f4a075cb5bb4da750a0e64a">NonDGlobalReliability::NonDGlobalReliability()</a>, <a class="el" href="classDakota_1_1NonDGPImpSampling.html#a30863d6e2d89aeb6e1fba805ebf6e0ae">NonDGPImpSampling::NonDGPImpSampling()</a>, <a class="el" href="classDakota_1_1NonDGPMSABayesCalibration.html#af6bf8eb9c9c7e0e86c29e6b7fa8b58af">NonDGPMSABayesCalibration::NonDGPMSABayesCalibration()</a>, <a class="el" href="classDakota_1_1NonDInterval.html#a360477f67b0ad6ac6a2b2b0f79cc6049">NonDInterval::NonDInterval()</a>, <a class="el" href="classDakota_1_1NonDLocalInterval.html#a5198b06d6d1d0ca0d536aab62b2a42f7">NonDLocalInterval::NonDLocalInterval()</a>, <a class="el" href="classDakota_1_1NonDLocalReliability.html#affe855c5e8271691548fcf3ac8b5e7f3">NonDLocalReliability::NonDLocalReliability()</a>, <a class="el" href="classDakota_1_1NonDMultilevelFunctionTrain.html#a9d0531fc46f709b7f827302a4fdf28e7">NonDMultilevelFunctionTrain::NonDMultilevelFunctionTrain()</a>, <a class="el" href="classDakota_1_1NonDMultilevelPolynomialChaos.html#af55f4096503ab2b5295cabcfb25ed2fb">NonDMultilevelPolynomialChaos::NonDMultilevelPolynomialChaos()</a>, <a class="el" href="classDakota_1_1NonDMultilevelSampling.html#a65c75c37eb9469a6c24989341b1ee1f1">NonDMultilevelSampling::NonDMultilevelSampling()</a>, <a class="el" href="classDakota_1_1NonDMultilevelStochCollocation.html#aaa3ed320d2c542bbcc9d5e4bbed570eb">NonDMultilevelStochCollocation::NonDMultilevelStochCollocation()</a>, <a class="el" href="classDakota_1_1NonDNonHierarchSampling.html#acc485b1b8f97fae1feddfc1acb2ba0e5">NonDNonHierarchSampling::NonDNonHierarchSampling()</a>, <a class="el" href="classDakota_1_1NonDQuadrature.html#adf7487cefc0d0c9f06e599cc61a48971">NonDQuadrature::NonDQuadrature()</a>, <a class="el" href="classDakota_1_1NonDSampling.html#a23d0b6a2cd171142a65d53f77b6e98af">NonDSampling::NonDSampling()</a>, <a class="el" href="classDakota_1_1NonDSparseGrid.html#aac25eef1c87ac855b66f27fba6619d8f">NonDSparseGrid::NonDSparseGrid()</a>, <a class="el" href="classDakota_1_1NonDStochCollocation.html#a708d3d6fa46336572921c3d5ebcc7daf">NonDStochCollocation::NonDStochCollocation()</a>, <a class="el" href="classDakota_1_1NonDSurrogateExpansion.html#add14a62099cd1042a932044840f35a2c">NonDSurrogateExpansion::NonDSurrogateExpansion()</a>, <a class="el" href="classDakota_1_1OptDartsOptimizer.html#a3b74c88636cc05917062ef31a0c5b748">OptDartsOptimizer::OptDartsOptimizer()</a>, <a class="el" href="classDakota_1_1ParamStudy.html#a05e69d3cf53799e1daa91139e91c3f56">ParamStudy::ParamStudy()</a>, <a class="el" href="classDakota_1_1NonDAdaptiveSampling.html#a9a7e968423ea4259cf60fadec2ae6f97">NonDAdaptiveSampling::parse_options()</a>, <a class="el" href="classDakota_1_1NonlinearCGOptimizer.html#a9a7e968423ea4259cf60fadec2ae6f97">NonlinearCGOptimizer::parse_options()</a>, <a class="el" href="classDakota_1_1Iterator.html#a85c8d03d2a72807624d23fd0dc3fe452">Iterator::problem_description_db()</a>, <a class="el" href="classDakota_1_1NonDC3FunctionTrain.html#adccb40b53dca505cc742f8d4975002a2">NonDC3FunctionTrain::resolve_refinement()</a>, <a class="el" href="classDakota_1_1APPSOptimizer.html#aeef32d19cd3ad25a4bef1ce5f3d04733">APPSOptimizer::set_apps_parameters()</a>, <a class="el" href="classDakota_1_1ROLOptimizer.html#ad4a75e679cbbe9ccadadf572137e39f3">ROLOptimizer::set_rol_parameters()</a>, <a class="el" href="classDakota_1_1COLINOptimizer.html#ad8bbb14723b57a00a8178343e969ef7e">COLINOptimizer::set_solver_parameters()</a>, <a class="el" href="classDakota_1_1SNLLLeastSq.html#a280857710d2b3aa00692747c10a2f41b">SNLLLeastSq::SNLLLeastSq()</a>, <a class="el" href="classDakota_1_1SNLLOptimizer.html#a9e4440aef21a8df16c2ad7d9cf63420d">SNLLOptimizer::SNLLOptimizer()</a>, <a class="el" href="classDakota_1_1COLINOptimizer.html#a6994325af491ffa935b34554e422db58">COLINOptimizer::solver_setup()</a>, and <a class="el" href="classDakota_1_1SurrBasedGlobalMinimizer.html#a4bc8d677c662a76eddaa3580e4c6489b">SurrBasedGlobalMinimizer::SurrBasedGlobalMinimizer()</a>.</p>

</div>
</div>
<a id="a7c2b07faf0a3a39201eebcfe83e3a5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2b07faf0a3a39201eebcfe83e3a5f7">&#9670;&nbsp;</a></span>maxEvalConcurrency</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int maxEvalConcurrency</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maximum number of concurrent model evaluations </p>
<p>This is important for parallel configuration init/set/free and may be set within empty envelope instances. Therefore, it cannot be pushed down into Analyzer/Minimizer derived classes. </p>

<p class="reference">Referenced by <a class="el" href="classDakota_1_1NonDPolynomialChaos.html#aab54723a8cadec0775c70e8cdf761ff0">NonDPolynomialChaos::config_expectation()</a>, <a class="el" href="classDakota_1_1NonDPolynomialChaos.html#aa27ab11e1ad9d708b5f8ef10b08278c9">NonDPolynomialChaos::config_regression()</a>, <a class="el" href="classDakota_1_1NonDC3FunctionTrain.html#a9eaeea0353c14cc1419a5f4d5613836e">NonDC3FunctionTrain::config_regression()</a>, <a class="el" href="classDakota_1_1DDACEDesignCompExp.html#afc0b8f56d54932c17619b2b7f08ed064">DDACEDesignCompExp::DDACEDesignCompExp()</a>, <a class="el" href="classDakota_1_1Iterator.html#ac52bd656bac37cbf7cc8926b025a0b5a">Iterator::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NonDAdaptiveSampling.html#ac52bd656bac37cbf7cc8926b025a0b5a">NonDAdaptiveSampling::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#ac52bd656bac37cbf7cc8926b025a0b5a">NonDBayesCalibration::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#ac52bd656bac37cbf7cc8926b025a0b5a">NonDExpansion::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NonDGlobalInterval.html#ac52bd656bac37cbf7cc8926b025a0b5a">NonDGlobalInterval::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NonDGlobalReliability.html#ac52bd656bac37cbf7cc8926b025a0b5a">NonDGlobalReliability::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NonDGPImpSampling.html#ac52bd656bac37cbf7cc8926b025a0b5a">NonDGPImpSampling::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NonDLocalInterval.html#ac52bd656bac37cbf7cc8926b025a0b5a">NonDLocalInterval::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NonDLocalReliability.html#ac52bd656bac37cbf7cc8926b025a0b5a">NonDLocalReliability::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1NonDPolynomialChaos.html#ac52bd656bac37cbf7cc8926b025a0b5a">NonDPolynomialChaos::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1SurrBasedMinimizer.html#ac52bd656bac37cbf7cc8926b025a0b5a">SurrBasedMinimizer::derived_free_communicators()</a>, <a class="el" href="classDakota_1_1Iterator.html#a707a74f84dfc750d57af34e048c3486f">Iterator::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NonDAdaptiveSampling.html#a707a74f84dfc750d57af34e048c3486f">NonDAdaptiveSampling::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#a707a74f84dfc750d57af34e048c3486f">NonDBayesCalibration::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#a707a74f84dfc750d57af34e048c3486f">NonDExpansion::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NonDGlobalInterval.html#a707a74f84dfc750d57af34e048c3486f">NonDGlobalInterval::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NonDGlobalReliability.html#a707a74f84dfc750d57af34e048c3486f">NonDGlobalReliability::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NonDGPImpSampling.html#a707a74f84dfc750d57af34e048c3486f">NonDGPImpSampling::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NonDLocalInterval.html#a707a74f84dfc750d57af34e048c3486f">NonDLocalInterval::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NonDLocalReliability.html#a707a74f84dfc750d57af34e048c3486f">NonDLocalReliability::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1NonDPolynomialChaos.html#a707a74f84dfc750d57af34e048c3486f">NonDPolynomialChaos::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1SurrBasedMinimizer.html#a707a74f84dfc750d57af34e048c3486f">SurrBasedMinimizer::derived_init_communicators()</a>, <a class="el" href="classDakota_1_1Iterator.html#ae89bef5ad711f51ceea37e61bcde54d5">Iterator::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1NonD.html#ae89bef5ad711f51ceea37e61bcde54d5">NonD::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#ae89bef5ad711f51ceea37e61bcde54d5">NonDBayesCalibration::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#ae89bef5ad711f51ceea37e61bcde54d5">NonDExpansion::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1NonDLocalReliability.html#ae89bef5ad711f51ceea37e61bcde54d5">NonDLocalReliability::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1NonDPolynomialChaos.html#ae89bef5ad711f51ceea37e61bcde54d5">NonDPolynomialChaos::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1SurrBasedMinimizer.html#ae89bef5ad711f51ceea37e61bcde54d5">SurrBasedMinimizer::derived_set_communicators()</a>, <a class="el" href="classDakota_1_1Iterator.html#a0ed0572b4666dcd0615fad9de1b8fa33">Iterator::estimate_partition_bounds()</a>, <a class="el" href="classDakota_1_1FSUDesignCompExp.html#af82e6a8bb5e5f23d8af8b81171a80861">FSUDesignCompExp::FSUDesignCompExp()</a>, <a class="el" href="classDakota_1_1NonDCubature.html#a3e8e02a9eed6b756ec9394cc63737eef">NonDCubature::initialize_grid()</a>, <a class="el" href="classDakota_1_1NonDQuadrature.html#a3e8e02a9eed6b756ec9394cc63737eef">NonDQuadrature::initialize_grid()</a>, <a class="el" href="classDakota_1_1NonDSparseGrid.html#a3e8e02a9eed6b756ec9394cc63737eef">NonDSparseGrid::initialize_grid()</a>, <a class="el" href="classDakota_1_1EffGlobalMinimizer.html#aad66adfc447bbc0a10a3ae5a60f9d213">EffGlobalMinimizer::initialize_sub_problem()</a>, <a class="el" href="classDakota_1_1NonDExpansion.html#a31106ed285936db61a0ca80c1770c1ea">NonDExpansion::initialize_u_space_grid()</a>, <a class="el" href="classDakota_1_1JEGAOptimizer.html#af6055e431f9309e633c4fd001eac226e">JEGAOptimizer::JEGAOptimizer()</a>, <a class="el" href="classDakota_1_1Iterator.html#af574c51ff1ee5be0a2c885e851f632d5">Iterator::maximum_evaluation_concurrency()</a>, <a class="el" href="classDakota_1_1NonDAdaptImpSampling.html#ad4afb0d2f082db865eb9e690044c431e">NonDAdaptImpSampling::NonDAdaptImpSampling()</a>, <a class="el" href="classDakota_1_1NonDBayesCalibration.html#afbef466ebbeaf7e3769ed95729befdca">NonDBayesCalibration::NonDBayesCalibration()</a>, <a class="el" href="classDakota_1_1NonDCubature.html#ac6e161e4a991503c488d052b9107aa47">NonDCubature::NonDCubature()</a>, <a class="el" href="classDakota_1_1NonDGlobalInterval.html#a0dd015e28b9a0ebcce56bd6ef2b494a7">NonDGlobalInterval::NonDGlobalInterval()</a>, <a class="el" href="classDakota_1_1NonDGlobalReliability.html#a877d620c1f4a075cb5bb4da750a0e64a">NonDGlobalReliability::NonDGlobalReliability()</a>, <a class="el" href="classDakota_1_1NonDHierarchSampling.html#a3865800dd9e48a93aaf7b8b5eb5c789e">NonDHierarchSampling::NonDHierarchSampling()</a>, <a class="el" href="classDakota_1_1NonDLHSInterval.html#ae3c2ebf9d30dfb8234ef69cd5c91b872">NonDLHSInterval::NonDLHSInterval()</a>, <a class="el" href="classDakota_1_1NonDNonHierarchSampling.html#acc485b1b8f97fae1feddfc1acb2ba0e5">NonDNonHierarchSampling::NonDNonHierarchSampling()</a>, <a class="el" href="classDakota_1_1NonDQuadrature.html#adf7487cefc0d0c9f06e599cc61a48971">NonDQuadrature::NonDQuadrature()</a>, <a class="el" href="classDakota_1_1NonDSampling.html#a23d0b6a2cd171142a65d53f77b6e98af">NonDSampling::NonDSampling()</a>, <a class="el" href="classDakota_1_1NonDSparseGrid.html#aac25eef1c87ac855b66f27fba6619d8f">NonDSparseGrid::NonDSparseGrid()</a>, <a class="el" href="classDakota_1_1Analyzer.html#a27577c3595ab5a70c2ed8b4d7f4a1cc1">Analyzer::num_samples()</a>, <a class="el" href="classDakota_1_1ParamStudy.html#a05e69d3cf53799e1daa91139e91c3f56">ParamStudy::ParamStudy()</a>, <a class="el" href="classDakota_1_1PSUADEDesignCompExp.html#a1f0de2258a37b4ed500a3b831f07d7b0">PSUADEDesignCompExp::PSUADEDesignCompExp()</a>, <a class="el" href="classDakota_1_1Iterator.html#a3f57321282ae3e2d47dddb807166cd4e">Iterator::resize_communicators()</a>, <a class="el" href="classDakota_1_1RichExtrapVerification.html#a0bfc865da7035f62b034c209064892f4">RichExtrapVerification::RichExtrapVerification()</a>, <a class="el" href="classDakota_1_1APPSOptimizer.html#aeef32d19cd3ad25a4bef1ce5f3d04733">APPSOptimizer::set_apps_parameters()</a>, <a class="el" href="classDakota_1_1COLINOptimizer.html#ad8bbb14723b57a00a8178343e969ef7e">COLINOptimizer::set_solver_parameters()</a>, <a class="el" href="classDakota_1_1SNLLOptimizer.html#a9e4440aef21a8df16c2ad7d9cf63420d">SNLLOptimizer::SNLLOptimizer()</a>, and <a class="el" href="classDakota_1_1Iterator.html#a42069156a27a9b284d798357dea97787">Iterator::update_from_model()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>DakotaIterator.hpp</li>
<li>DakotaIterator.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
