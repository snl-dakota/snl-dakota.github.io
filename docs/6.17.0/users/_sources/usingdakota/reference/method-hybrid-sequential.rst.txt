.. _method-hybrid-sequential:

""""""""""
sequential
""""""""""


Methods are run one at a time, in sequence


.. toctree::
   :hidden:
   :maxdepth: 1

   method-hybrid-sequential-method_name_list
   method-hybrid-sequential-method_pointer_list
   method-hybrid-sequential-iterator_servers
   method-hybrid-sequential-iterator_scheduling
   method-hybrid-sequential-processors_per_iterator


**Specification**

- *Alias:* uncoupled 

- *Arguments:* None


**Child Keywords:**

+-------------------------+--------------------+-----------------------------+---------------------------------------------+
| Required/Optional       | Description of     | Dakota Keyword              | Dakota Keyword Description                  |
|                         | Group              |                             |                                             |
+=========================+====================+=============================+=============================================+
| Required (Choose One)   | Sub-method         | `method_name_list`__        | List of Dakota methods to sequentially or   |
|                         | Selection          |                             | collaboratively run                         |
|                         |                    +-----------------------------+---------------------------------------------+
|                         |                    | `method_pointer_list`__     | Pointers to methods to execute sequantially |
|                         |                    |                             | or collaboratively                          |
+-------------------------+--------------------+-----------------------------+---------------------------------------------+
| Optional                                     | `iterator_servers`__        | Specify the number of iterator servers when |
|                                              |                             | Dakota is run in parallel                   |
+----------------------------------------------+-----------------------------+---------------------------------------------+
| Optional                                     | `iterator_scheduling`__     | Specify the scheduling of concurrent        |
|                                              |                             | iterators when Dakota is run in parallel    |
+----------------------------------------------+-----------------------------+---------------------------------------------+
| Optional                                     | `processors_per_iterator`__ | Specify the number of processors per        |
|                                              |                             | iterator server when Dakota is run in       |
|                                              |                             | parallel                                    |
+----------------------------------------------+-----------------------------+---------------------------------------------+

.. __: method-hybrid-sequential-method_name_list.html
__ method-hybrid-sequential-method_pointer_list.html
__ method-hybrid-sequential-iterator_servers.html
__ method-hybrid-sequential-iterator_scheduling.html
__ method-hybrid-sequential-processors_per_iterator.html



**Description**


In the ``sequential`` approach, methods are run one at a time, in
sequence.  The best solutions from one method are used to initialize
the next method.

The sequence of methods (i.e. iterators) to run are specified using
either a ``method_pointer_list`` or a ``method_name_list`` (with optional
``model_pointer_list``). Any number of iterators may be specified.

Method switching is managed through the separate convergence controls
of each method. The number of solutions transferred between methods is
specified by the particular method through its :ref:`method-final_solutions<method-final_solutions>`
method control.

For example, if one sets up a two-level study with a first method
that generates multiple solutions such as a genetic algorithm,
followed by a second method that is initialized only at a single point
such as a gradient-based algorithm, it is possible to take the
multiple solutions generated by the first method and create several
instances of the second method, each one with a different initial
starting point.

The logic governing the transfer of multiple solutions between methods
is as follows:

- if one solution is returned from method A, then one solution is transferred to method B.
- If multiple solutions are returned from method A, and method B can accept multiple solutions as input (for example, as a genetic algorithm population), then one instance of method B is initialized with multiple solutions.
- If multiple solutions are returned from method A but method B only can accept one initial starting point, then method B is run several times, each one with a separate starting point from the results of method A.


